        -:    0:Source:gzip-1.3.c
        -:    0:Graph:gzip-1.3.gcno
        -:    0:Data:gzip-1.3.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:/* Generated by CIL v. 1.7.3 */
        -:    2:/* print_CIL_Input is true */
        -:    3:
        -:    4:struct option {
        -:    5:   char const   *name ;
        -:    6:   int has_arg ;
        -:    7:   int *flag ;
        -:    8:   int val ;
        -:    9:};
        -:   10:typedef void *voidp;
        -:   11:typedef unsigned long size_t;
        -:   12:typedef unsigned long __dev_t;
        -:   13:typedef unsigned int __uid_t;
        -:   14:typedef unsigned int __gid_t;
        -:   15:typedef unsigned long __ino_t;
        -:   16:typedef unsigned int __mode_t;
        -:   17:typedef unsigned long __nlink_t;
        -:   18:typedef long __off_t;
        -:   19:typedef long __off64_t;
        -:   20:typedef long __time_t;
        -:   21:typedef long __blksize_t;
        -:   22:typedef long __blkcnt_t;
        -:   23:typedef long __ssize_t;
        -:   24:typedef long __syscall_slong_t;
        -:   25:struct _IO_FILE;
        -:   26:struct _IO_FILE;
        -:   27:typedef struct _IO_FILE FILE;
        -:   28:typedef void _IO_lock_t;
        -:   29:struct _IO_marker {
        -:   30:   struct _IO_marker *_next ;
        -:   31:   struct _IO_FILE *_sbuf ;
        -:   32:   int _pos ;
        -:   33:};
        -:   34:struct _IO_FILE {
        -:   35:   int _flags ;
        -:   36:   char *_IO_read_ptr ;
        -:   37:   char *_IO_read_end ;
        -:   38:   char *_IO_read_base ;
        -:   39:   char *_IO_write_base ;
        -:   40:   char *_IO_write_ptr ;
        -:   41:   char *_IO_write_end ;
        -:   42:   char *_IO_buf_base ;
        -:   43:   char *_IO_buf_end ;
        -:   44:   char *_IO_save_base ;
        -:   45:   char *_IO_backup_base ;
        -:   46:   char *_IO_save_end ;
        -:   47:   struct _IO_marker *_markers ;
        -:   48:   struct _IO_FILE *_chain ;
        -:   49:   int _fileno ;
        -:   50:   int _flags2 ;
        -:   51:   __off_t _old_offset ;
        -:   52:   unsigned short _cur_column ;
        -:   53:   signed char _vtable_offset ;
        -:   54:   char _shortbuf[1] ;
        -:   55:   _IO_lock_t *_lock ;
        -:   56:   __off64_t _offset ;
        -:   57:   void *__pad1 ;
        -:   58:   void *__pad2 ;
        -:   59:   void *__pad3 ;
        -:   60:   void *__pad4 ;
        -:   61:   size_t __pad5 ;
        -:   62:   int _mode ;
        -:   63:   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
        -:   64:};
        -:   65:typedef struct _IO_FILE _IO_FILE;
        -:   66:typedef __off_t off_t;
        -:   67:typedef __ssize_t ssize_t;
        -:   68:typedef __time_t time_t;
        -:   69:struct timespec {
        -:   70:   __time_t tv_sec ;
        -:   71:   __syscall_slong_t tv_nsec ;
        -:   72:};
        -:   73:typedef unsigned char uch;
        -:   74:typedef unsigned short ush;
        -:   75:typedef unsigned long ulg;
        -:   76:typedef int file_t;
        -:   77:struct stat {
        -:   78:   __dev_t st_dev ;
        -:   79:   __ino_t st_ino ;
        -:   80:   __nlink_t st_nlink ;
        -:   81:   __mode_t st_mode ;
        -:   82:   __uid_t st_uid ;
        -:   83:   __gid_t st_gid ;
        -:   84:   int __pad0 ;
        -:   85:   __dev_t st_rdev ;
        -:   86:   __off_t st_size ;
        -:   87:   __blksize_t st_blksize ;
        -:   88:   __blkcnt_t st_blocks ;
        -:   89:   struct timespec st_atim ;
        -:   90:   struct timespec st_mtim ;
        -:   91:   struct timespec st_ctim ;
        -:   92:   __syscall_slong_t __glibc_reserved[3] ;
        -:   93:};
        -:   94:typedef void (*__sighandler_t)(int  );
        -:   95:typedef ush Pos;
        -:   96:typedef unsigned int IPos;
        -:   97:struct config {
        -:   98:   ush good_length ;
        -:   99:   ush max_lazy ;
        -:  100:   ush nice_length ;
        -:  101:   ush max_chain ;
        -:  102:};
        -:  103:typedef struct config config;
        -:  104:struct huft;
        -:  105:union __anonunion_v_51 {
        -:  106:   ush n ;
        -:  107:   struct huft *t ;
        -:  108:};
        -:  109:struct huft {
        -:  110:   uch e ;
        -:  111:   uch b ;
        -:  112:   union __anonunion_v_51 v ;
        -:  113:};
        -:  114:union __anonunion_fc_52 {
        -:  115:   ush freq ;
        -:  116:   ush code ;
        -:  117:};
        -:  118:union __anonunion_dl_53 {
        -:  119:   ush dad ;
        -:  120:   ush len ;
        -:  121:};
        -:  122:struct ct_data {
        -:  123:   union __anonunion_fc_52 fc ;
        -:  124:   union __anonunion_dl_53 dl ;
        -:  125:};
        -:  126:typedef struct ct_data ct_data;
        -:  127:struct tree_desc {
        -:  128:   ct_data *dyn_tree ;
        -:  129:   ct_data *static_tree ;
        -:  130:   int *extra_bits ;
        -:  131:   int extra_base ;
        -:  132:   int elems ;
        -:  133:   int max_length ;
        -:  134:   int max_code ;
        -:  135:};
        -:  136:typedef struct tree_desc tree_desc;
        -:  137:typedef unsigned char char_type;
        -:  138:typedef long code_int;
        -:  139:typedef unsigned long cmp_code_int;
        -:  140:struct dirent {
        -:  141:   __ino_t d_ino ;
        -:  142:   __off_t d_off ;
        -:  143:   unsigned short d_reclen ;
        -:  144:   unsigned char d_type ;
        -:  145:   char d_name[256] ;
        -:  146:};
        -:  147:struct __dirstream;
        -:  148:struct __dirstream;
        -:  149:typedef struct __dirstream DIR;
        -:  150:struct utimbuf {
        -:  151:   __time_t actime ;
        -:  152:   __time_t modtime ;
        -:  153:};
        -:  154:#pragma merger("0","/tmp/cil-ZS5KSGrl.i","")
        -:  155:extern char *optarg ;
        -:  156:extern int optind ;
        -:  157:extern int getopt_long(int __argc , char * const  *__argv , char const   *__shortopts ,
        -:  158:                       struct option  const  *__longopts , int *__longind ) ;
        -:  159:extern int _IO_putc(int __c , _IO_FILE *__fp ) ;
        -:  160:extern struct _IO_FILE *stdin ;
        -:  161:extern struct _IO_FILE *stdout ;
        -:  162:extern struct _IO_FILE *stderr ;
        -:  163:extern int fflush(FILE *__stream ) ;
        -:  164:extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
        -:  165:                   , ...) ;
        -:  166:extern int printf(char const   * __restrict  __format  , ...) ;
        -:  167:extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
        -:  168:extern void perror(char const   *__s ) ;
        -:  169:extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) fileno)(FILE *__stream ) ;
        -:  170:extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
        -:  171:                                                                                                 void const   * __restrict  __src ,
        -:  172:                                                                                                 size_t __n ) ;
        -:  173:extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
        -:  174:                                                                                               int __c ,
        -:  175:                                                                                               size_t __n ) ;
        -:  176:extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) memcmp)(void const   *__s1 ,
        -:  177:                                                                                               void const   *__s2 ,
        -:  178:                                                                                               size_t __n )  __attribute__((__pure__)) ;
        -:  179:extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
        -:  180:                                                                                                 char const   * __restrict  __src ) ;
        -:  181:extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcat)(char * __restrict  __dest ,
        -:  182:                                                                                                 char const   * __restrict  __src ) ;
        -:  183:extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
        -:  184:                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
        -:  185:extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
        -:  186:                                                                                                char const   *__s2 ,
        -:  187:                                                                                                size_t __n )  __attribute__((__pure__)) ;
        -:  188:extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strrchr)(char const   *__s ,
        -:  189:                                                                                                int __c )  __attribute__((__pure__)) ;
        -:  190:extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1,2), __leaf__)) strcspn)(char const   *__s ,
        -:  191:                                                                                                   char const   *__reject )  __attribute__((__pure__)) ;
        -:  192:extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1,2), __leaf__)) strspn)(char const   *__s ,
        -:  193:                                                                                                  char const   *__accept )  __attribute__((__pure__)) ;
        -:  194:extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
        -:  195:int method ;
        -:  196:uch inbuf[32832]  ;
        -:  197:uch outbuf[18432]  ;
        -:  198:ush d_buf[32768]  ;
        -:  199:uch window[65536L]  ;
        -:  200:ush prev[1L << 16]  ;
        -:  201:unsigned int insize  ;
        -:  202:unsigned int inptr  ;
        -:  203:unsigned int outcnt  ;
        -:  204:off_t bytes_in  ;
        -:  205:off_t bytes_out  ;
        -:  206:off_t header_bytes  ;
        -:  207:int ifd  ;
        -:  208:int ofd  ;
        -:  209:char ifname[1024]  ;
        -:  210:char ofname[1024]  ;
        -:  211:char *progname  ;
        -:  212:time_t time_stamp  ;
        -:  213:off_t ifile_size  ;
        -:  214:int decrypt  ;
        -:  215:int exit_code ;
        -:  216:int verbose ;
        -:  217:int quiet ;
        -:  218:int level ;
        -:  219:int test ;
        -:  220:int to_stdout ;
        -:  221:int save_orig_name  ;
        -:  222:int zip(int in , int out ) ;
        -:  223:int file_read(char *buf , unsigned int size ) ;
        -:  224:int unzip(int in , int out ) ;
        -:  225:int check_zipfile(int in ) ;
        -:  226:int unpack(int in , int out ) ;
        -:  227:int unlzh(int in , int out ) ;
        -:  228:void abort_gzip(void) ;
        -:  229:void lm_init(int pack_level , ush *flags___0 ) ;
        -:  230:off_t deflate(void) ;
        -:  231:void ct_init(ush *attr , int *methodp ) ;
        -:  232:int ct_tally(int dist , int lc ) ;
        -:  233:off_t flush_block(char *buf , ulg stored_len , int eof ) ;
        -:  234:void bi_init(file_t zipfile ) ;
        -:  235:void send_bits(int value , int length ) ;
        -:  236:unsigned int bi_reverse(unsigned int code , int len ) ;
        -:  237:void bi_windup(void) ;
        -:  238:void copy_block(char *buf , unsigned int len , int header ) ;
        -:  239:int (*read_buf)(char *buf , unsigned int size )  ;
        -:  240:int copy(int in , int out ) ;
        -:  241:ulg updcrc(uch *s , unsigned int n ) ;
        -:  242:void clear_bufs(void) ;
        -:  243:int fill_inbuf(int eof_ok ) ;
        -:  244:void flush_outbuf(void) ;
        -:  245:void flush_window(void) ;
        -:  246:void write_buf(int fd , voidp buf , unsigned int cnt ) ;
        -:  247:char *strlwr(char *s ) ;
        -:  248:char *base_name(char *fname ) ;
        -:  249:int xunlink(char *filename ) ;
        -:  250:void make_simple_name(char *name ) ;
        -:  251:char *add_envopt(int *argcp , char ***argvp , char *env___0 ) ;
        -:  252:void error(char *m ) ;
        -:  253:void warning(char *m ) ;
        -:  254:void read_error(void) ;
        -:  255:void write_error(void) ;
        -:  256:void display_ratio(off_t num , off_t den , FILE *file ) ;
        -:  257:void fprint_off(FILE *file , off_t offset , int width ) ;
        -:  258:voidp xmalloc(unsigned int size ) ;
        -:  259:int inflate(void) ;
        -:  260:int maxbits ;
        -:  261:int block_mode ;
        -:  262:int lzw(int in , int out ) ;
        -:  263:int unlzw(int in , int out ) ;
        -:  264:extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
        -:  265:extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tolower)(int __c ) ;
        -:  266:extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) stat)(char const   * __restrict  __file ,
        -:  267:                                                                                             struct stat * __restrict  __buf ) ;
        -:  268:extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) fstat)(int __fd ,
        -:  269:                                                                                            struct stat *__buf ) ;
        -:  270:extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) chmod)(char const   *__file ,
        -:  271:                                                                                            __mode_t __mode ) ;
        -:  272:extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
        -:  273:extern  __attribute__((__nothrow__)) __sighandler_t ( __attribute__((__leaf__)) signal)(int __sig ,
        -:  274:                                                                                        void (*__handler)(int  ) ) ;
        -:  275:static file_t zfile  ;
        -:  276:static unsigned short bi_buf  ;
        -:  277:static int bi_valid  ;
        1:  278:void bi_init(file_t zipfile ) 
        -:  279:{ 
        -:  280:
        -:  281:
        -:  282:  {
        1:  283:  zfile = zipfile;
        1:  284:  bi_buf = (unsigned short)0;
        1:  285:  bi_valid = 0;
        1:  286:  if (zfile != -1) {
        1:  287:    read_buf = & file_read;
        1:  288:  }
        1:  289:  return;
        -:  290:}
        -:  291:}
    16572:  292:void send_bits(int value , int length ) 
        -:  293:{ 
        -:  294:  unsigned int tmp ;
        -:  295:  unsigned int tmp___0 ;
        -:  296:  unsigned int tmp___1 ;
        -:  297:  unsigned int tmp___2 ;
        -:  298:
        -:  299:  {
    16572:  300:  if (bi_valid > (int )(16UL * sizeof(char )) - length) {
     6013:  301:    bi_buf = (unsigned short )((int )bi_buf | (value << bi_valid));
     6013:  302:    if (outcnt < 16382U) {
     6013:  303:      tmp = outcnt;
     6013:  304:      outcnt ++;
     6013:  305:      outbuf[tmp] = (uch )((int )bi_buf & 255);
     6013:  306:      tmp___0 = outcnt;
     6013:  307:      outcnt ++;
     6013:  308:      outbuf[tmp___0] = (uch )((int )bi_buf >> 8);
     6013:  309:    } else {
    #####:  310:      tmp___1 = outcnt;
    #####:  311:      outcnt ++;
    #####:  312:      outbuf[tmp___1] = (uch )((int )bi_buf & 255);
    #####:  313:      if (outcnt == 16384U) {
        -:  314:        {
    #####:  315:        flush_outbuf();
        -:  316:        }
    #####:  317:      }
    #####:  318:      tmp___2 = outcnt;
    #####:  319:      outcnt ++;
    #####:  320:      outbuf[tmp___2] = (uch )((int )bi_buf >> 8);
    #####:  321:      if (outcnt == 16384U) {
        -:  322:        {
    #####:  323:        flush_outbuf();
        -:  324:        }
    #####:  325:      }
        -:  326:    }
     6013:  327:    bi_buf = (unsigned short )((int )((ush )value) >> (16UL * sizeof(char ) - (unsigned long )bi_valid));
     6013:  328:    bi_valid = (int )((unsigned long )bi_valid + ((unsigned long )length - 16UL * sizeof(char )));
     6013:  329:  } else {
    10559:  330:    bi_buf = (unsigned short )((int )bi_buf | (value << bi_valid));
    10559:  331:    bi_valid += length;
        -:  332:  }
    16572:  333:  return;
        -:  334:}
        -:  335:}
      474:  336:unsigned int bi_reverse(unsigned int code , int len ) 
        -:  337:{ 
        -:  338:  register unsigned int res ;
        -:  339:
        -:  340:  {
      474:  341:  res = 0U;
        -:  342:  {
     3738:  343:  while (1) {
        -:  344:    while_continue: /* CIL Label */ ;
     3738:  345:    res |= code & 1U;
     3738:  346:    code >>= 1;
     3738:  347:    res <<= 1;
     3738:  348:    len --;
     3738:  349:    if (! (len > 0)) {
      474:  350:      goto while_break;
        -:  351:    }
        -:  352:  }
        -:  353:  while_break: /* CIL Label */ ;
        -:  354:  }
      474:  355:  return (res >> 1);
        -:  356:}
        -:  357:}
        1:  358:void bi_windup(void) 
        -:  359:{ 
        -:  360:  unsigned int tmp ;
        -:  361:  unsigned int tmp___0 ;
        -:  362:  unsigned int tmp___1 ;
        -:  363:  unsigned int tmp___2 ;
        -:  364:  unsigned int tmp___3 ;
        -:  365:
        -:  366:  {
        1:  367:  if (bi_valid > 8) {
        1:  368:    if (outcnt < 16382U) {
        1:  369:      tmp = outcnt;
        1:  370:      outcnt ++;
        1:  371:      outbuf[tmp] = (uch )((int )bi_buf & 255);
        1:  372:      tmp___0 = outcnt;
        1:  373:      outcnt ++;
        1:  374:      outbuf[tmp___0] = (uch )((int )bi_buf >> 8);
        1:  375:    } else {
    #####:  376:      tmp___1 = outcnt;
    #####:  377:      outcnt ++;
    #####:  378:      outbuf[tmp___1] = (uch )((int )bi_buf & 255);
    #####:  379:      if (outcnt == 16384U) {
        -:  380:        {
    #####:  381:        flush_outbuf();
        -:  382:        }
    #####:  383:      }
    #####:  384:      tmp___2 = outcnt;
    #####:  385:      outcnt ++;
    #####:  386:      outbuf[tmp___2] = (uch )((int )bi_buf >> 8);
    #####:  387:      if (outcnt == 16384U) {
        -:  388:        {
    #####:  389:        flush_outbuf();
        -:  390:        }
    #####:  391:      }
        -:  392:    }
        1:  393:  } else { //Added block
    #####:  394:  if (bi_valid > 0) {
    #####:  395:    tmp___3 = outcnt;
    #####:  396:    outcnt ++;
    #####:  397:    outbuf[tmp___3] = (uch )bi_buf;
    #####:  398:    if (outcnt == 16384U) {
        -:  399:      {
    #####:  400:      flush_outbuf();
        -:  401:      }
    #####:  402:    }
    #####:  403:  }
        -:  404:  }
        1:  405:  bi_buf = (unsigned short)0;
        1:  406:  bi_valid = 0;
        1:  407:  return;
        -:  408:}
        -:  409:}
    #####:  410:void copy_block(char *buf , unsigned int len , int header ) 
        -:  411:{ 
        -:  412:  unsigned int tmp ;
        -:  413:  unsigned int tmp___0 ;
        -:  414:  unsigned int tmp___1 ;
        -:  415:  unsigned int tmp___2 ;
        -:  416:  unsigned int tmp___3 ;
        -:  417:  unsigned int tmp___4 ;
        -:  418:  unsigned int tmp___5 ;
        -:  419:  unsigned int tmp___6 ;
        -:  420:  unsigned int tmp___7 ;
        -:  421:  char *tmp___8 ;
        -:  422:  unsigned int tmp___9 ;
        -:  423:
        -:  424:  {
        -:  425:  {
    #####:  426:  bi_windup();
        -:  427:  }
    #####:  428:  if (header) {
    #####:  429:    if (outcnt < 16382U) {
    #####:  430:      tmp = outcnt;
    #####:  431:      outcnt ++;
    #####:  432:      outbuf[tmp] = (uch )((int )((ush )len) & 255);
    #####:  433:      tmp___0 = outcnt;
    #####:  434:      outcnt ++;
    #####:  435:      outbuf[tmp___0] = (uch )((int )((ush )len) >> 8);
    #####:  436:    } else {
    #####:  437:      tmp___1 = outcnt;
    #####:  438:      outcnt ++;
    #####:  439:      outbuf[tmp___1] = (uch )((int )((ush )len) & 255);
    #####:  440:      if (outcnt == 16384U) {
        -:  441:        {
    #####:  442:        flush_outbuf();
        -:  443:        }
    #####:  444:      }
    #####:  445:      tmp___2 = outcnt;
    #####:  446:      outcnt ++;
    #####:  447:      outbuf[tmp___2] = (uch )((int )((ush )len) >> 8);
    #####:  448:      if (outcnt == 16384U) {
        -:  449:        {
    #####:  450:        flush_outbuf();
        -:  451:        }
    #####:  452:      }
        -:  453:    }
    #####:  454:    if (outcnt < 16382U) {
    #####:  455:      tmp___3 = outcnt;
    #####:  456:      outcnt ++;
    #####:  457:      outbuf[tmp___3] = (uch )((int )((ush )(~ len)) & 255);
    #####:  458:      tmp___4 = outcnt;
    #####:  459:      outcnt ++;
    #####:  460:      outbuf[tmp___4] = (uch )((int )((ush )(~ len)) >> 8);
    #####:  461:    } else {
    #####:  462:      tmp___5 = outcnt;
    #####:  463:      outcnt ++;
    #####:  464:      outbuf[tmp___5] = (uch )((int )((ush )(~ len)) & 255);
    #####:  465:      if (outcnt == 16384U) {
        -:  466:        {
    #####:  467:        flush_outbuf();
        -:  468:        }
    #####:  469:      }
    #####:  470:      tmp___6 = outcnt;
    #####:  471:      outcnt ++;
    #####:  472:      outbuf[tmp___6] = (uch )((int )((ush )(~ len)) >> 8);
    #####:  473:      if (outcnt == 16384U) {
        -:  474:        {
    #####:  475:        flush_outbuf();
        -:  476:        }
    #####:  477:      }
        -:  478:    }
    #####:  479:  }
        -:  480:  {
    #####:  481:  while (1) {
        -:  482:    while_continue: /* CIL Label */ ;
    #####:  483:    tmp___9 = len;
    #####:  484:    len --;
    #####:  485:    if (! tmp___9) {
    #####:  486:      goto while_break;
        -:  487:    }
    #####:  488:    tmp___7 = outcnt;
    #####:  489:    outcnt ++;
    #####:  490:    tmp___8 = buf;
    #####:  491:    buf ++;
    #####:  492:    outbuf[tmp___7] = (uch )*tmp___8;
    #####:  493:    if (outcnt == 16384U) {
        -:  494:      {
    #####:  495:      flush_outbuf();
        -:  496:      }
    #####:  497:    }
        -:  498:  }
        -:  499:  while_break: /* CIL Label */ ;
        -:  500:  }
    #####:  501:  return;
        -:  502:}
        -:  503:}
        -:  504:ulg window_size  =    65536UL;
        -:  505:long block_start  ;
        -:  506:static unsigned int ins_h  ;
        -:  507:unsigned int prev_length  ;
        -:  508:unsigned int strstart  ;
        -:  509:unsigned int match_start  ;
        -:  510:static int eofile  ;
        -:  511:static unsigned int lookahead  ;
        -:  512:unsigned int max_chain_length  ;
        -:  513:static unsigned int max_lazy_match  ;
        -:  514:static int compr_level  ;
        -:  515:unsigned int good_match  ;
        -:  516:int nice_match  ;
        -:  517:static config configuration_table[10]  = 
        -:  518:  {      {(ush )0, (ush )0, (ush )0, (ush )0}, 
        -:  519:        {(ush )4, (ush )4, (ush )8, (ush )4}, 
        -:  520:        {(ush )4, (ush )5, (ush )16, (ush )8}, 
        -:  521:        {(ush )4, (ush )6, (ush )32, (ush )32}, 
        -:  522:        {(ush )4, (ush )4, (ush )16, (ush )16}, 
        -:  523:        {(ush )8, (ush )16, (ush )32, (ush )32}, 
        -:  524:        {(ush )8, (ush )16, (ush )128, (ush )128}, 
        -:  525:        {(ush )8, (ush )32, (ush )128, (ush )256}, 
        -:  526:        {(ush )32, (ush )128, (ush )258, (ush )1024}, 
        -:  527:        {(ush )32, (ush )258, (ush )258, (ush )4096}};
        -:  528:static void fill_window(void) ;
        -:  529:static off_t deflate_fast(void) ;
        -:  530:int longest_match(IPos cur_match ) ;
        1:  531:void lm_init(int pack_level , ush *flags___0 ) 
        -:  532:{ 
        -:  533:  register unsigned int j___0 ;
        -:  534:  unsigned int tmp ;
        -:  535:  int tmp___0 ;
        -:  536:
        -:  537:  {
        1:  538:  if (pack_level < 1) {
        -:  539:    {
    #####:  540:    error((char *)"bad pack level");
        -:  541:    }
    #####:  542:  } else { //Added block
        1:  543:  if (pack_level > 9) {
        -:  544:    {
    #####:  545:    error((char *)"bad pack level");
        -:  546:    }
    #####:  547:  }
        -:  548:  }
        -:  549:  {
        1:  550:  compr_level = pack_level;
        1:  551:  memset((voidp )((char *)(prev + 32768)), 0, (unsigned long )((unsigned int )(1 << 15)) * sizeof(*(prev + 32768)));
        1:  552:  max_lazy_match = (unsigned int )configuration_table[pack_level].max_lazy;
        1:  553:  good_match = (unsigned int )configuration_table[pack_level].good_length;
        1:  554:  nice_match = (int )configuration_table[pack_level].nice_length;
        1:  555:  max_chain_length = (unsigned int )configuration_table[pack_level].max_chain;
        -:  556:  }
        1:  557:  if (pack_level == 1) {
    #####:  558:    *flags___0 = (ush )((int )*flags___0 | 4);
    #####:  559:  } else { //Added block
        1:  560:  if (pack_level == 9) {
    #####:  561:    *flags___0 = (ush )((int )*flags___0 | 2);
    #####:  562:  }
        -:  563:  }
        1:  564:  strstart = 0U;
        1:  565:  block_start = 0L;
        -:  566:  if (sizeof(int ) <= 2UL) {
        -:  567:    tmp = 32768U;
        -:  568:  } else {
        1:  569:    tmp = 65536U;
        -:  570:  }
        -:  571:  {
        1:  572:  tmp___0 = (*read_buf)((char *)(window), tmp);
        1:  573:  lookahead = (unsigned int )tmp___0;
        -:  574:  }
        1:  575:  if (lookahead == 0U) {
    #####:  576:    eofile = 1;
    #####:  577:    lookahead = 0U;
    #####:  578:    return;
        -:  579:  } else { //Added block
        1:  580:  if (lookahead == 4294967295U) {
    #####:  581:    eofile = 1;
    #####:  582:    lookahead = 0U;
    #####:  583:    return;
        -:  584:  }
        -:  585:  }
        1:  586:  eofile = 0;
        -:  587:  {
        1:  588:  while (1) {
        -:  589:    while_continue: /* CIL Label */ ;
        1:  590:    if (lookahead < 262U) {
    #####:  591:      if (! (! eofile)) {
    #####:  592:        goto while_break;
        -:  593:      }
    #####:  594:    } else {
        1:  595:      goto while_break;
        -:  596:    }
        -:  597:    {
    #####:  598:    fill_window();
        -:  599:    }
        -:  600:  }
        -:  601:  while_break: /* CIL Label */ ;
        -:  602:  }
        1:  603:  ins_h = 0U;
        1:  604:  j___0 = 0U;
        -:  605:  {
        3:  606:  while (1) {
        -:  607:    while_continue___0: /* CIL Label */ ;
        3:  608:    if (! (j___0 < 2U)) {
        1:  609:      goto while_break___0;
        -:  610:    }
        2:  611:    ins_h = ((ins_h << 5) ^ (unsigned int )window[j___0]) & ((unsigned int )(1 << 15) - 1U);
        2:  612:    j___0 ++;
        -:  613:  }
        -:  614:  while_break___0: /* CIL Label */ ;
        -:  615:  }
        1:  616:  return;
        -:  617:}
        1:  618:}
     9037:  619:int longest_match(IPos cur_match ) 
        -:  620:{ 
        -:  621:  unsigned int chain_length ;
        -:  622:  register uch *scan ;
        -:  623:  register uch *match ;
        -:  624:  register int len ;
        -:  625:  int best_len ;
        -:  626:  IPos limit ;
        -:  627:  unsigned int tmp ;
        -:  628:  register uch *strend ;
        -:  629:  register uch scan_end1 ;
        -:  630:  register uch scan_end ;
        -:  631:
        -:  632:  {
     9037:  633:  chain_length = max_chain_length;
     9037:  634:  scan = window + strstart;
     9037:  635:  best_len = (int )prev_length;
     9037:  636:  if (strstart > 32506U) {
      391:  637:    tmp = strstart - 32506U;
      391:  638:  } else {
     8646:  639:    tmp = 0U;
        -:  640:  }
     9037:  641:  limit = tmp;
     9037:  642:  strend = (window + strstart) + 258;
     9037:  643:  scan_end1 = *(scan + (best_len - 1));
     9037:  644:  scan_end = *(scan + best_len);
     9037:  645:  if (prev_length >= good_match) {
     1279:  646:    chain_length >>= 2;
     1279:  647:  }
        -:  648:  {
   211931:  649:  while (1) {
        -:  650:    while_continue: /* CIL Label */ ;
   211931:  651:    match = window + cur_match;
   211931:  652:    if ((int )*(match + best_len) != (int )scan_end) {
   190926:  653:      goto __Cont;
        -:  654:    } else { //Added block
    21005:  655:    if ((int )*(match + (best_len - 1)) != (int )scan_end1) {
     9408:  656:      goto __Cont;
        -:  657:    } else { //Added block
    11597:  658:    if ((int )*match != (int )*scan) {
     3111:  659:      goto __Cont;
        -:  660:    } else {
     8486:  661:      match ++;
     8486:  662:      if ((int )*match != (int )*(scan + 1)) {
    #####:  663:        goto __Cont;
        -:  664:      }
        -:  665:    }
        -:  666:    }
        -:  667:    }
     8486:  668:    scan += 2;
     8486:  669:    match ++;
        -:  670:    {
     9595:  671:    while (1) {
        -:  672:      while_continue___0: /* CIL Label */ ;
     9595:  673:      scan ++;
     9595:  674:      match ++;
     9595:  675:      if ((int )*scan == (int )*match) {
     6866:  676:        scan ++;
     6866:  677:        match ++;
     6866:  678:        if ((int )*scan == (int )*match) {
     5154:  679:          scan ++;
     5154:  680:          match ++;
     5154:  681:          if ((int )*scan == (int )*match) {
     3978:  682:            scan ++;
     3978:  683:            match ++;
     3978:  684:            if ((int )*scan == (int )*match) {
     2966:  685:              scan ++;
     2966:  686:              match ++;
     2966:  687:              if ((int )*scan == (int )*match) {
     2289:  688:                scan ++;
     2289:  689:                match ++;
     2289:  690:                if ((int )*scan == (int )*match) {
     1749:  691:                  scan ++;
     1749:  692:                  match ++;
     1749:  693:                  if ((int )*scan == (int )*match) {
     1387:  694:                    scan ++;
     1387:  695:                    match ++;
     1387:  696:                    if ((int )*scan == (int )*match) {
     1110:  697:                      if (! ((unsigned long )scan < (unsigned long )strend)) {
        1:  698:                        goto while_break___0;
        -:  699:                      }
     1109:  700:                    } else {
      277:  701:                      goto while_break___0;
        -:  702:                    }
     1109:  703:                  } else {
      362:  704:                    goto while_break___0;
        -:  705:                  }
     1109:  706:                } else {
      540:  707:                  goto while_break___0;
        -:  708:                }
     1109:  709:              } else {
      677:  710:                goto while_break___0;
        -:  711:              }
     1109:  712:            } else {
     1012:  713:              goto while_break___0;
        -:  714:            }
     1109:  715:          } else {
     1176:  716:            goto while_break___0;
        -:  717:          }
     1109:  718:        } else {
     1712:  719:          goto while_break___0;
        -:  720:        }
     1109:  721:      } else {
     2729:  722:        goto while_break___0;
        -:  723:      }
        -:  724:    }
        -:  725:    while_break___0: /* CIL Label */ ;
        -:  726:    }
     8486:  727:    len = 258 - (int )(strend - scan);
     8486:  728:    scan = strend - 258;
    16174:  729:    if (len > best_len) {
     7690:  730:      match_start = cur_match;
     7690:  731:      best_len = len;
     7690:  732:      if (len >= nice_match) {
        2:  733:        goto while_break;
        -:  734:      }
     7688:  735:      scan_end1 = *(scan + (best_len - 1));
     7688:  736:      scan_end = *(scan + best_len);
     7688:  737:    }
        -:  738:    __Cont: 
   211929:  739:    cur_match = (IPos )prev[cur_match & 32767U];
   211929:  740:    if (cur_match > limit) {
   203777:  741:      chain_length --;
   203777:  742:      if (! (chain_length != 0U)) {
      883:  743:        goto while_break;
        -:  744:      }
   202894:  745:    } else {
     8152:  746:      goto while_break;
        -:  747:    }
        -:  748:  }
        -:  749:  while_break: /* CIL Label */ ;
        -:  750:  }
     9037:  751:  return (best_len);
        -:  752:}
        -:  753:}
        1:  754:static void fill_window(void) 
        -:  755:{ 
        -:  756:  register unsigned int n ;
        -:  757:  register unsigned int m ;
        -:  758:  unsigned int more ;
        -:  759:  unsigned int tmp ;
        -:  760:  unsigned int tmp___0 ;
        -:  761:  int tmp___1 ;
        -:  762:
        -:  763:  {
        1:  764:  more = (unsigned int )((window_size - (ulg )lookahead) - (ulg )strstart);
        1:  765:  if (more == 4294967295U) {
    #####:  766:    more --;
    #####:  767:  } else { //Added block
        1:  768:  if (strstart >= 65274U) {
        -:  769:    {
    #####:  770:    memcpy((void * __restrict  )((char *)(window)), (void const   * __restrict  )((char *)(window) + 32768),
        -:  771:           (size_t )32768U);
    #####:  772:    match_start -= 32768U;
    #####:  773:    strstart -= 32768U;
    #####:  774:    block_start -= 32768L;
    #####:  775:    n = 0U;
        -:  776:    }
        -:  777:    {
    #####:  778:    while (1) {
        -:  779:      while_continue: /* CIL Label */ ;
    #####:  780:      if (! (n < (unsigned int )(1 << 15))) {
    #####:  781:        goto while_break;
        -:  782:      }
    #####:  783:      m = (unsigned int )*((prev + 32768) + n);
    #####:  784:      if (m >= 32768U) {
    #####:  785:        tmp = m - 32768U;
    #####:  786:      } else {
    #####:  787:        tmp = 0U;
        -:  788:      }
    #####:  789:      *((prev + 32768) + n) = (Pos )tmp;
    #####:  790:      n ++;
        -:  791:    }
        -:  792:    while_break: /* CIL Label */ ;
        -:  793:    }
    #####:  794:    n = 0U;
        -:  795:    {
    #####:  796:    while (1) {
        -:  797:      while_continue___0: /* CIL Label */ ;
    #####:  798:      if (! (n < 32768U)) {
    #####:  799:        goto while_break___0;
        -:  800:      }
    #####:  801:      m = (unsigned int )prev[n];
    #####:  802:      if (m >= 32768U) {
    #####:  803:        tmp___0 = m - 32768U;
    #####:  804:      } else {
    #####:  805:        tmp___0 = 0U;
        -:  806:      }
    #####:  807:      prev[n] = (Pos )tmp___0;
    #####:  808:      n ++;
        -:  809:    }
        -:  810:    while_break___0: /* CIL Label */ ;
        -:  811:    }
    #####:  812:    more += 32768U;
    #####:  813:  }
        -:  814:  }
        1:  815:  if (! eofile) {
        -:  816:    {
        1:  817:    tmp___1 = (*read_buf)(((char *)(window) + strstart) + lookahead, more);
        1:  818:    n = (unsigned int )tmp___1;
        -:  819:    }
        1:  820:    if (n == 0U) {
        1:  821:      eofile = 1;
        1:  822:    } else { //Added block
    #####:  823:    if (n == 4294967295U) {
    #####:  824:      eofile = 1;
    #####:  825:    } else {
    #####:  826:      lookahead += n;
        -:  827:    }
        -:  828:    }
        1:  829:  }
        1:  830:  return;
        -:  831:}
        -:  832:}
    #####:  833:static off_t deflate_fast(void) 
        -:  834:{ 
        -:  835:  IPos hash_head ;
        -:  836:  int flush ;
        -:  837:  unsigned int match_length ;
        -:  838:  int tmp ;
        -:  839:  char *tmp___0 ;
        -:  840:  char *tmp___1 ;
        -:  841:  off_t tmp___2 ;
        -:  842:
        -:  843:  {
    #####:  844:  match_length = 0U;
    #####:  845:  prev_length = 2U;
        -:  846:  {
    #####:  847:  while (1) {
        -:  848:    while_continue: /* CIL Label */ ;
    #####:  849:    if (! (lookahead != 0U)) {
    #####:  850:      goto while_break;
        -:  851:    }
    #####:  852:    ins_h = ((ins_h << 5) ^ (unsigned int )window[(strstart + 3U) - 1U]) & ((unsigned int )(1 << 15) - 1U);
    #####:  853:    hash_head = (IPos )*((prev + 32768) + ins_h);
    #####:  854:    prev[strstart & 32767U] = (ush )hash_head;
    #####:  855:    *((prev + 32768) + ins_h) = (ush )strstart;
    #####:  856:    if (hash_head != 0U) {
    #####:  857:      if (strstart - hash_head <= 32506U) {
        -:  858:        {
    #####:  859:        tmp = longest_match(hash_head);
    #####:  860:        match_length = (unsigned int )tmp;
        -:  861:        }
    #####:  862:        if (match_length > lookahead) {
    #####:  863:          match_length = lookahead;
    #####:  864:        }
    #####:  865:      }
    #####:  866:    }
    #####:  867:    if (match_length >= 3U) {
        -:  868:      {
    #####:  869:      flush = ct_tally((int )(strstart - match_start), (int )(match_length - 3U));
    #####:  870:      lookahead -= match_length;
        -:  871:      }
    #####:  872:      if (match_length <= max_lazy_match) {
    #####:  873:        match_length --;
        -:  874:        {
    #####:  875:        while (1) {
        -:  876:          while_continue___0: /* CIL Label */ ;
    #####:  877:          strstart ++;
    #####:  878:          ins_h = ((ins_h << 5) ^ (unsigned int )window[(strstart + 3U) - 1U]) & ((unsigned int )(1 << 15) - 1U);
    #####:  879:          hash_head = (IPos )*((prev + 32768) + ins_h);
    #####:  880:          prev[strstart & 32767U] = (ush )hash_head;
    #####:  881:          *((prev + 32768) + ins_h) = (ush )strstart;
    #####:  882:          match_length --;
    #####:  883:          if (! (match_length != 0U)) {
    #####:  884:            goto while_break___0;
        -:  885:          }
        -:  886:        }
        -:  887:        while_break___0: /* CIL Label */ ;
        -:  888:        }
    #####:  889:        strstart ++;
    #####:  890:      } else {
    #####:  891:        strstart += match_length;
    #####:  892:        match_length = 0U;
    #####:  893:        ins_h = (unsigned int )window[strstart];
    #####:  894:        ins_h = ((ins_h << 5) ^ (unsigned int )window[strstart + 1U]) & ((unsigned int )(1 << 15) - 1U);
        -:  895:      }
    #####:  896:    } else {
        -:  897:      {
    #####:  898:      flush = ct_tally(0, (int )window[strstart]);
    #####:  899:      lookahead --;
    #####:  900:      strstart ++;
        -:  901:      }
        -:  902:    }
    #####:  903:    if (flush) {
    #####:  904:      if (block_start >= 0L) {
    #####:  905:        tmp___0 = (char *)(& window[(unsigned int )block_start]);
    #####:  906:      } else {
    #####:  907:        tmp___0 = (char *)((void *)0);
        -:  908:      }
        -:  909:      {
    #####:  910:      flush_block(tmp___0, (ulg )((long )strstart - block_start), 0);
    #####:  911:      block_start = (long )strstart;
        -:  912:      }
    #####:  913:    }
        -:  914:    {
    #####:  915:    while (1) {
        -:  916:      while_continue___1: /* CIL Label */ ;
    #####:  917:      if (lookahead < 262U) {
    #####:  918:        if (! (! eofile)) {
    #####:  919:          goto while_break___1;
        -:  920:        }
    #####:  921:      } else {
    #####:  922:        goto while_break___1;
        -:  923:      }
        -:  924:      {
    #####:  925:      fill_window();
        -:  926:      }
        -:  927:    }
        -:  928:    while_break___1: /* CIL Label */ ;
        -:  929:    }
        -:  930:  }
        -:  931:  while_break: /* CIL Label */ ;
        -:  932:  }
    #####:  933:  if (block_start >= 0L) {
    #####:  934:    tmp___1 = (char *)(& window[(unsigned int )block_start]);
    #####:  935:  } else {
    #####:  936:    tmp___1 = (char *)((void *)0);
        -:  937:  }
        -:  938:  {
    #####:  939:  tmp___2 = flush_block(tmp___1, (ulg )((long )strstart - block_start), 1);
        -:  940:  }
    #####:  941:  return (tmp___2);
        -:  942:}
        -:  943:}
        1:  944:off_t deflate(void) 
        -:  945:{ 
        -:  946:  IPos hash_head ;
        -:  947:  IPos prev_match ;
        -:  948:  int flush ;
        -:  949:  int match_available ;
        -:  950:  register unsigned int match_length ;
        -:  951:  off_t tmp ;
        -:  952:  int tmp___0 ;
        -:  953:  char *tmp___1 ;
        -:  954:  char *tmp___2 ;
        -:  955:  int tmp___3 ;
        -:  956:  char *tmp___4 ;
        -:  957:  off_t tmp___5 ;
        -:  958:
        -:  959:  {
        1:  960:  match_available = 0;
        1:  961:  match_length = 2U;
        1:  962:  if (compr_level <= 3) {
        -:  963:    {
    #####:  964:    tmp = deflate_fast();
        -:  965:    }
    #####:  966:    return (tmp);
        -:  967:  }
        -:  968:  {
    11568:  969:  while (1) {
        -:  970:    while_continue: /* CIL Label */ ;
    11568:  971:    if (! (lookahead != 0U)) {
        1:  972:      goto while_break;
        -:  973:    }
    11567:  974:    ins_h = ((ins_h << 5) ^ (unsigned int )window[(strstart + 3U) - 1U]) & ((unsigned int )(1 << 15) - 1U);
    11567:  975:    hash_head = (IPos )*((prev + 32768) + ins_h);
    11567:  976:    prev[strstart & 32767U] = (ush )hash_head;
    11567:  977:    *((prev + 32768) + ins_h) = (ush )strstart;
    11567:  978:    prev_length = match_length;
    11567:  979:    prev_match = match_start;
    11567:  980:    match_length = 2U;
    11567:  981:    if (hash_head != 0U) {
     9271:  982:      if (prev_length < max_lazy_match) {
     9037:  983:        if (strstart - hash_head <= 32506U) {
        -:  984:          {
     9037:  985:          tmp___0 = longest_match(hash_head);
     9037:  986:          match_length = (unsigned int )tmp___0;
        -:  987:          }
     9037:  988:          if (match_length > lookahead) {
        1:  989:            match_length = lookahead;
        1:  990:          }
     9037:  991:          if (match_length == 3U) {
     1232:  992:            if (strstart - match_start > 4096U) {
      265:  993:              match_length --;
      265:  994:            }
     1232:  995:          }
     9037:  996:        }
     9037:  997:      }
     9271:  998:    }
    11567:  999:    if (prev_length >= 3U) {
     4784: 1000:      if (match_length <= prev_length) {
        -: 1001:        {
     4166: 1002:        flush = ct_tally((int )((strstart - 1U) - prev_match), (int )(prev_length - 3U));
     4166: 1003:        lookahead -= prev_length - 1U;
     4166: 1004:        prev_length -= 2U;
        -: 1005:        }
        -: 1006:        {
    22664: 1007:        while (1) {
        -: 1008:          while_continue___0: /* CIL Label */ ;
    22664: 1009:          strstart ++;
    22664: 1010:          ins_h = ((ins_h << 5) ^ (unsigned int )window[(strstart + 3U) - 1U]) & ((unsigned int )(1 << 15) - 1U);
    22664: 1011:          hash_head = (IPos )*((prev + 32768) + ins_h);
    22664: 1012:          prev[strstart & 32767U] = (ush )hash_head;
    22664: 1013:          *((prev + 32768) + ins_h) = (ush )strstart;
    22664: 1014:          prev_length --;
    22664: 1015:          if (! (prev_length != 0U)) {
     4166: 1016:            goto while_break___0;
        -: 1017:          }
        -: 1018:        }
        -: 1019:        while_break___0: /* CIL Label */ ;
        -: 1020:        }
     4166: 1021:        match_available = 0;
     4166: 1022:        match_length = 2U;
     4166: 1023:        strstart ++;
     4166: 1024:        if (flush) {
    #####: 1025:          if (block_start >= 0L) {
    #####: 1026:            tmp___1 = (char *)(& window[(unsigned int )block_start]);
    #####: 1027:          } else {
    #####: 1028:            tmp___1 = (char *)((void *)0);
        -: 1029:          }
        -: 1030:          {
    #####: 1031:          flush_block(tmp___1, (ulg )((long )strstart - block_start), 0);
    #####: 1032:          block_start = (long )strstart;
        -: 1033:          }
    #####: 1034:        }
     4166: 1035:      } else {
      618: 1036:        goto _L;
        -: 1037:      }
    10949: 1038:    } else { //Added block
        -: 1039:    _L: 
     7401: 1040:    if (match_available) {
        -: 1041:      {
     3234: 1042:      tmp___3 = ct_tally(0, (int )window[strstart - 1U]);
        -: 1043:      }
     3234: 1044:      if (tmp___3) {
    #####: 1045:        if (block_start >= 0L) {
    #####: 1046:          tmp___2 = (char *)(& window[(unsigned int )block_start]);
    #####: 1047:        } else {
    #####: 1048:          tmp___2 = (char *)((void *)0);
        -: 1049:        }
        -: 1050:        {
    #####: 1051:        flush_block(tmp___2, (ulg )((long )strstart - block_start), 0);
    #####: 1052:        block_start = (long )strstart;
        -: 1053:        }
    #####: 1054:      }
     3234: 1055:      strstart ++;
     3234: 1056:      lookahead --;
     3234: 1057:    } else {
     4167: 1058:      match_available = 1;
     4167: 1059:      strstart ++;
     4167: 1060:      lookahead --;
        -: 1061:    }
        -: 1062:    }
        -: 1063:    {
    11568: 1064:    while (1) {
        -: 1065:      while_continue___1: /* CIL Label */ ;
    11568: 1066:      if (lookahead < 262U) {
      113: 1067:        if (! (! eofile)) {
      112: 1068:          goto while_break___1;
        -: 1069:        }
        1: 1070:      } else {
    11455: 1071:        goto while_break___1;
        -: 1072:      }
        -: 1073:      {
        1: 1074:      fill_window();
        -: 1075:      }
        -: 1076:    }
        -: 1077:    while_break___1: /* CIL Label */ ;
        -: 1078:    }
        -: 1079:  }
        -: 1080:  while_break: /* CIL Label */ ;
        -: 1081:  }
        1: 1082:  if (match_available) {
        -: 1083:    {
        1: 1084:    ct_tally(0, (int )window[strstart - 1U]);
        -: 1085:    }
        1: 1086:  }
        1: 1087:  if (block_start >= 0L) {
        1: 1088:    tmp___4 = (char *)(& window[(unsigned int )block_start]);
        1: 1089:  } else {
    #####: 1090:    tmp___4 = (char *)((void *)0);
        -: 1091:  }
        -: 1092:  {
        1: 1093:  tmp___5 = flush_block(tmp___4, (ulg )((long )strstart - block_start), 1);
        -: 1094:  }
        1: 1095:  return (tmp___5);
        -: 1096:}
        1: 1097:}
        -: 1098:extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
        -: 1099:extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
        -: 1100:extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) calloc)(size_t __nmemb ,
        -: 1101:                                                                               size_t __size )  __attribute__((__malloc__)) ;
        -: 1102:extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
        -: 1103:extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
        -: 1104:extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) getenv)(char const   *__name ) ;
        -: 1105:int huft_build(unsigned int *b , unsigned int n , unsigned int s , ush *d , ush *e ,
        -: 1106:               struct huft **t , int *m ) ;
        -: 1107:int huft_free(struct huft *t ) ;
        -: 1108:int inflate_codes(struct huft *tl , struct huft *td , int bl , int bd ) ;
        -: 1109:int inflate_stored(void) ;
        -: 1110:int inflate_fixed(void) ;
        -: 1111:int inflate_dynamic(void) ;
        -: 1112:int inflate_block(int *e ) ;
        -: 1113:static unsigned int border[19]  = 
        -: 1114:  {      16U,      17U,      18U,      0U, 
        -: 1115:        8U,      7U,      9U,      6U, 
        -: 1116:        10U,      5U,      11U,      4U, 
        -: 1117:        12U,      3U,      13U,      2U, 
        -: 1118:        14U,      1U,      15U};
        -: 1119:static ush cplens[31]  = 
        -: 1120:  {      (ush )3,      (ush )4,      (ush )5,      (ush )6, 
        -: 1121:        (ush )7,      (ush )8,      (ush )9,      (ush )10, 
        -: 1122:        (ush )11,      (ush )13,      (ush )15,      (ush )17, 
        -: 1123:        (ush )19,      (ush )23,      (ush )27,      (ush )31, 
        -: 1124:        (ush )35,      (ush )43,      (ush )51,      (ush )59, 
        -: 1125:        (ush )67,      (ush )83,      (ush )99,      (ush )115, 
        -: 1126:        (ush )131,      (ush )163,      (ush )195,      (ush )227, 
        -: 1127:        (ush )258,      (ush )0,      (ush )0};
        -: 1128:static ush cplext[31]  = 
        -: 1129:  {      (ush )0,      (ush )0,      (ush )0,      (ush )0, 
        -: 1130:        (ush )0,      (ush )0,      (ush )0,      (ush )0, 
        -: 1131:        (ush )1,      (ush )1,      (ush )1,      (ush )1, 
        -: 1132:        (ush )2,      (ush )2,      (ush )2,      (ush )2, 
        -: 1133:        (ush )3,      (ush )3,      (ush )3,      (ush )3, 
        -: 1134:        (ush )4,      (ush )4,      (ush )4,      (ush )4, 
        -: 1135:        (ush )5,      (ush )5,      (ush )5,      (ush )5, 
        -: 1136:        (ush )0,      (ush )99,      (ush )99};
        -: 1137:static ush cpdist[30]  = 
        -: 1138:  {      (ush )1,      (ush )2,      (ush )3,      (ush )4, 
        -: 1139:        (ush )5,      (ush )7,      (ush )9,      (ush )13, 
        -: 1140:        (ush )17,      (ush )25,      (ush )33,      (ush )49, 
        -: 1141:        (ush )65,      (ush )97,      (ush )129,      (ush )193, 
        -: 1142:        (ush )257,      (ush )385,      (ush )513,      (ush )769, 
        -: 1143:        (ush )1025,      (ush )1537,      (ush )2049,      (ush )3073, 
        -: 1144:        (ush )4097,      (ush )6145,      (ush )8193,      (ush )12289, 
        -: 1145:        (ush )16385,      (ush )24577};
        -: 1146:static ush cpdext[30]  = 
        -: 1147:  {      (ush )0,      (ush )0,      (ush )0,      (ush )0, 
        -: 1148:        (ush )1,      (ush )1,      (ush )2,      (ush )2, 
        -: 1149:        (ush )3,      (ush )3,      (ush )4,      (ush )4, 
        -: 1150:        (ush )5,      (ush )5,      (ush )6,      (ush )6, 
        -: 1151:        (ush )7,      (ush )7,      (ush )8,      (ush )8, 
        -: 1152:        (ush )9,      (ush )9,      (ush )10,      (ush )10, 
        -: 1153:        (ush )11,      (ush )11,      (ush )12,      (ush )12, 
        -: 1154:        (ush )13,      (ush )13};
        -: 1155:ulg bb  ;
        -: 1156:unsigned int bk  ;
        -: 1157:ush mask_bits[17]  = 
        -: 1158:  {      (ush )0,      (ush )1,      (ush )3,      (ush )7, 
        -: 1159:        (ush )15,      (ush )31,      (ush )63,      (ush )127, 
        -: 1160:        (ush )255,      (ush )511,      (ush )1023,      (ush )2047, 
        -: 1161:        (ush )4095,      (ush )8191,      (ush )16383,      (ush )32767, 
        -: 1162:        (ush )65535};
        -: 1163:int lbits  =    9;
        -: 1164:int dbits  =    6;
        -: 1165:unsigned int hufts  ;
    #####: 1166:int huft_build(unsigned int *b , unsigned int n , unsigned int s , ush *d , ush *e ,
        -: 1167:               struct huft **t , int *m ) 
        -: 1168:{ 
        -: 1169:  unsigned int a ;
        -: 1170:  unsigned int c[17] ;
        -: 1171:  unsigned int f ;
        -: 1172:  int g ;
        -: 1173:  int h ;
        -: 1174:  register unsigned int i___0 ;
        -: 1175:  register unsigned int j___0 ;
        -: 1176:  register int k ;
        -: 1177:  int l ;
        -: 1178:  register unsigned int *p ;
        -: 1179:  register struct huft *q ;
        -: 1180:  struct huft r ;
        -: 1181:  struct huft *u[16] ;
        -: 1182:  unsigned int v[288] ;
        -: 1183:  register int w ;
        -: 1184:  unsigned int x[17] ;
        -: 1185:  unsigned int *xp ;
        -: 1186:  int y ;
        -: 1187:  unsigned int z ;
        -: 1188:  unsigned int *tmp ;
        -: 1189:  unsigned int *tmp___0 ;
        -: 1190:  unsigned int tmp___1 ;
        -: 1191:  unsigned int *tmp___2 ;
        -: 1192:  void *tmp___3 ;
        -: 1193:  int tmp___4 ;
        -: 1194:  unsigned int *tmp___5 ;
        -: 1195:  unsigned int tmp___6 ;
        -: 1196:  int tmp___7 ;
        -: 1197:
        -: 1198:  {
        -: 1199:  {
    #####: 1200:  memset((voidp )(c), 0, sizeof(c));
    #####: 1201:  p = b;
    #####: 1202:  i___0 = n;
        -: 1203:  }
        -: 1204:  {
    #####: 1205:  while (1) {
        -: 1206:    while_continue: /* CIL Label */ ;
    #####: 1207:    (c[*p]) ++;
    #####: 1208:    p ++;
    #####: 1209:    i___0 --;
    #####: 1210:    if (! i___0) {
    #####: 1211:      goto while_break;
        -: 1212:    }
        -: 1213:  }
        -: 1214:  while_break: /* CIL Label */ ;
        -: 1215:  }
    #####: 1216:  if (c[0] == n) {
    #####: 1217:    *t = (struct huft *)((void *)0);
    #####: 1218:    *m = 0;
    #####: 1219:    return (0);
        -: 1220:  }
    #####: 1221:  l = *m;
    #####: 1222:  j___0 = 1U;
        -: 1223:  {
    #####: 1224:  while (1) {
        -: 1225:    while_continue___0: /* CIL Label */ ;
    #####: 1226:    if (! (j___0 <= 16U)) {
    #####: 1227:      goto while_break___0;
        -: 1228:    }
    #####: 1229:    if (c[j___0]) {
    #####: 1230:      goto while_break___0;
        -: 1231:    }
    #####: 1232:    j___0 ++;
        -: 1233:  }
        -: 1234:  while_break___0: /* CIL Label */ ;
        -: 1235:  }
    #####: 1236:  k = (int )j___0;
    #####: 1237:  if ((unsigned int )l < j___0) {
    #####: 1238:    l = (int )j___0;
    #####: 1239:  }
    #####: 1240:  i___0 = 16U;
        -: 1241:  {
    #####: 1242:  while (1) {
        -: 1243:    while_continue___1: /* CIL Label */ ;
    #####: 1244:    if (! i___0) {
    #####: 1245:      goto while_break___1;
        -: 1246:    }
    #####: 1247:    if (c[i___0]) {
    #####: 1248:      goto while_break___1;
        -: 1249:    }
    #####: 1250:    i___0 --;
        -: 1251:  }
        -: 1252:  while_break___1: /* CIL Label */ ;
        -: 1253:  }
    #####: 1254:  g = (int )i___0;
    #####: 1255:  if ((unsigned int )l > i___0) {
    #####: 1256:    l = (int )i___0;
    #####: 1257:  }
    #####: 1258:  *m = l;
    #####: 1259:  y = 1 << j___0;
        -: 1260:  {
    #####: 1261:  while (1) {
        -: 1262:    while_continue___2: /* CIL Label */ ;
    #####: 1263:    if (! (j___0 < i___0)) {
    #####: 1264:      goto while_break___2;
        -: 1265:    }
    #####: 1266:    y = (int )((unsigned int )y - c[j___0]);
    #####: 1267:    if (y < 0) {
    #####: 1268:      return (2);
        -: 1269:    }
    #####: 1270:    j___0 ++;
    #####: 1271:    y <<= 1;
        -: 1272:  }
        -: 1273:  while_break___2: /* CIL Label */ ;
        -: 1274:  }
    #####: 1275:  y = (int )((unsigned int )y - c[i___0]);
    #####: 1276:  if (y < 0) {
    #####: 1277:    return (2);
        -: 1278:  }
    #####: 1279:  c[i___0] += (unsigned int )y;
    #####: 1280:  j___0 = 0U;
    #####: 1281:  x[1] = j___0;
    #####: 1282:  p = c + 1;
    #####: 1283:  xp = x + 2;
        -: 1284:  {
    #####: 1285:  while (1) {
        -: 1286:    while_continue___3: /* CIL Label */ ;
    #####: 1287:    i___0 --;
    #####: 1288:    if (! i___0) {
    #####: 1289:      goto while_break___3;
        -: 1290:    }
    #####: 1291:    tmp = xp;
    #####: 1292:    xp ++;
    #####: 1293:    tmp___0 = p;
    #####: 1294:    p ++;
    #####: 1295:    j___0 += *tmp___0;
    #####: 1296:    *tmp = j___0;
        -: 1297:  }
        -: 1298:  while_break___3: /* CIL Label */ ;
        -: 1299:  }
    #####: 1300:  p = b;
    #####: 1301:  i___0 = 0U;
        -: 1302:  {
    #####: 1303:  while (1) {
        -: 1304:    while_continue___4: /* CIL Label */ ;
    #####: 1305:    tmp___2 = p;
    #####: 1306:    p ++;
    #####: 1307:    j___0 = *tmp___2;
    #####: 1308:    if (j___0 != 0U) {
    #####: 1309:      tmp___1 = x[j___0];
    #####: 1310:      (x[j___0]) ++;
    #####: 1311:      v[tmp___1] = i___0;
    #####: 1312:    }
    #####: 1313:    i___0 ++;
    #####: 1314:    if (! (i___0 < n)) {
    #####: 1315:      goto while_break___4;
        -: 1316:    }
        -: 1317:  }
        -: 1318:  while_break___4: /* CIL Label */ ;
        -: 1319:  }
    #####: 1320:  n = x[g];
    #####: 1321:  i___0 = 0U;
    #####: 1322:  x[0] = i___0;
    #####: 1323:  p = v;
    #####: 1324:  h = -1;
    #####: 1325:  w = - l;
    #####: 1326:  u[0] = (struct huft *)((void *)0);
    #####: 1327:  q = (struct huft *)((void *)0);
    #####: 1328:  z = 0U;
        -: 1329:  {
    #####: 1330:  while (1) {
        -: 1331:    while_continue___5: /* CIL Label */ ;
    #####: 1332:    if (! (k <= g)) {
    #####: 1333:      goto while_break___5;
        -: 1334:    }
    #####: 1335:    a = c[k];
        -: 1336:    {
    #####: 1337:    while (1) {
        -: 1338:      while_continue___6: /* CIL Label */ ;
    #####: 1339:      tmp___6 = a;
    #####: 1340:      a --;
    #####: 1341:      if (! tmp___6) {
    #####: 1342:        goto while_break___6;
        -: 1343:      }
        -: 1344:      {
    #####: 1345:      while (1) {
        -: 1346:        while_continue___7: /* CIL Label */ ;
    #####: 1347:        if (! (k > w + l)) {
    #####: 1348:          goto while_break___7;
        -: 1349:        }
    #####: 1350:        h ++;
    #####: 1351:        w += l;
    #####: 1352:        z = (unsigned int )(g - w);
    #####: 1353:        if (z > (unsigned int )l) {
    #####: 1354:          z = (unsigned int )l;
    #####: 1355:        } else {
    #####: 1356:          z = z;
        -: 1357:        }
    #####: 1358:        j___0 = (unsigned int )(k - w);
    #####: 1359:        f = (unsigned int )(1 << j___0);
    #####: 1360:        if (f > a + 1U) {
    #####: 1361:          f -= a + 1U;
    #####: 1362:          xp = c + k;
    #####: 1363:          if (j___0 < z) {
        -: 1364:            {
    #####: 1365:            while (1) {
        -: 1366:              while_continue___8: /* CIL Label */ ;
    #####: 1367:              j___0 ++;
    #####: 1368:              if (! (j___0 < z)) {
    #####: 1369:                goto while_break___8;
        -: 1370:              }
    #####: 1371:              f <<= 1;
    #####: 1372:              xp ++;
    #####: 1373:              if (f <= *xp) {
    #####: 1374:                goto while_break___8;
        -: 1375:              }
    #####: 1376:              f -= *xp;
        -: 1377:            }
        -: 1378:            while_break___8: /* CIL Label */ ;
        -: 1379:            }
    #####: 1380:          }
    #####: 1381:        }
        -: 1382:        {
    #####: 1383:        z = (unsigned int )(1 << j___0);
    #####: 1384:        tmp___3 = malloc((unsigned long )(z + 1U) * sizeof(struct huft ));
    #####: 1385:        q = (struct huft *)tmp___3;
        -: 1386:        }
    #####: 1387:        if ((unsigned long )q == (unsigned long )((struct huft *)((void *)0))) {
    #####: 1388:          if (h) {
        -: 1389:            {
    #####: 1390:            huft_free(u[0]);
        -: 1391:            }
    #####: 1392:          }
    #####: 1393:          return (3);
        -: 1394:        }
    #####: 1395:        hufts += z + 1U;
    #####: 1396:        *t = q + 1;
    #####: 1397:        t = & q->v.t;
    #####: 1398:        *t = (struct huft *)((void *)0);
    #####: 1399:        q ++;
    #####: 1400:        u[h] = q;
    #####: 1401:        if (h) {
    #####: 1402:          x[h] = i___0;
    #####: 1403:          r.b = (uch )l;
    #####: 1404:          r.e = (uch )(16U + j___0);
    #####: 1405:          r.v.t = q;
    #####: 1406:          j___0 = i___0 >> (w - l);
    #####: 1407:          *(u[h - 1] + j___0) = r;
    #####: 1408:        }
        -: 1409:      }
        -: 1410:      while_break___7: /* CIL Label */ ;
        -: 1411:      }
    #####: 1412:      r.b = (uch )(k - w);
    #####: 1413:      if ((unsigned long )p >= (unsigned long )(v + n)) {
    #####: 1414:        r.e = (uch )99;
    #####: 1415:      } else { //Added block
    #####: 1416:      if (*p < s) {
    #####: 1417:        if (*p < 256U) {
    #####: 1418:          tmp___4 = 16;
    #####: 1419:        } else {
    #####: 1420:          tmp___4 = 15;
        -: 1421:        }
    #####: 1422:        r.e = (uch )tmp___4;
    #####: 1423:        r.v.n = (ush )*p;
    #####: 1424:        p ++;
    #####: 1425:      } else {
    #####: 1426:        r.e = (uch )*(e + (*p - s));
    #####: 1427:        tmp___5 = p;
    #####: 1428:        p ++;
    #####: 1429:        r.v.n = *(d + (*tmp___5 - s));
        -: 1430:      }
        -: 1431:      }
    #####: 1432:      f = (unsigned int )(1 << (k - w));
    #####: 1433:      j___0 = i___0 >> w;
        -: 1434:      {
    #####: 1435:      while (1) {
        -: 1436:        while_continue___9: /* CIL Label */ ;
    #####: 1437:        if (! (j___0 < z)) {
    #####: 1438:          goto while_break___9;
        -: 1439:        }
    #####: 1440:        *(q + j___0) = r;
    #####: 1441:        j___0 += f;
        -: 1442:      }
        -: 1443:      while_break___9: /* CIL Label */ ;
        -: 1444:      }
    #####: 1445:      j___0 = (unsigned int )(1 << (k - 1));
        -: 1446:      {
    #####: 1447:      while (1) {
        -: 1448:        while_continue___10: /* CIL Label */ ;
    #####: 1449:        if (! (i___0 & j___0)) {
    #####: 1450:          goto while_break___10;
        -: 1451:        }
    #####: 1452:        i___0 ^= j___0;
    #####: 1453:        j___0 >>= 1;
        -: 1454:      }
        -: 1455:      while_break___10: /* CIL Label */ ;
        -: 1456:      }
    #####: 1457:      i___0 ^= j___0;
        -: 1458:      {
    #####: 1459:      while (1) {
        -: 1460:        while_continue___11: /* CIL Label */ ;
    #####: 1461:        if (! ((i___0 & (unsigned int )((1 << w) - 1)) != x[h])) {
    #####: 1462:          goto while_break___11;
        -: 1463:        }
    #####: 1464:        h --;
    #####: 1465:        w -= l;
        -: 1466:      }
        -: 1467:      while_break___11: /* CIL Label */ ;
        -: 1468:      }
        -: 1469:    }
        -: 1470:    while_break___6: /* CIL Label */ ;
        -: 1471:    }
    #####: 1472:    k ++;
        -: 1473:  }
        -: 1474:  while_break___5: /* CIL Label */ ;
        -: 1475:  }
    #####: 1476:  if (y != 0) {
    #####: 1477:    if (g != 1) {
    #####: 1478:      tmp___7 = 1;
    #####: 1479:    } else {
    #####: 1480:      tmp___7 = 0;
        -: 1481:    }
    #####: 1482:  } else {
    #####: 1483:    tmp___7 = 0;
        -: 1484:  }
    #####: 1485:  return (tmp___7);
        -: 1486:}
    #####: 1487:}
    #####: 1488:int huft_free(struct huft *t ) 
        -: 1489:{ 
        -: 1490:  register struct huft *p ;
        -: 1491:  register struct huft *q ;
        -: 1492:
        -: 1493:  {
    #####: 1494:  p = t;
        -: 1495:  {
    #####: 1496:  while (1) {
        -: 1497:    while_continue: /* CIL Label */ ;
    #####: 1498:    if (! ((unsigned long )p != (unsigned long )((struct huft *)((void *)0)))) {
    #####: 1499:      goto while_break;
        -: 1500:    }
        -: 1501:    {
    #####: 1502:    p --;
    #####: 1503:    q = p->v.t;
    #####: 1504:    free((void *)((char *)p));
    #####: 1505:    p = q;
        -: 1506:    }
        -: 1507:  }
        -: 1508:  while_break: /* CIL Label */ ;
        -: 1509:  }
    #####: 1510:  return (0);
        -: 1511:}
        -: 1512:}
    #####: 1513:int inflate_codes(struct huft *tl , struct huft *td , int bl , int bd ) 
        -: 1514:{ 
        -: 1515:  register unsigned int e ;
        -: 1516:  unsigned int n ;
        -: 1517:  unsigned int d ;
        -: 1518:  unsigned int w ;
        -: 1519:  struct huft *t ;
        -: 1520:  unsigned int ml ;
        -: 1521:  unsigned int md ;
        -: 1522:  register ulg b ;
        -: 1523:  register unsigned int k ;
        -: 1524:  unsigned int tmp ;
        -: 1525:  int tmp___0 ;
        -: 1526:  int tmp___1 ;
        -: 1527:  unsigned int tmp___2 ;
        -: 1528:  int tmp___3 ;
        -: 1529:  int tmp___4 ;
        -: 1530:  unsigned int tmp___5 ;
        -: 1531:  unsigned int tmp___6 ;
        -: 1532:  int tmp___7 ;
        -: 1533:  int tmp___8 ;
        -: 1534:  unsigned int tmp___9 ;
        -: 1535:  int tmp___10 ;
        -: 1536:  int tmp___11 ;
        -: 1537:  unsigned int tmp___12 ;
        -: 1538:  int tmp___13 ;
        -: 1539:  int tmp___14 ;
        -: 1540:  unsigned int tmp___15 ;
        -: 1541:  int tmp___16 ;
        -: 1542:  int tmp___17 ;
        -: 1543:  unsigned int tmp___19 ;
        -: 1544:  unsigned int tmp___20 ;
        -: 1545:  unsigned int tmp___21 ;
        -: 1546:
        -: 1547:  {
    #####: 1548:  b = bb;
    #####: 1549:  k = bk;
    #####: 1550:  w = outcnt;
    #####: 1551:  ml = (unsigned int )mask_bits[bl];
    #####: 1552:  md = (unsigned int )mask_bits[bd];
        -: 1553:  {
    #####: 1554:  while (1) {
        -: 1555:    while_continue: /* CIL Label */ ;
        -: 1556:    {
    #####: 1557:    while (1) {
        -: 1558:      while_continue___0: /* CIL Label */ ;
    #####: 1559:      if (! (k < (unsigned int )bl)) {
    #####: 1560:        goto while_break___0;
        -: 1561:      }
    #####: 1562:      if (inptr < insize) {
    #####: 1563:        tmp = inptr;
    #####: 1564:        inptr ++;
    #####: 1565:        tmp___1 = (int )inbuf[tmp];
    #####: 1566:      } else {
        -: 1567:        {
    #####: 1568:        tmp___0 = fill_inbuf(0);
    #####: 1569:        tmp___1 = tmp___0;
        -: 1570:        }
        -: 1571:      }
    #####: 1572:      b |= (ulg )((uch )tmp___1) << k;
    #####: 1573:      k += 8U;
        -: 1574:    }
        -: 1575:    while_break___0: /* CIL Label */ ;
        -: 1576:    }
    #####: 1577:    t = tl + ((unsigned int )b & ml);
    #####: 1578:    e = (unsigned int )t->e;
    #####: 1579:    if (e > 16U) {
        -: 1580:      {
    #####: 1581:      while (1) {
        -: 1582:        while_continue___1: /* CIL Label */ ;
    #####: 1583:        if (e == 99U) {
    #####: 1584:          return (1);
        -: 1585:        }
    #####: 1586:        b >>= (int )t->b;
    #####: 1587:        k -= (unsigned int )t->b;
    #####: 1588:        e -= 16U;
        -: 1589:        {
    #####: 1590:        while (1) {
        -: 1591:          while_continue___2: /* CIL Label */ ;
    #####: 1592:          if (! (k < e)) {
    #####: 1593:            goto while_break___2;
        -: 1594:          }
    #####: 1595:          if (inptr < insize) {
    #####: 1596:            tmp___2 = inptr;
    #####: 1597:            inptr ++;
    #####: 1598:            tmp___4 = (int )inbuf[tmp___2];
    #####: 1599:          } else {
        -: 1600:            {
    #####: 1601:            tmp___3 = fill_inbuf(0);
    #####: 1602:            tmp___4 = tmp___3;
        -: 1603:            }
        -: 1604:          }
    #####: 1605:          b |= (ulg )((uch )tmp___4) << k;
    #####: 1606:          k += 8U;
        -: 1607:        }
        -: 1608:        while_break___2: /* CIL Label */ ;
        -: 1609:        }
    #####: 1610:        t = t->v.t + ((unsigned int )b & (unsigned int )mask_bits[e]);
    #####: 1611:        e = (unsigned int )t->e;
    #####: 1612:        if (! (e > 16U)) {
    #####: 1613:          goto while_break___1;
        -: 1614:        }
        -: 1615:      }
        -: 1616:      while_break___1: /* CIL Label */ ;
        -: 1617:      }
    #####: 1618:    }
    #####: 1619:    b >>= (int )t->b;
    #####: 1620:    k -= (unsigned int )t->b;
    #####: 1621:    if (e == 16U) {
    #####: 1622:      tmp___5 = w;
    #####: 1623:      w ++;
    #####: 1624:      window[tmp___5] = (uch )t->v.n;
    #####: 1625:      if (w == 32768U) {
        -: 1626:        {
    #####: 1627:        outcnt = w;
    #####: 1628:        flush_window();
    #####: 1629:        w = 0U;
        -: 1630:        }
    #####: 1631:      }
    #####: 1632:    } else {
    #####: 1633:      if (e == 15U) {
    #####: 1634:        goto while_break;
        -: 1635:      }
        -: 1636:      {
    #####: 1637:      while (1) {
        -: 1638:        while_continue___3: /* CIL Label */ ;
    #####: 1639:        if (! (k < e)) {
    #####: 1640:          goto while_break___3;
        -: 1641:        }
    #####: 1642:        if (inptr < insize) {
    #####: 1643:          tmp___6 = inptr;
    #####: 1644:          inptr ++;
    #####: 1645:          tmp___8 = (int )inbuf[tmp___6];
    #####: 1646:        } else {
        -: 1647:          {
    #####: 1648:          tmp___7 = fill_inbuf(0);
    #####: 1649:          tmp___8 = tmp___7;
        -: 1650:          }
        -: 1651:        }
    #####: 1652:        b |= (ulg )((uch )tmp___8) << k;
    #####: 1653:        k += 8U;
        -: 1654:      }
        -: 1655:      while_break___3: /* CIL Label */ ;
        -: 1656:      }
    #####: 1657:      n = (unsigned int )t->v.n + ((unsigned int )b & (unsigned int )mask_bits[e]);
    #####: 1658:      b >>= e;
    #####: 1659:      k -= e;
        -: 1660:      {
    #####: 1661:      while (1) {
        -: 1662:        while_continue___4: /* CIL Label */ ;
    #####: 1663:        if (! (k < (unsigned int )bd)) {
    #####: 1664:          goto while_break___4;
        -: 1665:        }
    #####: 1666:        if (inptr < insize) {
    #####: 1667:          tmp___9 = inptr;
    #####: 1668:          inptr ++;
    #####: 1669:          tmp___11 = (int )inbuf[tmp___9];
    #####: 1670:        } else {
        -: 1671:          {
    #####: 1672:          tmp___10 = fill_inbuf(0);
    #####: 1673:          tmp___11 = tmp___10;
        -: 1674:          }
        -: 1675:        }
    #####: 1676:        b |= (ulg )((uch )tmp___11) << k;
    #####: 1677:        k += 8U;
        -: 1678:      }
        -: 1679:      while_break___4: /* CIL Label */ ;
        -: 1680:      }
    #####: 1681:      t = td + ((unsigned int )b & md);
    #####: 1682:      e = (unsigned int )t->e;
    #####: 1683:      if (e > 16U) {
        -: 1684:        {
    #####: 1685:        while (1) {
        -: 1686:          while_continue___5: /* CIL Label */ ;
    #####: 1687:          if (e == 99U) {
    #####: 1688:            return (1);
        -: 1689:          }
    #####: 1690:          b >>= (int )t->b;
    #####: 1691:          k -= (unsigned int )t->b;
    #####: 1692:          e -= 16U;
        -: 1693:          {
    #####: 1694:          while (1) {
        -: 1695:            while_continue___6: /* CIL Label */ ;
    #####: 1696:            if (! (k < e)) {
    #####: 1697:              goto while_break___6;
        -: 1698:            }
    #####: 1699:            if (inptr < insize) {
    #####: 1700:              tmp___12 = inptr;
    #####: 1701:              inptr ++;
    #####: 1702:              tmp___14 = (int )inbuf[tmp___12];
    #####: 1703:            } else {
        -: 1704:              {
    #####: 1705:              tmp___13 = fill_inbuf(0);
    #####: 1706:              tmp___14 = tmp___13;
        -: 1707:              }
        -: 1708:            }
    #####: 1709:            b |= (ulg )((uch )tmp___14) << k;
    #####: 1710:            k += 8U;
        -: 1711:          }
        -: 1712:          while_break___6: /* CIL Label */ ;
        -: 1713:          }
    #####: 1714:          t = t->v.t + ((unsigned int )b & (unsigned int )mask_bits[e]);
    #####: 1715:          e = (unsigned int )t->e;
    #####: 1716:          if (! (e > 16U)) {
    #####: 1717:            goto while_break___5;
        -: 1718:          }
        -: 1719:        }
        -: 1720:        while_break___5: /* CIL Label */ ;
        -: 1721:        }
    #####: 1722:      }
    #####: 1723:      b >>= (int )t->b;
    #####: 1724:      k -= (unsigned int )t->b;
        -: 1725:      {
    #####: 1726:      while (1) {
        -: 1727:        while_continue___7: /* CIL Label */ ;
    #####: 1728:        if (! (k < e)) {
    #####: 1729:          goto while_break___7;
        -: 1730:        }
    #####: 1731:        if (inptr < insize) {
    #####: 1732:          tmp___15 = inptr;
    #####: 1733:          inptr ++;
    #####: 1734:          tmp___17 = (int )inbuf[tmp___15];
    #####: 1735:        } else {
        -: 1736:          {
    #####: 1737:          tmp___16 = fill_inbuf(0);
    #####: 1738:          tmp___17 = tmp___16;
        -: 1739:          }
        -: 1740:        }
    #####: 1741:        b |= (ulg )((uch )tmp___17) << k;
    #####: 1742:        k += 8U;
        -: 1743:      }
        -: 1744:      while_break___7: /* CIL Label */ ;
        -: 1745:      }
    #####: 1746:      d = (w - (unsigned int )t->v.n) - ((unsigned int )b & (unsigned int )mask_bits[e]);
    #####: 1747:      b >>= e;
    #####: 1748:      k -= e;
        -: 1749:      {
    #####: 1750:      while (1) {
        -: 1751:        while_continue___8: /* CIL Label */ ;
    #####: 1752:        d &= 32767U;
    #####: 1753:        if (d > w) {
    #####: 1754:          tmp___19 = d;
    #####: 1755:        } else {
    #####: 1756:          tmp___19 = w;
        -: 1757:        }
    #####: 1758:        e = 32768U - tmp___19;
    #####: 1759:        if (e > n) {
    #####: 1760:          e = n;
    #####: 1761:        } else {
    #####: 1762:          e = e;
        -: 1763:        }
    #####: 1764:        n -= e;
    #####: 1765:        if (w - d >= e) {
        -: 1766:          {
    #####: 1767:          memcpy((void * __restrict  )(window + w), (void const   * __restrict  )(window + d),
    #####: 1768:                 (size_t )e);
    #####: 1769:          w += e;
    #####: 1770:          d += e;
        -: 1771:          }
    #####: 1772:        } else {
        -: 1773:          {
    #####: 1774:          while (1) {
        -: 1775:            while_continue___9: /* CIL Label */ ;
    #####: 1776:            tmp___20 = w;
    #####: 1777:            w ++;
    #####: 1778:            tmp___21 = d;
    #####: 1779:            d ++;
    #####: 1780:            window[tmp___20] = window[tmp___21];
    #####: 1781:            e --;
    #####: 1782:            if (! e) {
    #####: 1783:              goto while_break___9;
        -: 1784:            }
        -: 1785:          }
        -: 1786:          while_break___9: /* CIL Label */ ;
        -: 1787:          }
        -: 1788:        }
    #####: 1789:        if (w == 32768U) {
        -: 1790:          {
    #####: 1791:          outcnt = w;
    #####: 1792:          flush_window();
    #####: 1793:          w = 0U;
        -: 1794:          }
    #####: 1795:        }
    #####: 1796:        if (! n) {
    #####: 1797:          goto while_break___8;
        -: 1798:        }
        -: 1799:      }
        -: 1800:      while_break___8: /* CIL Label */ ;
        -: 1801:      }
        -: 1802:    }
        -: 1803:  }
        -: 1804:  while_break: /* CIL Label */ ;
        -: 1805:  }
    #####: 1806:  outcnt = w;
    #####: 1807:  bb = b;
    #####: 1808:  bk = k;
    #####: 1809:  return (0);
        -: 1810:}
    #####: 1811:}
    #####: 1812:int inflate_stored(void) 
        -: 1813:{ 
        -: 1814:  unsigned int n ;
        -: 1815:  unsigned int w ;
        -: 1816:  register ulg b ;
        -: 1817:  register unsigned int k ;
        -: 1818:  unsigned int tmp ;
        -: 1819:  int tmp___0 ;
        -: 1820:  int tmp___1 ;
        -: 1821:  unsigned int tmp___2 ;
        -: 1822:  int tmp___3 ;
        -: 1823:  int tmp___4 ;
        -: 1824:  unsigned int tmp___5 ;
        -: 1825:  int tmp___6 ;
        -: 1826:  int tmp___7 ;
        -: 1827:  unsigned int tmp___8 ;
        -: 1828:  unsigned int tmp___9 ;
        -: 1829:
        -: 1830:  {
    #####: 1831:  b = bb;
    #####: 1832:  k = bk;
    #####: 1833:  w = outcnt;
    #####: 1834:  n = k & 7U;
    #####: 1835:  b >>= n;
    #####: 1836:  k -= n;
        -: 1837:  {
    #####: 1838:  while (1) {
        -: 1839:    while_continue: /* CIL Label */ ;
    #####: 1840:    if (! (k < 16U)) {
    #####: 1841:      goto while_break;
        -: 1842:    }
    #####: 1843:    if (inptr < insize) {
    #####: 1844:      tmp = inptr;
    #####: 1845:      inptr ++;
    #####: 1846:      tmp___1 = (int )inbuf[tmp];
    #####: 1847:    } else {
        -: 1848:      {
    #####: 1849:      tmp___0 = fill_inbuf(0);
    #####: 1850:      tmp___1 = tmp___0;
        -: 1851:      }
        -: 1852:    }
    #####: 1853:    b |= (ulg )((uch )tmp___1) << k;
    #####: 1854:    k += 8U;
        -: 1855:  }
        -: 1856:  while_break: /* CIL Label */ ;
        -: 1857:  }
    #####: 1858:  n = (unsigned int )b & 65535U;
    #####: 1859:  b >>= 16;
    #####: 1860:  k -= 16U;
        -: 1861:  {
    #####: 1862:  while (1) {
        -: 1863:    while_continue___0: /* CIL Label */ ;
    #####: 1864:    if (! (k < 16U)) {
    #####: 1865:      goto while_break___0;
        -: 1866:    }
    #####: 1867:    if (inptr < insize) {
    #####: 1868:      tmp___2 = inptr;
    #####: 1869:      inptr ++;
    #####: 1870:      tmp___4 = (int )inbuf[tmp___2];
    #####: 1871:    } else {
        -: 1872:      {
    #####: 1873:      tmp___3 = fill_inbuf(0);
    #####: 1874:      tmp___4 = tmp___3;
        -: 1875:      }
        -: 1876:    }
    #####: 1877:    b |= (ulg )((uch )tmp___4) << k;
    #####: 1878:    k += 8U;
        -: 1879:  }
        -: 1880:  while_break___0: /* CIL Label */ ;
        -: 1881:  }
    #####: 1882:  if (n != (unsigned int )(~ b & 65535UL)) {
    #####: 1883:    return (1);
        -: 1884:  }
    #####: 1885:  b >>= 16;
    #####: 1886:  k -= 16U;
        -: 1887:  {
    #####: 1888:  while (1) {
        -: 1889:    while_continue___1: /* CIL Label */ ;
    #####: 1890:    tmp___9 = n;
    #####: 1891:    n --;
    #####: 1892:    if (! tmp___9) {
    #####: 1893:      goto while_break___1;
        -: 1894:    }
        -: 1895:    {
    #####: 1896:    while (1) {
        -: 1897:      while_continue___2: /* CIL Label */ ;
    #####: 1898:      if (! (k < 8U)) {
    #####: 1899:        goto while_break___2;
        -: 1900:      }
    #####: 1901:      if (inptr < insize) {
    #####: 1902:        tmp___5 = inptr;
    #####: 1903:        inptr ++;
    #####: 1904:        tmp___7 = (int )inbuf[tmp___5];
    #####: 1905:      } else {
        -: 1906:        {
    #####: 1907:        tmp___6 = fill_inbuf(0);
    #####: 1908:        tmp___7 = tmp___6;
        -: 1909:        }
        -: 1910:      }
    #####: 1911:      b |= (ulg )((uch )tmp___7) << k;
    #####: 1912:      k += 8U;
        -: 1913:    }
        -: 1914:    while_break___2: /* CIL Label */ ;
        -: 1915:    }
    #####: 1916:    tmp___8 = w;
    #####: 1917:    w ++;
    #####: 1918:    window[tmp___8] = (uch )b;
    #####: 1919:    if (w == 32768U) {
        -: 1920:      {
    #####: 1921:      outcnt = w;
    #####: 1922:      flush_window();
    #####: 1923:      w = 0U;
        -: 1924:      }
    #####: 1925:    }
    #####: 1926:    b >>= 8;
    #####: 1927:    k -= 8U;
        -: 1928:  }
        -: 1929:  while_break___1: /* CIL Label */ ;
        -: 1930:  }
    #####: 1931:  outcnt = w;
    #####: 1932:  bb = b;
    #####: 1933:  bk = k;
    #####: 1934:  return (0);
        -: 1935:}
    #####: 1936:}
    #####: 1937:int inflate_fixed(void) 
        -: 1938:{ 
        -: 1939:  int i___0 ;
        -: 1940:  struct huft *tl ;
        -: 1941:  struct huft *td ;
        -: 1942:  int bl ;
        -: 1943:  int bd ;
        -: 1944:  unsigned int l[288] ;
        -: 1945:  int tmp ;
        -: 1946:
        -: 1947:  {
    #####: 1948:  i___0 = 0;
        -: 1949:  {
    #####: 1950:  while (1) {
        -: 1951:    while_continue: /* CIL Label */ ;
    #####: 1952:    if (! (i___0 < 144)) {
    #####: 1953:      goto while_break;
        -: 1954:    }
    #####: 1955:    l[i___0] = 8U;
    #####: 1956:    i___0 ++;
        -: 1957:  }
        -: 1958:  while_break: /* CIL Label */ ;
        -: 1959:  }
        -: 1960:  {
    #####: 1961:  while (1) {
        -: 1962:    while_continue___0: /* CIL Label */ ;
    #####: 1963:    if (! (i___0 < 256)) {
    #####: 1964:      goto while_break___0;
        -: 1965:    }
    #####: 1966:    l[i___0] = 9U;
    #####: 1967:    i___0 ++;
        -: 1968:  }
        -: 1969:  while_break___0: /* CIL Label */ ;
        -: 1970:  }
        -: 1971:  {
    #####: 1972:  while (1) {
        -: 1973:    while_continue___1: /* CIL Label */ ;
    #####: 1974:    if (! (i___0 < 280)) {
    #####: 1975:      goto while_break___1;
        -: 1976:    }
    #####: 1977:    l[i___0] = 7U;
    #####: 1978:    i___0 ++;
        -: 1979:  }
        -: 1980:  while_break___1: /* CIL Label */ ;
        -: 1981:  }
        -: 1982:  {
    #####: 1983:  while (1) {
        -: 1984:    while_continue___2: /* CIL Label */ ;
    #####: 1985:    if (! (i___0 < 288)) {
    #####: 1986:      goto while_break___2;
        -: 1987:    }
    #####: 1988:    l[i___0] = 8U;
    #####: 1989:    i___0 ++;
        -: 1990:  }
        -: 1991:  while_break___2: /* CIL Label */ ;
        -: 1992:  }
        -: 1993:  {
    #####: 1994:  bl = 7;
    #####: 1995:  i___0 = huft_build(l, 288U, 257U, cplens, cplext, & tl, & bl);
        -: 1996:  }
    #####: 1997:  if (i___0 != 0) {
    #####: 1998:    return (i___0);
        -: 1999:  }
    #####: 2000:  i___0 = 0;
        -: 2001:  {
    #####: 2002:  while (1) {
        -: 2003:    while_continue___3: /* CIL Label */ ;
    #####: 2004:    if (! (i___0 < 30)) {
    #####: 2005:      goto while_break___3;
        -: 2006:    }
    #####: 2007:    l[i___0] = 5U;
    #####: 2008:    i___0 ++;
        -: 2009:  }
        -: 2010:  while_break___3: /* CIL Label */ ;
        -: 2011:  }
        -: 2012:  {
    #####: 2013:  bd = 5;
    #####: 2014:  i___0 = huft_build(l, 30U, 0U, cpdist, cpdext, & td, & bd);
        -: 2015:  }
    #####: 2016:  if (i___0 > 1) {
        -: 2017:    {
    #####: 2018:    huft_free(tl);
        -: 2019:    }
    #####: 2020:    return (i___0);
        -: 2021:  }
        -: 2022:  {
    #####: 2023:  tmp = inflate_codes(tl, td, bl, bd);
        -: 2024:  }
    #####: 2025:  if (tmp) {
    #####: 2026:    return (1);
        -: 2027:  }
        -: 2028:  {
    #####: 2029:  huft_free(tl);
    #####: 2030:  huft_free(td);
        -: 2031:  }
    #####: 2032:  return (0);
        -: 2033:}
    #####: 2034:}
    #####: 2035:int inflate_dynamic(void) 
        -: 2036:{ 
        -: 2037:  int i___0 ;
        -: 2038:  unsigned int j___0 ;
        -: 2039:  unsigned int l ;
        -: 2040:  unsigned int m ;
        -: 2041:  unsigned int n ;
        -: 2042:  struct huft *tl ;
        -: 2043:  struct huft *td ;
        -: 2044:  int bl ;
        -: 2045:  int bd ;
        -: 2046:  unsigned int nb ;
        -: 2047:  unsigned int nl ;
        -: 2048:  unsigned int nd ;
        -: 2049:  unsigned int ll[316] ;
        -: 2050:  register ulg b ;
        -: 2051:  register unsigned int k ;
        -: 2052:  unsigned int tmp ;
        -: 2053:  int tmp___0 ;
        -: 2054:  int tmp___1 ;
        -: 2055:  unsigned int tmp___2 ;
        -: 2056:  int tmp___3 ;
        -: 2057:  int tmp___4 ;
        -: 2058:  unsigned int tmp___5 ;
        -: 2059:  int tmp___6 ;
        -: 2060:  int tmp___7 ;
        -: 2061:  unsigned int tmp___8 ;
        -: 2062:  int tmp___9 ;
        -: 2063:  int tmp___10 ;
        -: 2064:  unsigned int tmp___11 ;
        -: 2065:  int tmp___12 ;
        -: 2066:  int tmp___13 ;
        -: 2067:  int tmp___14 ;
        -: 2068:  unsigned int tmp___15 ;
        -: 2069:  int tmp___16 ;
        -: 2070:  int tmp___17 ;
        -: 2071:  int tmp___18 ;
        -: 2072:  unsigned int tmp___19 ;
        -: 2073:  unsigned int tmp___20 ;
        -: 2074:  int tmp___21 ;
        -: 2075:  int tmp___22 ;
        -: 2076:  int tmp___23 ;
        -: 2077:  unsigned int tmp___24 ;
        -: 2078:  unsigned int tmp___25 ;
        -: 2079:  int tmp___26 ;
        -: 2080:  int tmp___27 ;
        -: 2081:  int tmp___28 ;
        -: 2082:  unsigned int tmp___29 ;
        -: 2083:  int tmp___30 ;
        -: 2084:
        -: 2085:  {
    #####: 2086:  b = bb;
    #####: 2087:  k = bk;
        -: 2088:  {
    #####: 2089:  while (1) {
        -: 2090:    while_continue: /* CIL Label */ ;
    #####: 2091:    if (! (k < 5U)) {
    #####: 2092:      goto while_break;
        -: 2093:    }
    #####: 2094:    if (inptr < insize) {
    #####: 2095:      tmp = inptr;
    #####: 2096:      inptr ++;
    #####: 2097:      tmp___1 = (int )inbuf[tmp];
    #####: 2098:    } else {
        -: 2099:      {
    #####: 2100:      tmp___0 = fill_inbuf(0);
    #####: 2101:      tmp___1 = tmp___0;
        -: 2102:      }
        -: 2103:    }
    #####: 2104:    b |= (ulg )((uch )tmp___1) << k;
    #####: 2105:    k += 8U;
        -: 2106:  }
        -: 2107:  while_break: /* CIL Label */ ;
        -: 2108:  }
    #####: 2109:  nl = 257U + ((unsigned int )b & 31U);
    #####: 2110:  b >>= 5;
    #####: 2111:  k -= 5U;
        -: 2112:  {
    #####: 2113:  while (1) {
        -: 2114:    while_continue___0: /* CIL Label */ ;
    #####: 2115:    if (! (k < 5U)) {
    #####: 2116:      goto while_break___0;
        -: 2117:    }
    #####: 2118:    if (inptr < insize) {
    #####: 2119:      tmp___2 = inptr;
    #####: 2120:      inptr ++;
    #####: 2121:      tmp___4 = (int )inbuf[tmp___2];
    #####: 2122:    } else {
        -: 2123:      {
    #####: 2124:      tmp___3 = fill_inbuf(0);
    #####: 2125:      tmp___4 = tmp___3;
        -: 2126:      }
        -: 2127:    }
    #####: 2128:    b |= (ulg )((uch )tmp___4) << k;
    #####: 2129:    k += 8U;
        -: 2130:  }
        -: 2131:  while_break___0: /* CIL Label */ ;
        -: 2132:  }
    #####: 2133:  nd = 1U + ((unsigned int )b & 31U);
    #####: 2134:  b >>= 5;
    #####: 2135:  k -= 5U;
        -: 2136:  {
    #####: 2137:  while (1) {
        -: 2138:    while_continue___1: /* CIL Label */ ;
    #####: 2139:    if (! (k < 4U)) {
    #####: 2140:      goto while_break___1;
        -: 2141:    }
    #####: 2142:    if (inptr < insize) {
    #####: 2143:      tmp___5 = inptr;
    #####: 2144:      inptr ++;
    #####: 2145:      tmp___7 = (int )inbuf[tmp___5];
    #####: 2146:    } else {
        -: 2147:      {
    #####: 2148:      tmp___6 = fill_inbuf(0);
    #####: 2149:      tmp___7 = tmp___6;
        -: 2150:      }
        -: 2151:    }
    #####: 2152:    b |= (ulg )((uch )tmp___7) << k;
    #####: 2153:    k += 8U;
        -: 2154:  }
        -: 2155:  while_break___1: /* CIL Label */ ;
        -: 2156:  }
    #####: 2157:  nb = 4U + ((unsigned int )b & 15U);
    #####: 2158:  b >>= 4;
    #####: 2159:  k -= 4U;
    #####: 2160:  if (nl > 286U) {
    #####: 2161:    return (1);
        -: 2162:  } else { //Added block
    #####: 2163:  if (nd > 30U) {
    #####: 2164:    return (1);
        -: 2165:  }
        -: 2166:  }
    #####: 2167:  j___0 = 0U;
        -: 2168:  {
    #####: 2169:  while (1) {
        -: 2170:    while_continue___2: /* CIL Label */ ;
    #####: 2171:    if (! (j___0 < nb)) {
    #####: 2172:      goto while_break___2;
        -: 2173:    }
        -: 2174:    {
    #####: 2175:    while (1) {
        -: 2176:      while_continue___3: /* CIL Label */ ;
    #####: 2177:      if (! (k < 3U)) {
    #####: 2178:        goto while_break___3;
        -: 2179:      }
    #####: 2180:      if (inptr < insize) {
    #####: 2181:        tmp___8 = inptr;
    #####: 2182:        inptr ++;
    #####: 2183:        tmp___10 = (int )inbuf[tmp___8];
    #####: 2184:      } else {
        -: 2185:        {
    #####: 2186:        tmp___9 = fill_inbuf(0);
    #####: 2187:        tmp___10 = tmp___9;
        -: 2188:        }
        -: 2189:      }
    #####: 2190:      b |= (ulg )((uch )tmp___10) << k;
    #####: 2191:      k += 8U;
        -: 2192:    }
        -: 2193:    while_break___3: /* CIL Label */ ;
        -: 2194:    }
    #####: 2195:    ll[border[j___0]] = (unsigned int )b & 7U;
    #####: 2196:    b >>= 3;
    #####: 2197:    k -= 3U;
    #####: 2198:    j___0 ++;
        -: 2199:  }
        -: 2200:  while_break___2: /* CIL Label */ ;
        -: 2201:  }
        -: 2202:  {
    #####: 2203:  while (1) {
        -: 2204:    while_continue___4: /* CIL Label */ ;
    #####: 2205:    if (! (j___0 < 19U)) {
    #####: 2206:      goto while_break___4;
        -: 2207:    }
    #####: 2208:    ll[border[j___0]] = 0U;
    #####: 2209:    j___0 ++;
        -: 2210:  }
        -: 2211:  while_break___4: /* CIL Label */ ;
        -: 2212:  }
        -: 2213:  {
    #####: 2214:  bl = 7;
    #####: 2215:  i___0 = huft_build(ll, 19U, 19U, (ush *)((void *)0), (ush *)((void *)0), & tl, & bl);
        -: 2216:  }
    #####: 2217:  if (i___0 != 0) {
    #####: 2218:    if (i___0 == 1) {
        -: 2219:      {
    #####: 2220:      huft_free(tl);
        -: 2221:      }
    #####: 2222:    }
    #####: 2223:    return (i___0);
        -: 2224:  }
    #####: 2225:  if ((unsigned long )tl == (unsigned long )((void *)0)) {
    #####: 2226:    return (2);
        -: 2227:  }
    #####: 2228:  n = nl + nd;
    #####: 2229:  m = (unsigned int )mask_bits[bl];
    #####: 2230:  l = 0U;
    #####: 2231:  i___0 = (int )l;
        -: 2232:  {
    #####: 2233:  while (1) {
        -: 2234:    while_continue___5: /* CIL Label */ ;
    #####: 2235:    if (! ((unsigned int )i___0 < n)) {
    #####: 2236:      goto while_break___5;
        -: 2237:    }
        -: 2238:    {
    #####: 2239:    while (1) {
        -: 2240:      while_continue___6: /* CIL Label */ ;
    #####: 2241:      if (! (k < (unsigned int )bl)) {
    #####: 2242:        goto while_break___6;
        -: 2243:      }
    #####: 2244:      if (inptr < insize) {
    #####: 2245:        tmp___11 = inptr;
    #####: 2246:        inptr ++;
    #####: 2247:        tmp___13 = (int )inbuf[tmp___11];
    #####: 2248:      } else {
        -: 2249:        {
    #####: 2250:        tmp___12 = fill_inbuf(0);
    #####: 2251:        tmp___13 = tmp___12;
        -: 2252:        }
        -: 2253:      }
    #####: 2254:      b |= (ulg )((uch )tmp___13) << k;
    #####: 2255:      k += 8U;
        -: 2256:    }
        -: 2257:    while_break___6: /* CIL Label */ ;
        -: 2258:    }
    #####: 2259:    td = tl + ((unsigned int )b & m);
    #####: 2260:    j___0 = (unsigned int )td->b;
    #####: 2261:    b >>= j___0;
    #####: 2262:    k -= j___0;
    #####: 2263:    j___0 = (unsigned int )td->v.n;
    #####: 2264:    if (j___0 < 16U) {
    #####: 2265:      tmp___14 = i___0;
    #####: 2266:      i___0 ++;
    #####: 2267:      l = j___0;
    #####: 2268:      ll[tmp___14] = l;
    #####: 2269:    } else { //Added block
    #####: 2270:    if (j___0 == 16U) {
        -: 2271:      {
    #####: 2272:      while (1) {
        -: 2273:        while_continue___7: /* CIL Label */ ;
    #####: 2274:        if (! (k < 2U)) {
    #####: 2275:          goto while_break___7;
        -: 2276:        }
    #####: 2277:        if (inptr < insize) {
    #####: 2278:          tmp___15 = inptr;
    #####: 2279:          inptr ++;
    #####: 2280:          tmp___17 = (int )inbuf[tmp___15];
    #####: 2281:        } else {
        -: 2282:          {
    #####: 2283:          tmp___16 = fill_inbuf(0);
    #####: 2284:          tmp___17 = tmp___16;
        -: 2285:          }
        -: 2286:        }
    #####: 2287:        b |= (ulg )((uch )tmp___17) << k;
    #####: 2288:        k += 8U;
        -: 2289:      }
        -: 2290:      while_break___7: /* CIL Label */ ;
        -: 2291:      }
    #####: 2292:      j___0 = 3U + ((unsigned int )b & 3U);
    #####: 2293:      b >>= 2;
    #####: 2294:      k -= 2U;
    #####: 2295:      if ((unsigned int )i___0 + j___0 > n) {
    #####: 2296:        return (1);
        -: 2297:      }
        -: 2298:      {
    #####: 2299:      while (1) {
        -: 2300:        while_continue___8: /* CIL Label */ ;
    #####: 2301:        tmp___19 = j___0;
    #####: 2302:        j___0 --;
    #####: 2303:        if (! tmp___19) {
    #####: 2304:          goto while_break___8;
        -: 2305:        }
    #####: 2306:        tmp___18 = i___0;
    #####: 2307:        i___0 ++;
    #####: 2308:        ll[tmp___18] = l;
        -: 2309:      }
        -: 2310:      while_break___8: /* CIL Label */ ;
        -: 2311:      }
    #####: 2312:    } else { //Added block
    #####: 2313:    if (j___0 == 17U) {
        -: 2314:      {
    #####: 2315:      while (1) {
        -: 2316:        while_continue___9: /* CIL Label */ ;
    #####: 2317:        if (! (k < 3U)) {
    #####: 2318:          goto while_break___9;
        -: 2319:        }
    #####: 2320:        if (inptr < insize) {
    #####: 2321:          tmp___20 = inptr;
    #####: 2322:          inptr ++;
    #####: 2323:          tmp___22 = (int )inbuf[tmp___20];
    #####: 2324:        } else {
        -: 2325:          {
    #####: 2326:          tmp___21 = fill_inbuf(0);
    #####: 2327:          tmp___22 = tmp___21;
        -: 2328:          }
        -: 2329:        }
    #####: 2330:        b |= (ulg )((uch )tmp___22) << k;
    #####: 2331:        k += 8U;
        -: 2332:      }
        -: 2333:      while_break___9: /* CIL Label */ ;
        -: 2334:      }
    #####: 2335:      j___0 = 3U + ((unsigned int )b & 7U);
    #####: 2336:      b >>= 3;
    #####: 2337:      k -= 3U;
    #####: 2338:      if ((unsigned int )i___0 + j___0 > n) {
    #####: 2339:        return (1);
        -: 2340:      }
        -: 2341:      {
    #####: 2342:      while (1) {
        -: 2343:        while_continue___10: /* CIL Label */ ;
    #####: 2344:        tmp___24 = j___0;
    #####: 2345:        j___0 --;
    #####: 2346:        if (! tmp___24) {
    #####: 2347:          goto while_break___10;
        -: 2348:        }
    #####: 2349:        tmp___23 = i___0;
    #####: 2350:        i___0 ++;
    #####: 2351:        ll[tmp___23] = 0U;
        -: 2352:      }
        -: 2353:      while_break___10: /* CIL Label */ ;
        -: 2354:      }
    #####: 2355:      l = 0U;
    #####: 2356:    } else {
        -: 2357:      {
    #####: 2358:      while (1) {
        -: 2359:        while_continue___11: /* CIL Label */ ;
    #####: 2360:        if (! (k < 7U)) {
    #####: 2361:          goto while_break___11;
        -: 2362:        }
    #####: 2363:        if (inptr < insize) {
    #####: 2364:          tmp___25 = inptr;
    #####: 2365:          inptr ++;
    #####: 2366:          tmp___27 = (int )inbuf[tmp___25];
    #####: 2367:        } else {
        -: 2368:          {
    #####: 2369:          tmp___26 = fill_inbuf(0);
    #####: 2370:          tmp___27 = tmp___26;
        -: 2371:          }
        -: 2372:        }
    #####: 2373:        b |= (ulg )((uch )tmp___27) << k;
    #####: 2374:        k += 8U;
        -: 2375:      }
        -: 2376:      while_break___11: /* CIL Label */ ;
        -: 2377:      }
    #####: 2378:      j___0 = 11U + ((unsigned int )b & 127U);
    #####: 2379:      b >>= 7;
    #####: 2380:      k -= 7U;
    #####: 2381:      if ((unsigned int )i___0 + j___0 > n) {
    #####: 2382:        return (1);
        -: 2383:      }
        -: 2384:      {
    #####: 2385:      while (1) {
        -: 2386:        while_continue___12: /* CIL Label */ ;
    #####: 2387:        tmp___29 = j___0;
    #####: 2388:        j___0 --;
    #####: 2389:        if (! tmp___29) {
    #####: 2390:          goto while_break___12;
        -: 2391:        }
    #####: 2392:        tmp___28 = i___0;
    #####: 2393:        i___0 ++;
    #####: 2394:        ll[tmp___28] = 0U;
        -: 2395:      }
        -: 2396:      while_break___12: /* CIL Label */ ;
        -: 2397:      }
    #####: 2398:      l = 0U;
        -: 2399:    }
        -: 2400:    }
        -: 2401:    }
        -: 2402:  }
        -: 2403:  while_break___5: /* CIL Label */ ;
        -: 2404:  }
        -: 2405:  {
    #####: 2406:  huft_free(tl);
    #####: 2407:  bb = b;
    #####: 2408:  bk = k;
    #####: 2409:  bl = lbits;
    #####: 2410:  i___0 = huft_build(ll, nl, 257U, cplens, cplext, & tl, & bl);
        -: 2411:  }
    #####: 2412:  if (i___0 != 0) {
    #####: 2413:    if (i___0 == 1) {
        -: 2414:      {
    #####: 2415:      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )" incomplete literal tree\n");
    #####: 2416:      huft_free(tl);
        -: 2417:      }
    #####: 2418:    }
    #####: 2419:    return (i___0);
        -: 2420:  }
        -: 2421:  {
    #####: 2422:  bd = dbits;
    #####: 2423:  i___0 = huft_build(ll + nl, nd, 0U, cpdist, cpdext, & td, & bd);
        -: 2424:  }
    #####: 2425:  if (i___0 != 0) {
    #####: 2426:    if (i___0 == 1) {
        -: 2427:      {
    #####: 2428:      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )" incomplete distance tree\n");
    #####: 2429:      huft_free(td);
        -: 2430:      }
    #####: 2431:    }
        -: 2432:    {
    #####: 2433:    huft_free(tl);
        -: 2434:    }
    #####: 2435:    return (i___0);
        -: 2436:  }
        -: 2437:  {
    #####: 2438:  tmp___30 = inflate_codes(tl, td, bl, bd);
        -: 2439:  }
    #####: 2440:  if (tmp___30) {
    #####: 2441:    return (1);
        -: 2442:  }
        -: 2443:  {
    #####: 2444:  huft_free(tl);
    #####: 2445:  huft_free(td);
        -: 2446:  }
    #####: 2447:  return (0);
        -: 2448:}
    #####: 2449:}
    #####: 2450:int inflate_block(int *e ) 
        -: 2451:{ 
        -: 2452:  unsigned int t ;
        -: 2453:  register ulg b ;
        -: 2454:  register unsigned int k ;
        -: 2455:  unsigned int tmp ;
        -: 2456:  int tmp___0 ;
        -: 2457:  int tmp___1 ;
        -: 2458:  unsigned int tmp___2 ;
        -: 2459:  int tmp___3 ;
        -: 2460:  int tmp___4 ;
        -: 2461:  int tmp___5 ;
        -: 2462:  int tmp___6 ;
        -: 2463:  int tmp___7 ;
        -: 2464:
        -: 2465:  {
    #####: 2466:  b = bb;
    #####: 2467:  k = bk;
        -: 2468:  {
    #####: 2469:  while (1) {
        -: 2470:    while_continue: /* CIL Label */ ;
    #####: 2471:    if (! (k < 1U)) {
    #####: 2472:      goto while_break;
        -: 2473:    }
    #####: 2474:    if (inptr < insize) {
    #####: 2475:      tmp = inptr;
    #####: 2476:      inptr ++;
    #####: 2477:      tmp___1 = (int )inbuf[tmp];
    #####: 2478:    } else {
        -: 2479:      {
    #####: 2480:      tmp___0 = fill_inbuf(0);
    #####: 2481:      tmp___1 = tmp___0;
        -: 2482:      }
        -: 2483:    }
    #####: 2484:    b |= (ulg )((uch )tmp___1) << k;
    #####: 2485:    k += 8U;
        -: 2486:  }
        -: 2487:  while_break: /* CIL Label */ ;
        -: 2488:  }
    #####: 2489:  *e = (int )b & 1;
    #####: 2490:  b >>= 1;
    #####: 2491:  k --;
        -: 2492:  {
    #####: 2493:  while (1) {
        -: 2494:    while_continue___0: /* CIL Label */ ;
    #####: 2495:    if (! (k < 2U)) {
    #####: 2496:      goto while_break___0;
        -: 2497:    }
    #####: 2498:    if (inptr < insize) {
    #####: 2499:      tmp___2 = inptr;
    #####: 2500:      inptr ++;
    #####: 2501:      tmp___4 = (int )inbuf[tmp___2];
    #####: 2502:    } else {
        -: 2503:      {
    #####: 2504:      tmp___3 = fill_inbuf(0);
    #####: 2505:      tmp___4 = tmp___3;
        -: 2506:      }
        -: 2507:    }
    #####: 2508:    b |= (ulg )((uch )tmp___4) << k;
    #####: 2509:    k += 8U;
        -: 2510:  }
        -: 2511:  while_break___0: /* CIL Label */ ;
        -: 2512:  }
    #####: 2513:  t = (unsigned int )b & 3U;
    #####: 2514:  b >>= 2;
    #####: 2515:  k -= 2U;
    #####: 2516:  bb = b;
    #####: 2517:  bk = k;
    #####: 2518:  if (t == 2U) {
        -: 2519:    {
    #####: 2520:    tmp___5 = inflate_dynamic();
        -: 2521:    }
    #####: 2522:    return (tmp___5);
        -: 2523:  }
    #####: 2524:  if (t == 0U) {
        -: 2525:    {
    #####: 2526:    tmp___6 = inflate_stored();
        -: 2527:    }
    #####: 2528:    return (tmp___6);
        -: 2529:  }
    #####: 2530:  if (t == 1U) {
        -: 2531:    {
    #####: 2532:    tmp___7 = inflate_fixed();
        -: 2533:    }
    #####: 2534:    return (tmp___7);
        -: 2535:  }
    #####: 2536:  return (2);
        -: 2537:}
    #####: 2538:}
    #####: 2539:int inflate(void) 
        -: 2540:{ 
        -: 2541:  int e ;
        -: 2542:  int r ;
        -: 2543:  unsigned int h ;
        -: 2544:
        -: 2545:  {
    #####: 2546:  outcnt = 0U;
    #####: 2547:  bk = 0U;
    #####: 2548:  bb = (ulg )0;
    #####: 2549:  h = 0U;
        -: 2550:  {
    #####: 2551:  while (1) {
        -: 2552:    while_continue: /* CIL Label */ ;
        -: 2553:    {
    #####: 2554:    hufts = 0U;
    #####: 2555:    r = inflate_block(& e);
        -: 2556:    }
    #####: 2557:    if (r != 0) {
    #####: 2558:      return (r);
        -: 2559:    }
    #####: 2560:    if (hufts > h) {
    #####: 2561:      h = hufts;
    #####: 2562:    }
    #####: 2563:    if (! (! e)) {
    #####: 2564:      goto while_break;
        -: 2565:    }
        -: 2566:  }
        -: 2567:  while_break: /* CIL Label */ ;
        -: 2568:  }
        -: 2569:  {
    #####: 2570:  while (1) {
        -: 2571:    while_continue___0: /* CIL Label */ ;
    #####: 2572:    if (! (bk >= 8U)) {
    #####: 2573:      goto while_break___0;
        -: 2574:    }
    #####: 2575:    bk -= 8U;
    #####: 2576:    inptr --;
        -: 2577:  }
        -: 2578:  while_break___0: /* CIL Label */ ;
        -: 2579:  }
        -: 2580:  {
    #####: 2581:  outcnt = outcnt;
    #####: 2582:  flush_window();
        -: 2583:  }
    #####: 2584:  return (0);
        -: 2585:}
    #####: 2586:}
        -: 2587:static int msg_done  =    0;
    #####: 2588:int lzw(int in , int out ) 
        -: 2589:{ 
        -: 2590:
        -: 2591:
        -: 2592:  {
    #####: 2593:  if (msg_done) {
    #####: 2594:    return (1);
        -: 2595:  }
        -: 2596:  {
    #####: 2597:  msg_done = 1;
    #####: 2598:  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"output in compress .Z format not supported\n");
        -: 2599:  }
    #####: 2600:  if (in != out) {
    #####: 2601:    exit_code = 1;
    #####: 2602:  }
    #####: 2603:  return (1);
        -: 2604:}
    #####: 2605:}
        -: 2606:static int extra_lbits[29]  = 
        -: 2607:  {      0,      0,      0,      0, 
        -: 2608:        0,      0,      0,      0, 
        -: 2609:        1,      1,      1,      1, 
        -: 2610:        2,      2,      2,      2, 
        -: 2611:        3,      3,      3,      3, 
        -: 2612:        4,      4,      4,      4, 
        -: 2613:        5,      5,      5,      5, 
        -: 2614:        0};
        -: 2615:static int extra_dbits[30]  = 
        -: 2616:  {      0,      0,      0,      0, 
        -: 2617:        1,      1,      2,      2, 
        -: 2618:        3,      3,      4,      4, 
        -: 2619:        5,      5,      6,      6, 
        -: 2620:        7,      7,      8,      8, 
        -: 2621:        9,      9,      10,      10, 
        -: 2622:        11,      11,      12,      12, 
        -: 2623:        13,      13};
        -: 2624:static int extra_blbits[19]  = 
        -: 2625:  {      0,      0,      0,      0, 
        -: 2626:        0,      0,      0,      0, 
        -: 2627:        0,      0,      0,      0, 
        -: 2628:        0,      0,      0,      0, 
        -: 2629:        2,      3,      7};
        -: 2630:static ct_data dyn_ltree[573]  ;
        -: 2631:static ct_data dyn_dtree[61]  ;
        -: 2632:static ct_data static_ltree[288]  ;
        -: 2633:static ct_data static_dtree[30]  ;
        -: 2634:static ct_data bl_tree[39]  ;
        -: 2635:static tree_desc l_desc  =    {dyn_ltree, static_ltree, extra_lbits, 257, 286, 15, 0};
        -: 2636:static tree_desc d_desc  =    {dyn_dtree, static_dtree, extra_dbits, 0, 30, 15, 0};
        -: 2637:static tree_desc bl_desc  =    {bl_tree, (ct_data *)0, extra_blbits, 0, 19, 7, 0};
        -: 2638:static ush bl_count[16]  ;
        -: 2639:static uch bl_order[19]  = 
        -: 2640:  {      (uch )16,      (uch )17,      (uch )18,      (uch )0, 
        -: 2641:        (uch )8,      (uch )7,      (uch )9,      (uch )6, 
        -: 2642:        (uch )10,      (uch )5,      (uch )11,      (uch )4, 
        -: 2643:        (uch )12,      (uch )3,      (uch )13,      (uch )2, 
        -: 2644:        (uch )14,      (uch )1,      (uch )15};
        -: 2645:static int heap[573]  ;
        -: 2646:static int heap_len  ;
        -: 2647:static int heap_max  ;
        -: 2648:static uch depth[573]  ;
        -: 2649:static uch length_code[256]  ;
        -: 2650:static uch dist_code[512]  ;
        -: 2651:static int base_length[29]  ;
        -: 2652:static int base_dist[30]  ;
        -: 2653:static uch flag_buf[4096]  ;
        -: 2654:static unsigned int last_lit  ;
        -: 2655:static unsigned int last_dist  ;
        -: 2656:static unsigned int last_flags  ;
        -: 2657:static uch flags  ;
        -: 2658:static uch flag_bit  ;
        -: 2659:static ulg opt_len  ;
        -: 2660:static ulg static_len  ;
        -: 2661:static off_t compressed_len  ;
        -: 2662:static off_t input_len  ;
        -: 2663:ush *file_type  ;
        -: 2664:int *file_method  ;
        -: 2665:static void init_block(void) ;
        -: 2666:static void pqdownheap(ct_data *tree , int k ) ;
        -: 2667:static void gen_bitlen(tree_desc *desc ) ;
        -: 2668:static void gen_codes(ct_data *tree , int max_code ) ;
        -: 2669:static void build_tree(tree_desc *desc ) ;
        -: 2670:static void scan_tree(ct_data *tree , int max_code ) ;
        -: 2671:static void send_tree(ct_data *tree , int max_code ) ;
        -: 2672:static int build_bl_tree(void) ;
        -: 2673:static void send_all_trees(int lcodes , int dcodes , int blcodes ) ;
        -: 2674:static void compress_block(ct_data *ltree , ct_data *dtree ) ;
        -: 2675:static void set_file_type(void) ;
        1: 2676:void ct_init(ush *attr , int *methodp ) 
        -: 2677:{ 
        -: 2678:  int n ;
        -: 2679:  int bits ;
        -: 2680:  int length ;
        -: 2681:  int code ;
        -: 2682:  int dist ;
        -: 2683:  int tmp ;
        -: 2684:  int tmp___0 ;
        -: 2685:  int tmp___1 ;
        -: 2686:  int tmp___2 ;
        -: 2687:  int tmp___3 ;
        -: 2688:  int tmp___4 ;
        -: 2689:  int tmp___5 ;
        -: 2690:  unsigned int tmp___6 ;
        -: 2691:
        -: 2692:  {
        1: 2693:  file_type = attr;
        1: 2694:  file_method = methodp;
        1: 2695:  input_len = 0L;
        1: 2696:  compressed_len = input_len;
        1: 2697:  if ((int )static_dtree[0].dl.len != 0) {
    #####: 2698:    return;
        -: 2699:  }
        1: 2700:  length = 0;
        1: 2701:  code = 0;
        -: 2702:  {
       29: 2703:  while (1) {
        -: 2704:    while_continue: /* CIL Label */ ;
       29: 2705:    if (! (code < 28)) {
        1: 2706:      goto while_break;
        -: 2707:    }
       28: 2708:    base_length[code] = length;
       28: 2709:    n = 0;
        -: 2710:    {
      284: 2711:    while (1) {
        -: 2712:      while_continue___0: /* CIL Label */ ;
      284: 2713:      if (! (n < 1 << extra_lbits[code])) {
       28: 2714:        goto while_break___0;
        -: 2715:      }
      256: 2716:      tmp = length;
      256: 2717:      length ++;
      256: 2718:      length_code[tmp] = (uch )code;
      256: 2719:      n ++;
        -: 2720:    }
        -: 2721:    while_break___0: /* CIL Label */ ;
        -: 2722:    }
       28: 2723:    code ++;
        -: 2724:  }
        -: 2725:  while_break: /* CIL Label */ ;
        -: 2726:  }
        1: 2727:  length_code[length - 1] = (uch )code;
        1: 2728:  dist = 0;
        1: 2729:  code = 0;
        -: 2730:  {
       17: 2731:  while (1) {
        -: 2732:    while_continue___1: /* CIL Label */ ;
       17: 2733:    if (! (code < 16)) {
        1: 2734:      goto while_break___1;
        -: 2735:    }
       16: 2736:    base_dist[code] = dist;
       16: 2737:    n = 0;
        -: 2738:    {
      272: 2739:    while (1) {
        -: 2740:      while_continue___2: /* CIL Label */ ;
      272: 2741:      if (! (n < 1 << extra_dbits[code])) {
       16: 2742:        goto while_break___2;
        -: 2743:      }
      256: 2744:      tmp___0 = dist;
      256: 2745:      dist ++;
      256: 2746:      dist_code[tmp___0] = (uch )code;
      256: 2747:      n ++;
        -: 2748:    }
        -: 2749:    while_break___2: /* CIL Label */ ;
        -: 2750:    }
       16: 2751:    code ++;
        -: 2752:  }
        -: 2753:  while_break___1: /* CIL Label */ ;
        -: 2754:  }
        1: 2755:  dist >>= 7;
        -: 2756:  {
       15: 2757:  while (1) {
        -: 2758:    while_continue___3: /* CIL Label */ ;
       15: 2759:    if (! (code < 30)) {
        1: 2760:      goto while_break___3;
        -: 2761:    }
       14: 2762:    base_dist[code] = dist << 7;
       14: 2763:    n = 0;
        -: 2764:    {
      268: 2765:    while (1) {
        -: 2766:      while_continue___4: /* CIL Label */ ;
      268: 2767:      if (! (n < 1 << (extra_dbits[code] - 7))) {
       14: 2768:        goto while_break___4;
        -: 2769:      }
      254: 2770:      tmp___1 = dist;
      254: 2771:      dist ++;
      254: 2772:      dist_code[256 + tmp___1] = (uch )code;
      254: 2773:      n ++;
        -: 2774:    }
        -: 2775:    while_break___4: /* CIL Label */ ;
        -: 2776:    }
       14: 2777:    code ++;
        -: 2778:  }
        -: 2779:  while_break___3: /* CIL Label */ ;
        -: 2780:  }
        1: 2781:  bits = 0;
        -: 2782:  {
       17: 2783:  while (1) {
        -: 2784:    while_continue___5: /* CIL Label */ ;
       17: 2785:    if (! (bits <= 15)) {
        1: 2786:      goto while_break___5;
        -: 2787:    }
       16: 2788:    bl_count[bits] = (ush )0;
       16: 2789:    bits ++;
        -: 2790:  }
        -: 2791:  while_break___5: /* CIL Label */ ;
        -: 2792:  }
        1: 2793:  n = 0;
        -: 2794:  {
      145: 2795:  while (1) {
        -: 2796:    while_continue___6: /* CIL Label */ ;
      145: 2797:    if (! (n <= 143)) {
        1: 2798:      goto while_break___6;
        -: 2799:    }
      144: 2800:    tmp___2 = n;
      144: 2801:    n ++;
      144: 2802:    static_ltree[tmp___2].dl.len = (ush )8;
      144: 2803:    bl_count[8] = (ush )((int )bl_count[8] + 1);
        -: 2804:  }
        -: 2805:  while_break___6: /* CIL Label */ ;
        -: 2806:  }
        -: 2807:  {
      113: 2808:  while (1) {
        -: 2809:    while_continue___7: /* CIL Label */ ;
      113: 2810:    if (! (n <= 255)) {
        1: 2811:      goto while_break___7;
        -: 2812:    }
      112: 2813:    tmp___3 = n;
      112: 2814:    n ++;
      112: 2815:    static_ltree[tmp___3].dl.len = (ush )9;
      112: 2816:    bl_count[9] = (ush )((int )bl_count[9] + 1);
        -: 2817:  }
        -: 2818:  while_break___7: /* CIL Label */ ;
        -: 2819:  }
        -: 2820:  {
       25: 2821:  while (1) {
        -: 2822:    while_continue___8: /* CIL Label */ ;
       25: 2823:    if (! (n <= 279)) {
        1: 2824:      goto while_break___8;
        -: 2825:    }
       24: 2826:    tmp___4 = n;
       24: 2827:    n ++;
       24: 2828:    static_ltree[tmp___4].dl.len = (ush )7;
       24: 2829:    bl_count[7] = (ush )((int )bl_count[7] + 1);
        -: 2830:  }
        -: 2831:  while_break___8: /* CIL Label */ ;
        -: 2832:  }
        -: 2833:  {
        9: 2834:  while (1) {
        -: 2835:    while_continue___9: /* CIL Label */ ;
        9: 2836:    if (! (n <= 287)) {
        1: 2837:      goto while_break___9;
        -: 2838:    }
        8: 2839:    tmp___5 = n;
        8: 2840:    n ++;
        8: 2841:    static_ltree[tmp___5].dl.len = (ush )8;
        8: 2842:    bl_count[8] = (ush )((int )bl_count[8] + 1);
        -: 2843:  }
        -: 2844:  while_break___9: /* CIL Label */ ;
        -: 2845:  }
        -: 2846:  {
        1: 2847:  gen_codes(static_ltree, 287);
        1: 2848:  n = 0;
        -: 2849:  }
        -: 2850:  {
       31: 2851:  while (1) {
        -: 2852:    while_continue___10: /* CIL Label */ ;
       31: 2853:    if (! (n < 30)) {
        1: 2854:      goto while_break___10;
        -: 2855:    }
        -: 2856:    {
       30: 2857:    static_dtree[n].dl.len = (ush )5;
       30: 2858:    tmp___6 = bi_reverse((unsigned int )n, 5);
       30: 2859:    static_dtree[n].fc.code = (ush )tmp___6;
       30: 2860:    n ++;
        -: 2861:    }
        -: 2862:  }
        -: 2863:  while_break___10: /* CIL Label */ ;
        -: 2864:  }
        -: 2865:  {
        1: 2866:  init_block();
        -: 2867:  }
        1: 2868:  return;
        -: 2869:}
        1: 2870:}
        2: 2871:static void init_block(void) 
        -: 2872:{ 
        -: 2873:  int n ;
        -: 2874:
        -: 2875:  {
        2: 2876:  n = 0;
        -: 2877:  {
      574: 2878:  while (1) {
        -: 2879:    while_continue: /* CIL Label */ ;
      574: 2880:    if (! (n < 286)) {
        2: 2881:      goto while_break;
        -: 2882:    }
      572: 2883:    dyn_ltree[n].fc.freq = (ush )0;
      572: 2884:    n ++;
        -: 2885:  }
        -: 2886:  while_break: /* CIL Label */ ;
        -: 2887:  }
        2: 2888:  n = 0;
        -: 2889:  {
       62: 2890:  while (1) {
        -: 2891:    while_continue___0: /* CIL Label */ ;
       62: 2892:    if (! (n < 30)) {
        2: 2893:      goto while_break___0;
        -: 2894:    }
       60: 2895:    dyn_dtree[n].fc.freq = (ush )0;
       60: 2896:    n ++;
        -: 2897:  }
        -: 2898:  while_break___0: /* CIL Label */ ;
        -: 2899:  }
        2: 2900:  n = 0;
        -: 2901:  {
       40: 2902:  while (1) {
        -: 2903:    while_continue___1: /* CIL Label */ ;
       40: 2904:    if (! (n < 19)) {
        2: 2905:      goto while_break___1;
        -: 2906:    }
       38: 2907:    bl_tree[n].fc.freq = (ush )0;
       38: 2908:    n ++;
        -: 2909:  }
        -: 2910:  while_break___1: /* CIL Label */ ;
        -: 2911:  }
        2: 2912:  dyn_ltree[256].fc.freq = (ush )1;
        2: 2913:  static_len = (ulg )0L;
        2: 2914:  opt_len = static_len;
        2: 2915:  last_flags = 0U;
        2: 2916:  last_dist = last_flags;
        2: 2917:  last_lit = last_dist;
        2: 2918:  flags = (uch )0;
        2: 2919:  flag_bit = (uch )1;
        2: 2920:  return;
        -: 2921:}
        -: 2922:}
      383: 2923:static void pqdownheap(ct_data *tree , int k ) 
        -: 2924:{ 
        -: 2925:  int v ;
        -: 2926:  int j___0 ;
        -: 2927:
        -: 2928:  {
      383: 2929:  v = heap[k];
      383: 2930:  j___0 = k << 1;
        -: 2931:  {
     1534: 2932:  while (1) {
        -: 2933:    while_continue: /* CIL Label */ ;
     1534: 2934:    if (! (j___0 <= heap_len)) {
      248: 2935:      goto while_break;
        -: 2936:    }
     1286: 2937:    if (j___0 < heap_len) {
     1260: 2938:      if ((int )(tree + heap[j___0 + 1])->fc.freq < (int )(tree + heap[j___0])->fc.freq) {
      532: 2939:        j___0 ++;
      532: 2940:      } else { //Added block
      728: 2941:      if ((int )(tree + heap[j___0 + 1])->fc.freq == (int )(tree + heap[j___0])->fc.freq) {
      142: 2942:        if ((int )depth[heap[j___0 + 1]] <= (int )depth[heap[j___0]]) {
      100: 2943:          j___0 ++;
      100: 2944:        }
      142: 2945:      }
        -: 2946:      }
     1260: 2947:    }
     1286: 2948:    if ((int )(tree + v)->fc.freq < (int )(tree + heap[j___0])->fc.freq) {
      123: 2949:      goto while_break;
        -: 2950:    } else { //Added block
     1163: 2951:    if ((int )(tree + v)->fc.freq == (int )(tree + heap[j___0])->fc.freq) {
       29: 2952:      if ((int )depth[v] <= (int )depth[heap[j___0]]) {
       12: 2953:        goto while_break;
        -: 2954:      }
       17: 2955:    }
        -: 2956:    }
     1151: 2957:    heap[k] = heap[j___0];
     1151: 2958:    k = j___0;
     1151: 2959:    j___0 <<= 1;
        -: 2960:  }
        -: 2961:  while_break: /* CIL Label */ ;
        -: 2962:  }
      383: 2963:  heap[k] = v;
      383: 2964:  return;
        -: 2965:}
        -: 2966:}
        3: 2967:static void gen_bitlen(tree_desc *desc ) 
        -: 2968:{ 
        -: 2969:  ct_data *tree ;
        -: 2970:  int *extra ;
        -: 2971:  int base ;
        -: 2972:  int max_code ;
        -: 2973:  int max_length ;
        -: 2974:  ct_data *stree ;
        -: 2975:  int h ;
        -: 2976:  int n ;
        -: 2977:  int m ;
        -: 2978:  int bits ;
        -: 2979:  int xbits ;
        -: 2980:  ush f ;
        -: 2981:  int overflow ;
        -: 2982:
        -: 2983:  {
        3: 2984:  tree = desc->dyn_tree;
        3: 2985:  extra = desc->extra_bits;
        3: 2986:  base = desc->extra_base;
        3: 2987:  max_code = desc->max_code;
        3: 2988:  max_length = desc->max_length;
        3: 2989:  stree = desc->static_tree;
        3: 2990:  overflow = 0;
        3: 2991:  bits = 0;
        -: 2992:  {
       51: 2993:  while (1) {
        -: 2994:    while_continue: /* CIL Label */ ;
       51: 2995:    if (! (bits <= 15)) {
        3: 2996:      goto while_break;
        -: 2997:    }
       48: 2998:    bl_count[bits] = (ush )0;
       48: 2999:    bits ++;
        -: 3000:  }
        -: 3001:  while_break: /* CIL Label */ ;
        -: 3002:  }
        3: 3003:  (tree + heap[heap_max])->dl.len = (ush )0;
        3: 3004:  h = heap_max + 1;
        -: 3005:  {
      309: 3006:  while (1) {
        -: 3007:    while_continue___0: /* CIL Label */ ;
      309: 3008:    if (! (h < 573)) {
        3: 3009:      goto while_break___0;
        -: 3010:    }
      306: 3011:    n = heap[h];
      306: 3012:    bits = (int )(tree + (int )(tree + n)->dl.dad)->dl.len + 1;
      306: 3013:    if (bits > max_length) {
    #####: 3014:      bits = max_length;
    #####: 3015:      overflow ++;
    #####: 3016:    }
      306: 3017:    (tree + n)->dl.len = (ush )bits;
      306: 3018:    if (n > max_code) {
      150: 3019:      goto __Cont;
        -: 3020:    }
      156: 3021:    bl_count[bits] = (ush )((int )bl_count[bits] + 1);
      156: 3022:    xbits = 0;
      156: 3023:    if (n >= base) {
       64: 3024:      xbits = *(extra + (n - base));
       64: 3025:    }
      156: 3026:    f = (tree + n)->fc.freq;
      156: 3027:    opt_len += (ulg )f * (ulg )(bits + xbits);
      297: 3028:    if (stree) {
      141: 3029:      static_len += (ulg )f * (ulg )((int )(stree + n)->dl.len + xbits);
      141: 3030:    }
        -: 3031:    __Cont: 
      306: 3032:    h ++;
        -: 3033:  }
        -: 3034:  while_break___0: /* CIL Label */ ;
        -: 3035:  }
        3: 3036:  if (overflow == 0) {
        3: 3037:    return;
        -: 3038:  }
        -: 3039:  {
    #####: 3040:  while (1) {
        -: 3041:    while_continue___1: /* CIL Label */ ;
    #####: 3042:    bits = max_length - 1;
        -: 3043:    {
    #####: 3044:    while (1) {
        -: 3045:      while_continue___2: /* CIL Label */ ;
    #####: 3046:      if (! ((int )bl_count[bits] == 0)) {
    #####: 3047:        goto while_break___2;
        -: 3048:      }
    #####: 3049:      bits --;
        -: 3050:    }
        -: 3051:    while_break___2: /* CIL Label */ ;
        -: 3052:    }
    #####: 3053:    bl_count[bits] = (ush )((int )bl_count[bits] - 1);
    #####: 3054:    bl_count[bits + 1] = (ush )((int )bl_count[bits + 1] + 2);
    #####: 3055:    bl_count[max_length] = (ush )((int )bl_count[max_length] - 1);
    #####: 3056:    overflow -= 2;
    #####: 3057:    if (! (overflow > 0)) {
    #####: 3058:      goto while_break___1;
        -: 3059:    }
        -: 3060:  }
        -: 3061:  while_break___1: /* CIL Label */ ;
        -: 3062:  }
    #####: 3063:  bits = max_length;
        -: 3064:  {
    #####: 3065:  while (1) {
        -: 3066:    while_continue___3: /* CIL Label */ ;
    #####: 3067:    if (! (bits != 0)) {
    #####: 3068:      goto while_break___3;
        -: 3069:    }
    #####: 3070:    n = (int )bl_count[bits];
        -: 3071:    {
    #####: 3072:    while (1) {
        -: 3073:      while_continue___4: /* CIL Label */ ;
    #####: 3074:      if (! (n != 0)) {
    #####: 3075:        goto while_break___4;
        -: 3076:      }
    #####: 3077:      h --;
    #####: 3078:      m = heap[h];
    #####: 3079:      if (m > max_code) {
    #####: 3080:        goto while_continue___4;
        -: 3081:      }
    #####: 3082:      if ((unsigned int )(tree + m)->dl.len != (unsigned int )bits) {
    #####: 3083:        opt_len += (ulg )(((long )bits - (long )(tree + m)->dl.len) * (long )(tree + m)->fc.freq);
    #####: 3084:        (tree + m)->dl.len = (ush )bits;
    #####: 3085:      }
    #####: 3086:      n --;
        -: 3087:    }
        -: 3088:    while_break___4: /* CIL Label */ ;
        -: 3089:    }
    #####: 3090:    bits --;
        -: 3091:  }
        -: 3092:  while_break___3: /* CIL Label */ ;
        -: 3093:  }
    #####: 3094:  return;
        -: 3095:}
        3: 3096:}
        4: 3097:static void gen_codes(ct_data *tree , int max_code ) 
        -: 3098:{ 
        -: 3099:  ush next_code[16] ;
        -: 3100:  ush code ;
        -: 3101:  int bits ;
        -: 3102:  int n ;
        -: 3103:  int len ;
        -: 3104:  ush tmp ;
        -: 3105:  unsigned int tmp___0 ;
        -: 3106:
        -: 3107:  {
        4: 3108:  code = (ush )0;
        4: 3109:  bits = 1;
        -: 3110:  {
       64: 3111:  while (1) {
        -: 3112:    while_continue: /* CIL Label */ ;
       64: 3113:    if (! (bits <= 15)) {
        4: 3114:      goto while_break;
        -: 3115:    }
       60: 3116:    code = (ush )(((int )code + (int )bl_count[bits - 1]) << 1);
       60: 3117:    next_code[bits] = code;
       60: 3118:    bits ++;
        -: 3119:  }
        -: 3120:  while_break: /* CIL Label */ ;
        -: 3121:  }
        4: 3122:  n = 0;
        -: 3123:  {
      627: 3124:  while (1) {
        -: 3125:    while_continue___0: /* CIL Label */ ;
      627: 3126:    if (! (n <= max_code)) {
        4: 3127:      goto while_break___0;
        -: 3128:    }
      623: 3129:    len = (int )(tree + n)->dl.len;
      623: 3130:    if (len == 0) {
      179: 3131:      goto __Cont;
        -: 3132:    }
        -: 3133:    {
      444: 3134:    tmp = next_code[len];
      444: 3135:    next_code[len] = (ush )((int )next_code[len] + 1);
      444: 3136:    tmp___0 = bi_reverse((unsigned int )tmp, len);
      444: 3137:    (tree + n)->fc.code = (ush )tmp___0;
      444: 3138:    }
        -: 3139:    __Cont: 
      623: 3140:    n ++;
        -: 3141:  }
        -: 3142:  while_break___0: /* CIL Label */ ;
        -: 3143:  }
        4: 3144:  return;
        -: 3145:}
        -: 3146:}
        3: 3147:static void build_tree(tree_desc *desc ) 
        -: 3148:{ 
        -: 3149:  ct_data *tree ;
        -: 3150:  ct_data *stree ;
        -: 3151:  int elems ;
        -: 3152:  int n ;
        -: 3153:  int m ;
        -: 3154:  int max_code ;
        -: 3155:  int node ;
        -: 3156:  int new ;
        -: 3157:  int tmp ;
        -: 3158:  int tmp___0 ;
        -: 3159:  int tmp___1 ;
        -: 3160:  ush tmp___2 ;
        -: 3161:  int tmp___3 ;
        -: 3162:
        -: 3163:  {
        3: 3164:  tree = desc->dyn_tree;
        3: 3165:  stree = desc->static_tree;
        3: 3166:  elems = desc->elems;
        3: 3167:  max_code = -1;
        3: 3168:  node = elems;
        3: 3169:  heap_len = 0;
        3: 3170:  heap_max = 573;
        3: 3171:  n = 0;
        -: 3172:  {
      338: 3173:  while (1) {
        -: 3174:    while_continue: /* CIL Label */ ;
      338: 3175:    if (! (n < elems)) {
        3: 3176:      goto while_break;
        -: 3177:    }
      335: 3178:    if ((int )(tree + n)->fc.freq != 0) {
      156: 3179:      heap_len ++;
      156: 3180:      max_code = n;
      156: 3181:      heap[heap_len] = max_code;
      156: 3182:      depth[n] = (uch )0;
      156: 3183:    } else {
      179: 3184:      (tree + n)->dl.len = (ush )0;
        -: 3185:    }
      335: 3186:    n ++;
        -: 3187:  }
        -: 3188:  while_break: /* CIL Label */ ;
        -: 3189:  }
        -: 3190:  {
        3: 3191:  while (1) {
        -: 3192:    while_continue___0: /* CIL Label */ ;
        3: 3193:    if (! (heap_len < 2)) {
        3: 3194:      goto while_break___0;
        -: 3195:    }
    #####: 3196:    heap_len ++;
    #####: 3197:    if (max_code < 2) {
    #####: 3198:      max_code ++;
    #####: 3199:      tmp = max_code;
    #####: 3200:    } else {
    #####: 3201:      tmp = 0;
        -: 3202:    }
    #####: 3203:    heap[heap_len] = tmp;
    #####: 3204:    new = tmp;
    #####: 3205:    (tree + new)->fc.freq = (ush )1;
    #####: 3206:    depth[new] = (uch )0;
    #####: 3207:    opt_len --;
    #####: 3208:    if (stree) {
    #####: 3209:      static_len -= (ulg )(stree + new)->dl.len;
    #####: 3210:    }
        -: 3211:  }
        -: 3212:  while_break___0: /* CIL Label */ ;
        -: 3213:  }
        3: 3214:  desc->max_code = max_code;
        3: 3215:  n = heap_len / 2;
        -: 3216:  {
       80: 3217:  while (1) {
        -: 3218:    while_continue___1: /* CIL Label */ ;
       80: 3219:    if (! (n >= 1)) {
        3: 3220:      goto while_break___1;
        -: 3221:    }
        -: 3222:    {
       77: 3223:    pqdownheap(tree, n);
       77: 3224:    n --;
        -: 3225:    }
        -: 3226:  }
        -: 3227:  while_break___1: /* CIL Label */ ;
        -: 3228:  }
        -: 3229:  {
      153: 3230:  while (1) {
        -: 3231:    while_continue___2: /* CIL Label */ ;
        -: 3232:    {
      153: 3233:    n = heap[1];
      153: 3234:    tmp___0 = heap_len;
      153: 3235:    heap_len --;
      153: 3236:    heap[1] = heap[tmp___0];
      153: 3237:    pqdownheap(tree, 1);
      153: 3238:    m = heap[1];
      153: 3239:    heap_max --;
      153: 3240:    heap[heap_max] = n;
      153: 3241:    heap_max --;
      153: 3242:    heap[heap_max] = m;
      153: 3243:    (tree + node)->fc.freq = (ush )((int )(tree + n)->fc.freq + (int )(tree + m)->fc.freq);
        -: 3244:    }
      153: 3245:    if ((int )depth[n] >= (int )depth[m]) {
       99: 3246:      tmp___1 = (int )depth[n];
       99: 3247:    } else {
       54: 3248:      tmp___1 = (int )depth[m];
        -: 3249:    }
        -: 3250:    {
      153: 3251:    depth[node] = (uch )(tmp___1 + 1);
      153: 3252:    tmp___2 = (ush )node;
      153: 3253:    (tree + m)->dl.dad = tmp___2;
      153: 3254:    (tree + n)->dl.dad = tmp___2;
      153: 3255:    tmp___3 = node;
      153: 3256:    node ++;
      153: 3257:    heap[1] = tmp___3;
      153: 3258:    pqdownheap(tree, 1);
        -: 3259:    }
      153: 3260:    if (! (heap_len >= 2)) {
        3: 3261:      goto while_break___2;
        -: 3262:    }
        -: 3263:  }
        -: 3264:  while_break___2: /* CIL Label */ ;
        -: 3265:  }
        -: 3266:  {
        3: 3267:  heap_max --;
        3: 3268:  heap[heap_max] = heap[1];
        3: 3269:  gen_bitlen(desc);
        3: 3270:  gen_codes(tree, max_code);
        -: 3271:  }
        3: 3272:  return;
        -: 3273:}
        -: 3274:}
        2: 3275:static void scan_tree(ct_data *tree , int max_code ) 
        -: 3276:{ 
        -: 3277:  int n ;
        -: 3278:  int prevlen ;
        -: 3279:  int curlen ;
        -: 3280:  int nextlen ;
        -: 3281:  int count ;
        -: 3282:  int max_count ;
        -: 3283:  int min_count ;
        -: 3284:
        -: 3285:  {
        2: 3286:  prevlen = -1;
        2: 3287:  nextlen = (int )(tree + 0)->dl.len;
        2: 3288:  count = 0;
        2: 3289:  max_count = 7;
        2: 3290:  min_count = 4;
        2: 3291:  if (nextlen == 0) {
        1: 3292:    max_count = 138;
        1: 3293:    min_count = 3;
        1: 3294:  }
        2: 3295:  (tree + (max_code + 1))->dl.len = (ush )65535;
        2: 3296:  n = 0;
        -: 3297:  {
      318: 3298:  while (1) {
        -: 3299:    while_continue: /* CIL Label */ ;
      318: 3300:    if (! (n <= max_code)) {
        2: 3301:      goto while_break;
        -: 3302:    }
      316: 3303:    curlen = nextlen;
      316: 3304:    nextlen = (int )(tree + (n + 1))->dl.len;
      316: 3305:    count ++;
      316: 3306:    if (count < max_count) {
      315: 3307:      if (curlen == nextlen) {
      205: 3308:        goto __Cont;
        -: 3309:      } else {
      110: 3310:        goto _L;
        -: 3311:      }
        1: 3312:    } else { //Added block
        -: 3313:    _L: 
      111: 3314:    if (count < min_count) {
      103: 3315:      bl_tree[curlen].fc.freq = (ush )((int )bl_tree[curlen].fc.freq + count);
      103: 3316:    } else { //Added block
        8: 3317:    if (curlen != 0) {
        3: 3318:      if (curlen != prevlen) {
        3: 3319:        bl_tree[curlen].fc.freq = (ush )((int )bl_tree[curlen].fc.freq + 1);
        3: 3320:      }
        3: 3321:      bl_tree[16].fc.freq = (ush )((int )bl_tree[16].fc.freq + 1);
        3: 3322:    } else { //Added block
        5: 3323:    if (count <= 10) {
        3: 3324:      bl_tree[17].fc.freq = (ush )((int )bl_tree[17].fc.freq + 1);
        3: 3325:    } else {
        2: 3326:      bl_tree[18].fc.freq = (ush )((int )bl_tree[18].fc.freq + 1);
        -: 3327:    }
        -: 3328:    }
        -: 3329:    }
        -: 3330:    }
      111: 3331:    count = 0;
      111: 3332:    prevlen = curlen;
      222: 3333:    if (nextlen == 0) {
       12: 3334:      max_count = 138;
       12: 3335:      min_count = 3;
       12: 3336:    } else { //Added block
       99: 3337:    if (curlen == nextlen) {
        1: 3338:      max_count = 6;
        1: 3339:      min_count = 3;
        1: 3340:    } else {
       98: 3341:      max_count = 7;
       98: 3342:      min_count = 4;
        -: 3343:    }
        -: 3344:    }
        -: 3345:    __Cont: 
      316: 3346:    n ++;
        -: 3347:  }
        -: 3348:  while_break: /* CIL Label */ ;
        -: 3349:  }
        2: 3350:  return;
        -: 3351:}
        -: 3352:}
        2: 3353:static void send_tree(ct_data *tree , int max_code ) 
        -: 3354:{ 
        -: 3355:  int n ;
        -: 3356:  int prevlen ;
        -: 3357:  int curlen ;
        -: 3358:  int nextlen ;
        -: 3359:  int count ;
        -: 3360:  int max_count ;
        -: 3361:  int min_count ;
        -: 3362:
        -: 3363:  {
        2: 3364:  prevlen = -1;
        2: 3365:  nextlen = (int )(tree + 0)->dl.len;
        2: 3366:  count = 0;
        2: 3367:  max_count = 7;
        2: 3368:  min_count = 4;
        2: 3369:  if (nextlen == 0) {
        1: 3370:    max_count = 138;
        1: 3371:    min_count = 3;
        1: 3372:  }
        2: 3373:  n = 0;
        -: 3374:  {
      318: 3375:  while (1) {
        -: 3376:    while_continue: /* CIL Label */ ;
      318: 3377:    if (! (n <= max_code)) {
        2: 3378:      goto while_break;
        -: 3379:    }
      316: 3380:    curlen = nextlen;
      316: 3381:    nextlen = (int )(tree + (n + 1))->dl.len;
      316: 3382:    count ++;
      316: 3383:    if (count < max_count) {
      315: 3384:      if (curlen == nextlen) {
      205: 3385:        goto __Cont;
        -: 3386:      } else {
      110: 3387:        goto _L;
        -: 3388:      }
        1: 3389:    } else { //Added block
        -: 3390:    _L: 
      111: 3391:    if (count < min_count) {
        -: 3392:      {
      135: 3393:      while (1) {
        -: 3394:        while_continue___0: /* CIL Label */ ;
        -: 3395:        {
      135: 3396:        send_bits((int )bl_tree[curlen].fc.code, (int )bl_tree[curlen].dl.len);
      135: 3397:        count --;
        -: 3398:        }
      135: 3399:        if (! (count != 0)) {
      103: 3400:          goto while_break___0;
        -: 3401:        }
        -: 3402:      }
        -: 3403:      while_break___0: /* CIL Label */ ;
        -: 3404:      }
      103: 3405:    } else { //Added block
        8: 3406:    if (curlen != 0) {
        3: 3407:      if (curlen != prevlen) {
        -: 3408:        {
        3: 3409:        send_bits((int )bl_tree[curlen].fc.code, (int )bl_tree[curlen].dl.len);
        3: 3410:        count --;
        -: 3411:        }
        3: 3412:      }
        -: 3413:      {
        3: 3414:      send_bits((int )bl_tree[16].fc.code, (int )bl_tree[16].dl.len);
        3: 3415:      send_bits(count - 3, 2);
        -: 3416:      }
        3: 3417:    } else { //Added block
        5: 3418:    if (count <= 10) {
        -: 3419:      {
        3: 3420:      send_bits((int )bl_tree[17].fc.code, (int )bl_tree[17].dl.len);
        3: 3421:      send_bits(count - 3, 3);
        -: 3422:      }
        3: 3423:    } else {
        -: 3424:      {
        2: 3425:      send_bits((int )bl_tree[18].fc.code, (int )bl_tree[18].dl.len);
        2: 3426:      send_bits(count - 11, 7);
        -: 3427:      }
        -: 3428:    }
        -: 3429:    }
        -: 3430:    }
        -: 3431:    }
      111: 3432:    count = 0;
      111: 3433:    prevlen = curlen;
      222: 3434:    if (nextlen == 0) {
       12: 3435:      max_count = 138;
       12: 3436:      min_count = 3;
       12: 3437:    } else { //Added block
       99: 3438:    if (curlen == nextlen) {
        1: 3439:      max_count = 6;
        1: 3440:      min_count = 3;
        1: 3441:    } else {
       98: 3442:      max_count = 7;
       98: 3443:      min_count = 4;
        -: 3444:    }
        -: 3445:    }
        -: 3446:    __Cont: 
      316: 3447:    n ++;
        -: 3448:  }
        -: 3449:  while_break: /* CIL Label */ ;
        -: 3450:  }
        2: 3451:  return;
        -: 3452:}
        -: 3453:}
        1: 3454:static int build_bl_tree(void) 
        -: 3455:{ 
        -: 3456:  int max_blindex ;
        -: 3457:
        -: 3458:  {
        -: 3459:  {
        1: 3460:  scan_tree(dyn_ltree, l_desc.max_code);
        1: 3461:  scan_tree(dyn_dtree, d_desc.max_code);
        1: 3462:  build_tree(& bl_desc);
        1: 3463:  max_blindex = 18;
        -: 3464:  }
        -: 3465:  {
        5: 3466:  while (1) {
        -: 3467:    while_continue: /* CIL Label */ ;
        5: 3468:    if (! (max_blindex >= 3)) {
    #####: 3469:      goto while_break;
        -: 3470:    }
        5: 3471:    if ((int )bl_tree[bl_order[max_blindex]].dl.len != 0) {
        1: 3472:      goto while_break;
        -: 3473:    }
        4: 3474:    max_blindex --;
        -: 3475:  }
        -: 3476:  while_break: /* CIL Label */ ;
        -: 3477:  }
        1: 3478:  opt_len += (ulg )(((3 * (max_blindex + 1) + 5) + 5) + 4);
        1: 3479:  return (max_blindex);
        -: 3480:}
        -: 3481:}
        1: 3482:static void send_all_trees(int lcodes , int dcodes , int blcodes ) 
        -: 3483:{ 
        -: 3484:  int rank ;
        -: 3485:
        -: 3486:  {
        -: 3487:  {
        1: 3488:  send_bits(lcodes - 257, 5);
        1: 3489:  send_bits(dcodes - 1, 5);
        1: 3490:  send_bits(blcodes - 4, 4);
        1: 3491:  rank = 0;
        -: 3492:  }
        -: 3493:  {
       16: 3494:  while (1) {
        -: 3495:    while_continue: /* CIL Label */ ;
       16: 3496:    if (! (rank < blcodes)) {
        1: 3497:      goto while_break;
        -: 3498:    }
        -: 3499:    {
       15: 3500:    send_bits((int )bl_tree[bl_order[rank]].dl.len, 3);
       15: 3501:    rank ++;
        -: 3502:    }
        -: 3503:  }
        -: 3504:  while_break: /* CIL Label */ ;
        -: 3505:  }
        -: 3506:  {
        1: 3507:  send_tree(dyn_ltree, lcodes - 1);
        1: 3508:  send_tree(dyn_dtree, dcodes - 1);
        -: 3509:  }
        1: 3510:  return;
        -: 3511:}
        -: 3512:}
        1: 3513:off_t flush_block(char *buf , ulg stored_len , int eof ) 
        -: 3514:{ 
        -: 3515:  ulg opt_lenb ;
        -: 3516:  ulg static_lenb ;
        -: 3517:  int max_blindex ;
        -: 3518:
        -: 3519:  {
        1: 3520:  flag_buf[last_flags] = flags;
        1: 3521:  if ((int )*file_type == 65535) {
        -: 3522:    {
    #####: 3523:    set_file_type();
        -: 3524:    }
    #####: 3525:  }
        -: 3526:  {
        1: 3527:  build_tree(& l_desc);
        1: 3528:  build_tree(& d_desc);
        1: 3529:  max_blindex = build_bl_tree();
        1: 3530:  opt_lenb = ((opt_len + 3UL) + 7UL) >> 3;
        1: 3531:  static_lenb = ((static_len + 3UL) + 7UL) >> 3;
        1: 3532:  input_len = (off_t )((ulg )input_len + stored_len);
        -: 3533:  }
        1: 3534:  if (static_lenb <= opt_lenb) {
    #####: 3535:    opt_lenb = static_lenb;
    #####: 3536:  }
        1: 3537:  if (stored_len <= opt_lenb) {
    #####: 3538:    if (eof) {
    #####: 3539:      if (compressed_len == 0L) {
    #####: 3540:        goto _L___2;
        -: 3541:      } else {
    #####: 3542:        goto _L___2;
        -: 3543:      }
        -: 3544:    } else {
    #####: 3545:      goto _L___2;
        -: 3546:    }
        1: 3547:  } else { //Added block
        -: 3548:  _L___2: 
        1: 3549:  if (stored_len + 4UL <= opt_lenb) {
    #####: 3550:    if ((unsigned long )buf != (unsigned long )((char *)0)) {
        -: 3551:      {
    #####: 3552:      send_bits(eof, 3);
    #####: 3553:      compressed_len = ((compressed_len + 3L) + 7L) & -8L;
    #####: 3554:      compressed_len = (off_t )((ulg )compressed_len + ((stored_len + 4UL) << 3));
    #####: 3555:      copy_block(buf, (unsigned int )stored_len, 1);
        -: 3556:      }
    #####: 3557:    } else {
    #####: 3558:      goto _L;
        -: 3559:    }
        1: 3560:  } else { //Added block
        -: 3561:  _L: 
        1: 3562:  if (static_lenb == opt_lenb) {
        -: 3563:    {
    #####: 3564:    send_bits((1 << 1) + eof, 3);
    #####: 3565:    compress_block(static_ltree, static_dtree);
    #####: 3566:    compressed_len = (off_t )((ulg )compressed_len + (3UL + static_len));
        -: 3567:    }
    #####: 3568:  } else {
        -: 3569:    {
        1: 3570:    send_bits((2 << 1) + eof, 3);
        1: 3571:    send_all_trees(l_desc.max_code + 1, d_desc.max_code + 1, max_blindex + 1);
        1: 3572:    compress_block(dyn_ltree, dyn_dtree);
        1: 3573:    compressed_len = (off_t )((ulg )compressed_len + (3UL + opt_len));
        -: 3574:    }
        -: 3575:  }
        -: 3576:  }
        -: 3577:  }
        -: 3578:  {
        1: 3579:  init_block();
        -: 3580:  }
        1: 3581:  if (eof) {
        -: 3582:    {
        1: 3583:    bi_windup();
        1: 3584:    compressed_len += 7L;
        -: 3585:    }
        1: 3586:  }
        1: 3587:  return (compressed_len >> 3);
        -: 3588:}
        -: 3589:}
     7401: 3590:int ct_tally(int dist , int lc ) 
        -: 3591:{ 
        -: 3592:  unsigned int tmp ;
        -: 3593:  int tmp___0 ;
        -: 3594:  unsigned int tmp___1 ;
        -: 3595:  unsigned int tmp___2 ;
        -: 3596:  ulg out_length ;
        -: 3597:  ulg in_length ;
        -: 3598:  int dcode ;
        -: 3599:  int tmp___3 ;
        -: 3600:
        -: 3601:  {
     7401: 3602:  tmp = last_lit;
     7401: 3603:  last_lit ++;
     7401: 3604:  inbuf[tmp] = (uch )lc;
     7401: 3605:  if (dist == 0) {
     3235: 3606:    dyn_ltree[lc].fc.freq = (ush )((int )dyn_ltree[lc].fc.freq + 1);
     3235: 3607:  } else {
     4166: 3608:    dist --;
     4166: 3609:    dyn_ltree[((int )length_code[lc] + 256) + 1].fc.freq = (ush )((int )dyn_ltree[((int )length_code[lc] + 256) + 1].fc.freq + 1);
     4166: 3610:    if (dist < 256) {
      956: 3611:      tmp___0 = (int )dist_code[dist];
      956: 3612:    } else {
     3210: 3613:      tmp___0 = (int )dist_code[256 + (dist >> 7)];
        -: 3614:    }
     4166: 3615:    dyn_dtree[tmp___0].fc.freq = (ush )((int )dyn_dtree[tmp___0].fc.freq + 1);
     4166: 3616:    tmp___1 = last_dist;
     4166: 3617:    last_dist ++;
     4166: 3618:    d_buf[tmp___1] = (ush )dist;
     4166: 3619:    flags = (uch )((int )flags | (int )flag_bit);
        -: 3620:  }
     7401: 3621:  flag_bit = (uch )((int )flag_bit << 1);
     7401: 3622:  if ((last_lit & 7U) == 0U) {
      925: 3623:    tmp___2 = last_flags;
      925: 3624:    last_flags ++;
      925: 3625:    flag_buf[tmp___2] = flags;
      925: 3626:    flags = (uch )0;
      925: 3627:    flag_bit = (uch )1;
      925: 3628:  }
     7401: 3629:  if (level > 2) {
     7401: 3630:    if ((last_lit & 4095U) == 0U) {
        1: 3631:      out_length = (ulg )last_lit * 8UL;
        1: 3632:      in_length = (ulg )strstart - (ulg )block_start;
        1: 3633:      dcode = 0;
        -: 3634:      {
       31: 3635:      while (1) {
        -: 3636:        while_continue: /* CIL Label */ ;
       31: 3637:        if (! (dcode < 30)) {
        1: 3638:          goto while_break;
        -: 3639:        }
       30: 3640:        out_length += (ulg )dyn_dtree[dcode].fc.freq * (ulg )(5L + (long )extra_dbits[dcode]);
       30: 3641:        dcode ++;
        -: 3642:      }
        -: 3643:      while_break: /* CIL Label */ ;
        -: 3644:      }
        1: 3645:      out_length >>= 3;
        1: 3646:      if (last_dist < last_lit / 2U) {
    #####: 3647:        if (out_length < in_length / 2UL) {
    #####: 3648:          return (1);
        -: 3649:        }
    #####: 3650:      }
        1: 3651:    }
     7401: 3652:  }
     7401: 3653:  if (last_lit == 32767U) {
    #####: 3654:    tmp___3 = 1;
    #####: 3655:  } else { //Added block
     7401: 3656:  if (last_dist == 32768U) {
    #####: 3657:    tmp___3 = 1;
    #####: 3658:  } else {
     7401: 3659:    tmp___3 = 0;
        -: 3660:  }
        -: 3661:  }
     7401: 3662:  return (tmp___3);
        -: 3663:}
     7401: 3664:}
        1: 3665:static void compress_block(ct_data *ltree , ct_data *dtree ) 
        -: 3666:{ 
        -: 3667:  unsigned int dist ;
        -: 3668:  int lc ;
        -: 3669:  unsigned int lx ;
        -: 3670:  unsigned int dx ;
        -: 3671:  unsigned int fx ;
        -: 3672:  uch flag ;
        -: 3673:  unsigned int code ;
        -: 3674:  int extra ;
        -: 3675:  unsigned int tmp ;
        -: 3676:  unsigned int tmp___0 ;
        -: 3677:  unsigned int tmp___1 ;
        -: 3678:
        -: 3679:  {
        1: 3680:  lx = 0U;
        1: 3681:  dx = 0U;
        1: 3682:  fx = 0U;
        1: 3683:  flag = (uch )0;
        1: 3684:  if (last_lit != 0U) {
        -: 3685:    {
     7401: 3686:    while (1) {
        -: 3687:      while_continue: /* CIL Label */ ;
     7401: 3688:      if ((lx & 7U) == 0U) {
      926: 3689:        tmp = fx;
      926: 3690:        fx ++;
      926: 3691:        flag = flag_buf[tmp];
      926: 3692:      }
     7401: 3693:      tmp___0 = lx;
     7401: 3694:      lx ++;
     7401: 3695:      lc = (int )inbuf[tmp___0];
     7401: 3696:      if (((int )flag & 1) == 0) {
        -: 3697:        {
     3235: 3698:        send_bits((int )(ltree + lc)->fc.code, (int )(ltree + lc)->dl.len);
        -: 3699:        }
     3235: 3700:      } else {
        -: 3701:        {
     4166: 3702:        code = (unsigned int )length_code[lc];
     4166: 3703:        send_bits((int )(ltree + ((code + 256U) + 1U))->fc.code, (int )(ltree + ((code + 256U) + 1U))->dl.len);
     4166: 3704:        extra = extra_lbits[code];
        -: 3705:        }
     4166: 3706:        if (extra != 0) {
        -: 3707:          {
      681: 3708:          lc -= base_length[code];
      681: 3709:          send_bits(lc, extra);
        -: 3710:          }
      681: 3711:        }
     4166: 3712:        tmp___1 = dx;
     4166: 3713:        dx ++;
     4166: 3714:        dist = (unsigned int )d_buf[tmp___1];
     4166: 3715:        if (dist < 256U) {
      956: 3716:          code = (unsigned int )dist_code[dist];
      956: 3717:        } else {
     3210: 3718:          code = (unsigned int )dist_code[256U + (dist >> 7)];
        -: 3719:        }
        -: 3720:        {
     4166: 3721:        send_bits((int )(dtree + code)->fc.code, (int )(dtree + code)->dl.len);
     4166: 3722:        extra = extra_dbits[code];
        -: 3723:        }
     4166: 3724:        if (extra != 0) {
        -: 3725:          {
     4150: 3726:          dist -= (unsigned int )base_dist[code];
     4150: 3727:          send_bits((int )dist, extra);
        -: 3728:          }
     4150: 3729:        }
        -: 3730:      }
     7401: 3731:      flag = (uch )((int )flag >> 1);
     7401: 3732:      if (! (lx < last_lit)) {
        1: 3733:        goto while_break;
        -: 3734:      }
        -: 3735:    }
        -: 3736:    while_break: /* CIL Label */ ;
        -: 3737:    }
        1: 3738:  }
        -: 3739:  {
        1: 3740:  send_bits((int )(ltree + 256)->fc.code, (int )(ltree + 256)->dl.len);
        -: 3741:  }
        1: 3742:  return;
        -: 3743:}
        -: 3744:}
    #####: 3745:static void set_file_type(void) 
        -: 3746:{ 
        -: 3747:  int n ;
        -: 3748:  unsigned int ascii_freq ;
        -: 3749:  unsigned int bin_freq ;
        -: 3750:  int tmp ;
        -: 3751:  int tmp___0 ;
        -: 3752:  int tmp___1 ;
        -: 3753:
        -: 3754:  {
    #####: 3755:  n = 0;
    #####: 3756:  ascii_freq = 0U;
    #####: 3757:  bin_freq = 0U;
        -: 3758:  {
    #####: 3759:  while (1) {
        -: 3760:    while_continue: /* CIL Label */ ;
    #####: 3761:    if (! (n < 7)) {
    #####: 3762:      goto while_break;
        -: 3763:    }
    #####: 3764:    tmp = n;
    #####: 3765:    n ++;
    #####: 3766:    bin_freq += (unsigned int )dyn_ltree[tmp].fc.freq;
        -: 3767:  }
        -: 3768:  while_break: /* CIL Label */ ;
        -: 3769:  }
        -: 3770:  {
    #####: 3771:  while (1) {
        -: 3772:    while_continue___0: /* CIL Label */ ;
    #####: 3773:    if (! (n < 128)) {
    #####: 3774:      goto while_break___0;
        -: 3775:    }
    #####: 3776:    tmp___0 = n;
    #####: 3777:    n ++;
    #####: 3778:    ascii_freq += (unsigned int )dyn_ltree[tmp___0].fc.freq;
        -: 3779:  }
        -: 3780:  while_break___0: /* CIL Label */ ;
        -: 3781:  }
        -: 3782:  {
    #####: 3783:  while (1) {
        -: 3784:    while_continue___1: /* CIL Label */ ;
    #####: 3785:    if (! (n < 256)) {
    #####: 3786:      goto while_break___1;
        -: 3787:    }
    #####: 3788:    tmp___1 = n;
    #####: 3789:    n ++;
    #####: 3790:    bin_freq += (unsigned int )dyn_ltree[tmp___1].fc.freq;
        -: 3791:  }
        -: 3792:  while_break___1: /* CIL Label */ ;
        -: 3793:  }
    #####: 3794:  if (bin_freq > ascii_freq >> 2) {
    #####: 3795:    *file_type = (ush )0;
    #####: 3796:  } else {
    #####: 3797:    *file_type = (ush )1;
        -: 3798:  }
    #####: 3799:  return;
        -: 3800:}
        -: 3801:}
        -: 3802:static unsigned int decode(unsigned int count , uch *buffer ) ;
        -: 3803:static void decode_start(void) ;
        -: 3804:static void huf_decode_start(void) ;
        -: 3805:static unsigned int decode_c(void) ;
        -: 3806:static unsigned int decode_p(void) ;
        -: 3807:static void read_pt_len(int nn , int nbit , int i_special ) ;
        -: 3808:static void read_c_len(void) ;
        -: 3809:static void fillbuf(int n ) ;
        -: 3810:static unsigned int getbits(int n ) ;
        -: 3811:static void init_getbits(void) ;
        -: 3812:static void make_table(int nchar , uch *bitlen , int tablebits , ush *table ) ;
        -: 3813:static uch pt_len[19]  ;
        -: 3814:static unsigned int blocksize  ;
        -: 3815:static ush pt_table[256]  ;
        -: 3816:static ush bitbuf  ;
        -: 3817:static unsigned int subbitbuf  ;
        -: 3818:static int bitcount  ;
    #####: 3819:static void fillbuf(int n ) 
        -: 3820:{ 
        -: 3821:  unsigned int tmp ;
        -: 3822:  int tmp___0 ;
        -: 3823:  int tmp___1 ;
        -: 3824:
        -: 3825:  {
    #####: 3826:  bitbuf = (ush )((int )bitbuf << n);
        -: 3827:  {
    #####: 3828:  while (1) {
        -: 3829:    while_continue: /* CIL Label */ ;
    #####: 3830:    if (! (n > bitcount)) {
    #####: 3831:      goto while_break;
        -: 3832:    }
    #####: 3833:    n -= bitcount;
    #####: 3834:    bitbuf = (ush )((unsigned int )bitbuf | (subbitbuf << n));
    #####: 3835:    if (inptr < insize) {
    #####: 3836:      tmp = inptr;
    #####: 3837:      inptr ++;
    #####: 3838:      tmp___1 = (int )inbuf[tmp];
    #####: 3839:    } else {
        -: 3840:      {
    #####: 3841:      tmp___0 = fill_inbuf(1);
    #####: 3842:      tmp___1 = tmp___0;
        -: 3843:      }
        -: 3844:    }
    #####: 3845:    subbitbuf = (unsigned int )tmp___1;
    #####: 3846:    if ((int )subbitbuf == -1) {
    #####: 3847:      subbitbuf = 0U;
    #####: 3848:    }
    #####: 3849:    bitcount = 8;
        -: 3850:  }
        -: 3851:  while_break: /* CIL Label */ ;
        -: 3852:  }
    #####: 3853:  bitcount -= n;
    #####: 3854:  bitbuf = (ush )((unsigned int )bitbuf | (subbitbuf >> bitcount));
    #####: 3855:  return;
        -: 3856:}
        -: 3857:}
    #####: 3858:static unsigned int getbits(int n ) 
        -: 3859:{ 
        -: 3860:  unsigned int x ;
        -: 3861:
        -: 3862:  {
        -: 3863:  {
    #####: 3864:  x = (unsigned int )((int )bitbuf >> (16UL * sizeof(char ) - (unsigned long )n));
    #####: 3865:  fillbuf(n);
        -: 3866:  }
    #####: 3867:  return (x);
        -: 3868:}
        -: 3869:}
    #####: 3870:static void init_getbits(void) 
        -: 3871:{ 
        -: 3872:
        -: 3873:
        -: 3874:  {
        -: 3875:  {
    #####: 3876:  bitbuf = (ush )0;
    #####: 3877:  subbitbuf = 0U;
    #####: 3878:  bitcount = 0;
    #####: 3879:  fillbuf((int )(16UL * sizeof(char )));
        -: 3880:  }
    #####: 3881:  return;
        -: 3882:}
        -: 3883:}
    #####: 3884:static void make_table(int nchar , uch *bitlen , int tablebits , ush *table ) 
        -: 3885:{ 
        -: 3886:  ush count[17] ;
        -: 3887:  ush weight[17] ;
        -: 3888:  ush start[18] ;
        -: 3889:  ush *p ;
        -: 3890:  unsigned int i___0 ;
        -: 3891:  unsigned int k ;
        -: 3892:  unsigned int len ;
        -: 3893:  unsigned int ch ;
        -: 3894:  unsigned int jutbits ;
        -: 3895:  unsigned int avail ;
        -: 3896:  unsigned int nextcode ;
        -: 3897:  unsigned int mask ;
        -: 3898:  unsigned int tmp ;
        -: 3899:  ush tmp___0 ;
        -: 3900:  unsigned int tmp___1 ;
        -: 3901:
        -: 3902:  {
    #####: 3903:  i___0 = 1U;
        -: 3904:  {
    #####: 3905:  while (1) {
        -: 3906:    while_continue: /* CIL Label */ ;
    #####: 3907:    if (! (i___0 <= 16U)) {
    #####: 3908:      goto while_break;
        -: 3909:    }
    #####: 3910:    count[i___0] = (ush )0;
    #####: 3911:    i___0 ++;
        -: 3912:  }
        -: 3913:  while_break: /* CIL Label */ ;
        -: 3914:  }
    #####: 3915:  i___0 = 0U;
        -: 3916:  {
    #####: 3917:  while (1) {
        -: 3918:    while_continue___0: /* CIL Label */ ;
    #####: 3919:    if (! (i___0 < (unsigned int )nchar)) {
    #####: 3920:      goto while_break___0;
        -: 3921:    }
    #####: 3922:    count[*(bitlen + i___0)] = (ush )((int )count[*(bitlen + i___0)] + 1);
    #####: 3923:    i___0 ++;
        -: 3924:  }
        -: 3925:  while_break___0: /* CIL Label */ ;
        -: 3926:  }
    #####: 3927:  start[1] = (ush )0;
    #####: 3928:  i___0 = 1U;
        -: 3929:  {
    #####: 3930:  while (1) {
        -: 3931:    while_continue___1: /* CIL Label */ ;
    #####: 3932:    if (! (i___0 <= 16U)) {
    #####: 3933:      goto while_break___1;
        -: 3934:    }
    #####: 3935:    start[i___0 + 1U] = (ush )((int )start[i___0] + ((int )count[i___0] << (16U - i___0)));
    #####: 3936:    i___0 ++;
        -: 3937:  }
        -: 3938:  while_break___1: /* CIL Label */ ;
        -: 3939:  }
    #####: 3940:  if (((int )start[17] & 65535) != 0) {
        -: 3941:    {
    #####: 3942:    error((char *)"Bad table\n");
        -: 3943:    }
    #####: 3944:  }
    #####: 3945:  jutbits = (unsigned int )(16 - tablebits);
    #####: 3946:  i___0 = 1U;
        -: 3947:  {
    #####: 3948:  while (1) {
        -: 3949:    while_continue___2: /* CIL Label */ ;
    #####: 3950:    if (! (i___0 <= (unsigned int )tablebits)) {
    #####: 3951:      goto while_break___2;
        -: 3952:    }
    #####: 3953:    start[i___0] = (ush )((int )start[i___0] >> jutbits);
    #####: 3954:    weight[i___0] = (ush )(1U << ((unsigned int )tablebits - i___0));
    #####: 3955:    i___0 ++;
        -: 3956:  }
        -: 3957:  while_break___2: /* CIL Label */ ;
        -: 3958:  }
        -: 3959:  {
    #####: 3960:  while (1) {
        -: 3961:    while_continue___3: /* CIL Label */ ;
    #####: 3962:    if (! (i___0 <= 16U)) {
    #####: 3963:      goto while_break___3;
        -: 3964:    }
    #####: 3965:    weight[i___0] = (ush )(1U << (16U - i___0));
    #####: 3966:    i___0 ++;
        -: 3967:  }
        -: 3968:  while_break___3: /* CIL Label */ ;
        -: 3969:  }
    #####: 3970:  i___0 = (unsigned int )((int )start[tablebits + 1] >> jutbits);
    #####: 3971:  if (i___0 != 0U) {
    #####: 3972:    k = (unsigned int )(1 << tablebits);
        -: 3973:    {
    #####: 3974:    while (1) {
        -: 3975:      while_continue___4: /* CIL Label */ ;
    #####: 3976:      if (! (i___0 != k)) {
    #####: 3977:        goto while_break___4;
        -: 3978:      }
    #####: 3979:      tmp = i___0;
    #####: 3980:      i___0 ++;
    #####: 3981:      *(table + tmp) = (ush )0;
        -: 3982:    }
        -: 3983:    while_break___4: /* CIL Label */ ;
        -: 3984:    }
    #####: 3985:  }
    #####: 3986:  avail = (unsigned int )nchar;
    #####: 3987:  mask = 1U << (15 - tablebits);
    #####: 3988:  ch = 0U;
        -: 3989:  {
    #####: 3990:  while (1) {
        -: 3991:    while_continue___5: /* CIL Label */ ;
    #####: 3992:    if (! (ch < (unsigned int )nchar)) {
    #####: 3993:      goto while_break___5;
        -: 3994:    }
    #####: 3995:    len = (unsigned int )*(bitlen + ch);
    #####: 3996:    if (len == 0U) {
    #####: 3997:      goto __Cont;
        -: 3998:    }
    #####: 3999:    nextcode = (unsigned int )((int )start[len] + (int )weight[len]);
    #####: 4000:    if (len <= (unsigned int )tablebits) {
    #####: 4001:      i___0 = (unsigned int )start[len];
        -: 4002:      {
    #####: 4003:      while (1) {
        -: 4004:        while_continue___6: /* CIL Label */ ;
    #####: 4005:        if (! (i___0 < nextcode)) {
    #####: 4006:          goto while_break___6;
        -: 4007:        }
    #####: 4008:        *(table + i___0) = (ush )ch;
    #####: 4009:        i___0 ++;
        -: 4010:      }
        -: 4011:      while_break___6: /* CIL Label */ ;
        -: 4012:      }
    #####: 4013:    } else {
    #####: 4014:      k = (unsigned int )start[len];
    #####: 4015:      p = table + (k >> jutbits);
    #####: 4016:      i___0 = len - (unsigned int )tablebits;
        -: 4017:      {
    #####: 4018:      while (1) {
        -: 4019:        while_continue___7: /* CIL Label */ ;
    #####: 4020:        if (! (i___0 != 0U)) {
    #####: 4021:          goto while_break___7;
        -: 4022:        }
    #####: 4023:        if ((int )*p == 0) {
    #####: 4024:          tmp___0 = (ush )0;
    #####: 4025:          prev[avail] = tmp___0;
    #####: 4026:          *((prev + 32768) + avail) = tmp___0;
    #####: 4027:          tmp___1 = avail;
    #####: 4028:          avail ++;
    #####: 4029:          *p = (ush )tmp___1;
    #####: 4030:        }
    #####: 4031:        if (k & mask) {
    #####: 4032:          p = (prev + 32768) + (int )*p;
    #####: 4033:        } else {
    #####: 4034:          p = & prev[*p];
        -: 4035:        }
    #####: 4036:        k <<= 1;
    #####: 4037:        i___0 --;
        -: 4038:      }
        -: 4039:      while_break___7: /* CIL Label */ ;
        -: 4040:      }
    #####: 4041:      *p = (ush )ch;
        -: 4042:    }
    #####: 4043:    start[len] = (ush )nextcode;
        -: 4044:    __Cont: 
    #####: 4045:    ch ++;
        -: 4046:  }
        -: 4047:  while_break___5: /* CIL Label */ ;
        -: 4048:  }
    #####: 4049:  return;
        -: 4050:}
        -: 4051:}
    #####: 4052:static void read_pt_len(int nn , int nbit , int i_special ) 
        -: 4053:{ 
        -: 4054:  int i___0 ;
        -: 4055:  int c ;
        -: 4056:  int n ;
        -: 4057:  unsigned int mask ;
        -: 4058:  unsigned int tmp ;
        -: 4059:  unsigned int tmp___0 ;
        -: 4060:  int tmp___1 ;
        -: 4061:  int tmp___2 ;
        -: 4062:  unsigned int tmp___3 ;
        -: 4063:  int tmp___4 ;
        -: 4064:  int tmp___5 ;
        -: 4065:
        -: 4066:  {
        -: 4067:  {
    #####: 4068:  tmp = getbits(nbit);
    #####: 4069:  n = (int )tmp;
        -: 4070:  }
    #####: 4071:  if (n == 0) {
        -: 4072:    {
    #####: 4073:    tmp___0 = getbits(nbit);
    #####: 4074:    c = (int )tmp___0;
    #####: 4075:    i___0 = 0;
        -: 4076:    }
        -: 4077:    {
    #####: 4078:    while (1) {
        -: 4079:      while_continue: /* CIL Label */ ;
    #####: 4080:      if (! (i___0 < nn)) {
    #####: 4081:        goto while_break;
        -: 4082:      }
    #####: 4083:      pt_len[i___0] = (uch )0;
    #####: 4084:      i___0 ++;
        -: 4085:    }
        -: 4086:    while_break: /* CIL Label */ ;
        -: 4087:    }
    #####: 4088:    i___0 = 0;
        -: 4089:    {
    #####: 4090:    while (1) {
        -: 4091:      while_continue___0: /* CIL Label */ ;
    #####: 4092:      if (! (i___0 < 256)) {
    #####: 4093:        goto while_break___0;
        -: 4094:      }
    #####: 4095:      pt_table[i___0] = (ush )c;
    #####: 4096:      i___0 ++;
        -: 4097:    }
        -: 4098:    while_break___0: /* CIL Label */ ;
        -: 4099:    }
    #####: 4100:  } else {
    #####: 4101:    i___0 = 0;
        -: 4102:    {
    #####: 4103:    while (1) {
        -: 4104:      while_continue___1: /* CIL Label */ ;
    #####: 4105:      if (! (i___0 < n)) {
    #####: 4106:        goto while_break___1;
        -: 4107:      }
    #####: 4108:      c = (int )bitbuf >> (16UL * sizeof(char ) - 3UL);
    #####: 4109:      if (c == 7) {
    #####: 4110:        mask = 1U << ((16UL * sizeof(char ) - 1UL) - 3UL);
        -: 4111:        {
    #####: 4112:        while (1) {
        -: 4113:          while_continue___2: /* CIL Label */ ;
    #####: 4114:          if (! (mask & (unsigned int )bitbuf)) {
    #####: 4115:            goto while_break___2;
        -: 4116:          }
    #####: 4117:          mask >>= 1;
    #####: 4118:          c ++;
        -: 4119:        }
        -: 4120:        while_break___2: /* CIL Label */ ;
        -: 4121:        }
    #####: 4122:      }
    #####: 4123:      if (c < 7) {
    #####: 4124:        tmp___1 = 3;
    #####: 4125:      } else {
    #####: 4126:        tmp___1 = c - 3;
        -: 4127:      }
        -: 4128:      {
    #####: 4129:      fillbuf(tmp___1);
    #####: 4130:      tmp___2 = i___0;
    #####: 4131:      i___0 ++;
    #####: 4132:      pt_len[tmp___2] = (uch )c;
        -: 4133:      }
    #####: 4134:      if (i___0 == i_special) {
        -: 4135:        {
    #####: 4136:        tmp___3 = getbits(2);
    #####: 4137:        c = (int )tmp___3;
        -: 4138:        }
        -: 4139:        {
    #####: 4140:        while (1) {
        -: 4141:          while_continue___3: /* CIL Label */ ;
    #####: 4142:          c --;
    #####: 4143:          if (! (c >= 0)) {
    #####: 4144:            goto while_break___3;
        -: 4145:          }
    #####: 4146:          tmp___4 = i___0;
    #####: 4147:          i___0 ++;
    #####: 4148:          pt_len[tmp___4] = (uch )0;
        -: 4149:        }
        -: 4150:        while_break___3: /* CIL Label */ ;
        -: 4151:        }
    #####: 4152:      }
        -: 4153:    }
        -: 4154:    while_break___1: /* CIL Label */ ;
        -: 4155:    }
        -: 4156:    {
    #####: 4157:    while (1) {
        -: 4158:      while_continue___4: /* CIL Label */ ;
    #####: 4159:      if (! (i___0 < nn)) {
    #####: 4160:        goto while_break___4;
        -: 4161:      }
    #####: 4162:      tmp___5 = i___0;
    #####: 4163:      i___0 ++;
    #####: 4164:      pt_len[tmp___5] = (uch )0;
        -: 4165:    }
        -: 4166:    while_break___4: /* CIL Label */ ;
        -: 4167:    }
        -: 4168:    {
    #####: 4169:    make_table(nn, pt_len, 8, pt_table);
        -: 4170:    }
        -: 4171:  }
    #####: 4172:  return;
        -: 4173:}
        -: 4174:}
    #####: 4175:static void read_c_len(void) 
        -: 4176:{ 
        -: 4177:  int i___0 ;
        -: 4178:  int c ;
        -: 4179:  int n ;
        -: 4180:  unsigned int mask ;
        -: 4181:  unsigned int tmp ;
        -: 4182:  unsigned int tmp___0 ;
        -: 4183:  unsigned int tmp___1 ;
        -: 4184:  unsigned int tmp___2 ;
        -: 4185:  int tmp___3 ;
        -: 4186:  int tmp___4 ;
        -: 4187:  int tmp___5 ;
        -: 4188:
        -: 4189:  {
        -: 4190:  {
    #####: 4191:  tmp = getbits(9);
    #####: 4192:  n = (int )tmp;
        -: 4193:  }
    #####: 4194:  if (n == 0) {
        -: 4195:    {
    #####: 4196:    tmp___0 = getbits(9);
    #####: 4197:    c = (int )tmp___0;
    #####: 4198:    i___0 = 0;
        -: 4199:    }
        -: 4200:    {
    #####: 4201:    while (1) {
        -: 4202:      while_continue: /* CIL Label */ ;
    #####: 4203:      if (! (i___0 < 510)) {
    #####: 4204:        goto while_break;
        -: 4205:      }
    #####: 4206:      outbuf[i___0] = (uch )0;
    #####: 4207:      i___0 ++;
        -: 4208:    }
        -: 4209:    while_break: /* CIL Label */ ;
        -: 4210:    }
    #####: 4211:    i___0 = 0;
        -: 4212:    {
    #####: 4213:    while (1) {
        -: 4214:      while_continue___0: /* CIL Label */ ;
    #####: 4215:      if (! (i___0 < 4096)) {
    #####: 4216:        goto while_break___0;
        -: 4217:      }
    #####: 4218:      d_buf[i___0] = (ush )c;
    #####: 4219:      i___0 ++;
        -: 4220:    }
        -: 4221:    while_break___0: /* CIL Label */ ;
        -: 4222:    }
    #####: 4223:  } else {
    #####: 4224:    i___0 = 0;
        -: 4225:    {
    #####: 4226:    while (1) {
        -: 4227:      while_continue___1: /* CIL Label */ ;
    #####: 4228:      if (! (i___0 < n)) {
    #####: 4229:        goto while_break___1;
        -: 4230:      }
    #####: 4231:      c = (int )pt_table[(int )bitbuf >> (16UL * sizeof(char ) - 8UL)];
    #####: 4232:      if (c >= 19) {
    #####: 4233:        mask = 1U << ((16UL * sizeof(char ) - 1UL) - 8UL);
        -: 4234:        {
    #####: 4235:        while (1) {
        -: 4236:          while_continue___2: /* CIL Label */ ;
    #####: 4237:          if ((unsigned int )bitbuf & mask) {
    #####: 4238:            c = (int )*((prev + 32768) + c);
    #####: 4239:          } else {
    #####: 4240:            c = (int )prev[c];
        -: 4241:          }
    #####: 4242:          mask >>= 1;
    #####: 4243:          if (! (c >= 19)) {
    #####: 4244:            goto while_break___2;
        -: 4245:          }
        -: 4246:        }
        -: 4247:        while_break___2: /* CIL Label */ ;
        -: 4248:        }
    #####: 4249:      }
        -: 4250:      {
    #####: 4251:      fillbuf((int )pt_len[c]);
        -: 4252:      }
    #####: 4253:      if (c <= 2) {
    #####: 4254:        if (c == 0) {
    #####: 4255:          c = 1;
    #####: 4256:        } else { //Added block
    #####: 4257:        if (c == 1) {
        -: 4258:          {
    #####: 4259:          tmp___1 = getbits(4);
    #####: 4260:          c = (int )(tmp___1 + 3U);
        -: 4261:          }
    #####: 4262:        } else {
        -: 4263:          {
    #####: 4264:          tmp___2 = getbits(9);
    #####: 4265:          c = (int )(tmp___2 + 20U);
        -: 4266:          }
        -: 4267:        }
        -: 4268:        }
        -: 4269:        {
    #####: 4270:        while (1) {
        -: 4271:          while_continue___3: /* CIL Label */ ;
    #####: 4272:          c --;
    #####: 4273:          if (! (c >= 0)) {
    #####: 4274:            goto while_break___3;
        -: 4275:          }
    #####: 4276:          tmp___3 = i___0;
    #####: 4277:          i___0 ++;
    #####: 4278:          outbuf[tmp___3] = (uch )0;
        -: 4279:        }
        -: 4280:        while_break___3: /* CIL Label */ ;
        -: 4281:        }
    #####: 4282:      } else {
    #####: 4283:        tmp___4 = i___0;
    #####: 4284:        i___0 ++;
    #####: 4285:        outbuf[tmp___4] = (uch )(c - 2);
        -: 4286:      }
        -: 4287:    }
        -: 4288:    while_break___1: /* CIL Label */ ;
        -: 4289:    }
        -: 4290:    {
    #####: 4291:    while (1) {
        -: 4292:      while_continue___4: /* CIL Label */ ;
    #####: 4293:      if (! (i___0 < 510)) {
    #####: 4294:        goto while_break___4;
        -: 4295:      }
    #####: 4296:      tmp___5 = i___0;
    #####: 4297:      i___0 ++;
    #####: 4298:      outbuf[tmp___5] = (uch )0;
        -: 4299:    }
        -: 4300:    while_break___4: /* CIL Label */ ;
        -: 4301:    }
        -: 4302:    {
    #####: 4303:    make_table(510, outbuf, 12, d_buf);
        -: 4304:    }
        -: 4305:  }
    #####: 4306:  return;
        -: 4307:}
        -: 4308:}
    #####: 4309:static unsigned int decode_c(void) 
        -: 4310:{ 
        -: 4311:  unsigned int j___0 ;
        -: 4312:  unsigned int mask ;
        -: 4313:
        -: 4314:  {
    #####: 4315:  if (blocksize == 0U) {
        -: 4316:    {
    #####: 4317:    blocksize = getbits(16);
        -: 4318:    }
    #####: 4319:    if (blocksize == 0U) {
    #####: 4320:      return (510U);
        -: 4321:    }
        -: 4322:    {
    #####: 4323:    read_pt_len(19, 5, 3);
    #####: 4324:    read_c_len();
    #####: 4325:    read_pt_len(14, 4, -1);
        -: 4326:    }
    #####: 4327:  }
    #####: 4328:  blocksize --;
    #####: 4329:  j___0 = (unsigned int )d_buf[(int )bitbuf >> (16UL * sizeof(char ) - 12UL)];
    #####: 4330:  if (j___0 >= 510U) {
    #####: 4331:    mask = 1U << ((16UL * sizeof(char ) - 1UL) - 12UL);
        -: 4332:    {
    #####: 4333:    while (1) {
        -: 4334:      while_continue: /* CIL Label */ ;
    #####: 4335:      if ((unsigned int )bitbuf & mask) {
    #####: 4336:        j___0 = (unsigned int )*((prev + 32768) + j___0);
    #####: 4337:      } else {
    #####: 4338:        j___0 = (unsigned int )prev[j___0];
        -: 4339:      }
    #####: 4340:      mask >>= 1;
    #####: 4341:      if (! (j___0 >= 510U)) {
    #####: 4342:        goto while_break;
        -: 4343:      }
        -: 4344:    }
        -: 4345:    while_break: /* CIL Label */ ;
        -: 4346:    }
    #####: 4347:  }
        -: 4348:  {
    #####: 4349:  fillbuf((int )outbuf[j___0]);
        -: 4350:  }
    #####: 4351:  return (j___0);
        -: 4352:}
    #####: 4353:}
    #####: 4354:static unsigned int decode_p(void) 
        -: 4355:{ 
        -: 4356:  unsigned int j___0 ;
        -: 4357:  unsigned int mask ;
        -: 4358:  unsigned int tmp ;
        -: 4359:
        -: 4360:  {
    #####: 4361:  j___0 = (unsigned int )pt_table[(int )bitbuf >> (16UL * sizeof(char ) - 8UL)];
    #####: 4362:  if (j___0 >= 14U) {
    #####: 4363:    mask = 1U << ((16UL * sizeof(char ) - 1UL) - 8UL);
        -: 4364:    {
    #####: 4365:    while (1) {
        -: 4366:      while_continue: /* CIL Label */ ;
    #####: 4367:      if ((unsigned int )bitbuf & mask) {
    #####: 4368:        j___0 = (unsigned int )*((prev + 32768) + j___0);
    #####: 4369:      } else {
    #####: 4370:        j___0 = (unsigned int )prev[j___0];
        -: 4371:      }
    #####: 4372:      mask >>= 1;
    #####: 4373:      if (! (j___0 >= 14U)) {
    #####: 4374:        goto while_break;
        -: 4375:      }
        -: 4376:    }
        -: 4377:    while_break: /* CIL Label */ ;
        -: 4378:    }
    #####: 4379:  }
        -: 4380:  {
    #####: 4381:  fillbuf((int )pt_len[j___0]);
        -: 4382:  }
    #####: 4383:  if (j___0 != 0U) {
        -: 4384:    {
    #####: 4385:    tmp = getbits((int )(j___0 - 1U));
    #####: 4386:    j___0 = (1U << (j___0 - 1U)) + tmp;
        -: 4387:    }
    #####: 4388:  }
    #####: 4389:  return (j___0);
        -: 4390:}
        -: 4391:}
    #####: 4392:static void huf_decode_start(void) 
        -: 4393:{ 
        -: 4394:
        -: 4395:
        -: 4396:  {
        -: 4397:  {
    #####: 4398:  init_getbits();
    #####: 4399:  blocksize = 0U;
        -: 4400:  }
    #####: 4401:  return;
        -: 4402:}
        -: 4403:}
        -: 4404:static int j  ;
        -: 4405:static int done  ;
    #####: 4406:static void decode_start(void) 
        -: 4407:{ 
        -: 4408:
        -: 4409:
        -: 4410:  {
        -: 4411:  {
    #####: 4412:  huf_decode_start();
    #####: 4413:  j = 0;
    #####: 4414:  done = 0;
        -: 4415:  }
    #####: 4416:  return;
        -: 4417:}
        -: 4418:}
        -: 4419:static unsigned int i  ;
    #####: 4420:static unsigned int decode(unsigned int count , uch *buffer ) 
        -: 4421:{ 
        -: 4422:  unsigned int r ;
        -: 4423:  unsigned int c ;
        -: 4424:  unsigned int tmp ;
        -: 4425:
        -: 4426:  {
    #####: 4427:  r = 0U;
        -: 4428:  {
    #####: 4429:  while (1) {
        -: 4430:    while_continue: /* CIL Label */ ;
    #####: 4431:    j --;
    #####: 4432:    if (! (j >= 0)) {
    #####: 4433:      goto while_break;
        -: 4434:    }
    #####: 4435:    *(buffer + r) = *(buffer + i);
    #####: 4436:    i = (i + 1U) & ((1U << 13) - 1U);
    #####: 4437:    r ++;
    #####: 4438:    if (r == count) {
    #####: 4439:      return (r);
        -: 4440:    }
        -: 4441:  }
        -: 4442:  while_break: /* CIL Label */ ;
        -: 4443:  }
        -: 4444:  {
    #####: 4445:  while (1) {
        -: 4446:    while_continue___0: /* CIL Label */ ;
        -: 4447:    {
    #####: 4448:    c = decode_c();
        -: 4449:    }
    #####: 4450:    if (c == 510U) {
    #####: 4451:      done = 1;
    #####: 4452:      return (r);
        -: 4453:    }
    #####: 4454:    if (c <= 255U) {
    #####: 4455:      *(buffer + r) = (uch )c;
    #####: 4456:      r ++;
    #####: 4457:      if (r == count) {
    #####: 4458:        return (r);
        -: 4459:      }
    #####: 4460:    } else {
        -: 4461:      {
    #####: 4462:      j = (int )(c - 253U);
    #####: 4463:      tmp = decode_p();
    #####: 4464:      i = ((r - tmp) - 1U) & ((1U << 13) - 1U);
        -: 4465:      }
        -: 4466:      {
    #####: 4467:      while (1) {
        -: 4468:        while_continue___1: /* CIL Label */ ;
    #####: 4469:        j --;
    #####: 4470:        if (! (j >= 0)) {
    #####: 4471:          goto while_break___1;
        -: 4472:        }
    #####: 4473:        *(buffer + r) = *(buffer + i);
    #####: 4474:        i = (i + 1U) & ((1U << 13) - 1U);
    #####: 4475:        r ++;
    #####: 4476:        if (r == count) {
    #####: 4477:          return (r);
        -: 4478:        }
        -: 4479:      }
        -: 4480:      while_break___1: /* CIL Label */ ;
        -: 4481:      }
        -: 4482:    }
        -: 4483:  }
        -: 4484:  while_break___0: /* CIL Label */ ;
        -: 4485:  }
        -: 4486:}
    #####: 4487:}
    #####: 4488:int unlzh(int in , int out ) 
        -: 4489:{ 
        -: 4490:  unsigned int n ;
        -: 4491:
        -: 4492:  {
        -: 4493:  {
    #####: 4494:  ifd = in;
    #####: 4495:  ofd = out;
    #####: 4496:  decode_start();
        -: 4497:  }
        -: 4498:  {
    #####: 4499:  while (1) {
        -: 4500:    while_continue: /* CIL Label */ ;
    #####: 4501:    if (! (! done)) {
    #####: 4502:      goto while_break;
        -: 4503:    }
        -: 4504:    {
    #####: 4505:    n = decode(1U << 13, window);
        -: 4506:    }
    #####: 4507:    if (! test) {
    #####: 4508:      if (n > 0U) {
        -: 4509:        {
    #####: 4510:        write_buf(out, (voidp )((char *)(window)), n);
        -: 4511:        }
    #####: 4512:      }
    #####: 4513:    }
        -: 4514:  }
        -: 4515:  while_break: /* CIL Label */ ;
        -: 4516:  }
    #####: 4517:  return (0);
        -: 4518:}
        -: 4519:}
        -: 4520:extern  __attribute__((__nothrow__)) __off_t ( __attribute__((__leaf__)) lseek)(int __fd ,
        -: 4521:                                                                                __off_t __offset ,
        -: 4522:                                                                                int __whence ) ;
        -: 4523:extern int close(int __fd ) ;
        -: 4524:extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
        -: 4525:extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
        -: 4526:extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) chown)(char const   *__file ,
        -: 4527:                                                                                            __uid_t __owner ,
        -: 4528:                                                                                            __gid_t __group ) ;
        -: 4529:extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) isatty)(int __fd ) ;
        -: 4530:extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) unlink)(char const   *__name ) ;
        -: 4531:extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
        -: 4532:                                                   , ...) ;
        -: 4533:int block_mode  =    128;
    #####: 4534:int unlzw(int in , int out ) 
        -: 4535:{ 
        -: 4536:  register char_type *stackp ;
        -: 4537:  code_int code ;
        -: 4538:  int finchar ;
        -: 4539:  code_int oldcode ;
        -: 4540:  code_int incode ;
        -: 4541:  long inbits ;
        -: 4542:  long posbits ;
        -: 4543:  int outpos ;
        -: 4544:  unsigned int bitmask ;
        -: 4545:  code_int free_ent ;
        -: 4546:  code_int maxcode ;
        -: 4547:  code_int maxmaxcode ;
        -: 4548:  int n_bits ;
        -: 4549:  int rsize ;
        -: 4550:  unsigned int tmp ;
        -: 4551:  int tmp___0 ;
        -: 4552:  register int i___0 ;
        -: 4553:  int e ;
        -: 4554:  int o ;
        -: 4555:  ssize_t tmp___1 ;
        -: 4556:  register char_type *p ;
        -: 4557:  int tmp___2 ;
        -: 4558:  char const   *tmp___3 ;
        -: 4559:  register int i___1 ;
        -: 4560:
        -: 4561:  {
    #####: 4562:  if (inptr < insize) {
    #####: 4563:    tmp = inptr;
    #####: 4564:    inptr ++;
    #####: 4565:    maxbits = (int )inbuf[tmp];
    #####: 4566:  } else {
        -: 4567:    {
    #####: 4568:    tmp___0 = fill_inbuf(0);
    #####: 4569:    maxbits = tmp___0;
        -: 4570:    }
        -: 4571:  }
    #####: 4572:  block_mode = maxbits & 128;
    #####: 4573:  if ((maxbits & 96) != 0) {
    #####: 4574:    if (! quiet) {
        -: 4575:      {
    #####: 4576:      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\n%s: %s: warning, unknown flags 0x%x\n",
    #####: 4577:              progname, ifname, maxbits & 96);
        -: 4578:      }
    #####: 4579:    }
    #####: 4580:    if (exit_code == 0) {
    #####: 4581:      exit_code = 2;
    #####: 4582:    }
    #####: 4583:  }
    #####: 4584:  maxbits &= 31;
    #####: 4585:  maxmaxcode = 1L << maxbits;
    #####: 4586:  if (maxbits > 16) {
        -: 4587:    {
    #####: 4588:    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\n%s: %s: compressed with %d bits, can only handle %d bits\n",
    #####: 4589:            progname, ifname, maxbits, 16);
    #####: 4590:    exit_code = 1;
        -: 4591:    }
    #####: 4592:    return (1);
        -: 4593:  }
    #####: 4594:  rsize = (int )insize;
    #####: 4595:  n_bits = 9;
    #####: 4596:  maxcode = (1L << n_bits) - 1L;
    #####: 4597:  bitmask = (unsigned int )((1 << n_bits) - 1);
    #####: 4598:  oldcode = (code_int )-1;
    #####: 4599:  finchar = 0;
    #####: 4600:  outpos = 0;
    #####: 4601:  posbits = (long )(inptr << 3);
    #####: 4602:  if (block_mode) {
    #####: 4603:    free_ent = (code_int )257;
    #####: 4604:  } else {
    #####: 4605:    free_ent = (code_int )256;
        -: 4606:  }
        -: 4607:  {
    #####: 4608:  memset((voidp )(prev), 0, (size_t )256);
    #####: 4609:  code = (code_int )255;
        -: 4610:  }
        -: 4611:  {
    #####: 4612:  while (1) {
        -: 4613:    while_continue: /* CIL Label */ ;
    #####: 4614:    if (! (code >= 0L)) {
    #####: 4615:      goto while_break;
        -: 4616:    }
    #####: 4617:    window[code] = (char_type )code;
    #####: 4618:    code --;
        -: 4619:  }
        -: 4620:  while_break: /* CIL Label */ ;
        -: 4621:  }
        -: 4622:  {
    #####: 4623:  while (1) {
        -: 4624:    while_continue___0: /* CIL Label */ ;
        -: 4625:    resetbuf: 
    #####: 4626:    o = (int )(posbits >> 3);
    #####: 4627:    e = (int )(insize - (unsigned int )o);
    #####: 4628:    i___0 = 0;
        -: 4629:    {
    #####: 4630:    while (1) {
        -: 4631:      while_continue___1: /* CIL Label */ ;
    #####: 4632:      if (! (i___0 < e)) {
    #####: 4633:        goto while_break___1;
        -: 4634:      }
    #####: 4635:      inbuf[i___0] = inbuf[i___0 + o];
    #####: 4636:      i___0 ++;
        -: 4637:    }
        -: 4638:    while_break___1: /* CIL Label */ ;
        -: 4639:    }
    #####: 4640:    insize = (unsigned int )e;
    #####: 4641:    posbits = 0L;
    #####: 4642:    if (insize < 64U) {
        -: 4643:      {
    #####: 4644:      tmp___1 = read(in, (void *)((char *)(inbuf) + insize), (size_t )32768);
    #####: 4645:      rsize = (int )tmp___1;
        -: 4646:      }
    #####: 4647:      if (rsize == -1) {
        -: 4648:        {
    #####: 4649:        read_error();
        -: 4650:        }
    #####: 4651:      }
    #####: 4652:      insize += (unsigned int )rsize;
    #####: 4653:      bytes_in += (off_t )rsize;
    #####: 4654:    }
    #####: 4655:    if (rsize != 0) {
    #####: 4656:      inbits = ((long )insize - (long )(insize % (unsigned int )n_bits)) << 3;
    #####: 4657:    } else {
    #####: 4658:      inbits = ((long )insize << 3) - (long )(n_bits - 1);
        -: 4659:    }
        -: 4660:    {
    #####: 4661:    while (1) {
        -: 4662:      while_continue___2: /* CIL Label */ ;
    #####: 4663:      if (! (inbits > posbits)) {
    #####: 4664:        goto while_break___2;
        -: 4665:      }
    #####: 4666:      if (free_ent > maxcode) {
    #####: 4667:        posbits = (posbits - 1L) + ((long )(n_bits << 3) - ((posbits - 1L) + (long )(n_bits << 3)) % (long )(n_bits << 3));
    #####: 4668:        n_bits ++;
    #####: 4669:        if (n_bits == maxbits) {
    #####: 4670:          maxcode = maxmaxcode;
    #####: 4671:        } else {
    #####: 4672:          maxcode = (1L << n_bits) - 1L;
        -: 4673:        }
    #####: 4674:        bitmask = (unsigned int )((1 << n_bits) - 1);
    #####: 4675:        goto resetbuf;
        -: 4676:      }
    #####: 4677:      p = & inbuf[posbits >> 3];
    #####: 4678:      code = ((((long )*(p + 0) | ((long )*(p + 1) << 8)) | ((long )*(p + 2) << 16)) >> (posbits & 7L)) & (long )bitmask;
    #####: 4679:      posbits += (long )n_bits;
    #####: 4680:      if (oldcode == -1L) {
    #####: 4681:        if (code >= 256L) {
        -: 4682:          {
    #####: 4683:          error((char *)"corrupt input.");
        -: 4684:          }
    #####: 4685:        }
    #####: 4686:        tmp___2 = outpos;
    #####: 4687:        outpos ++;
    #####: 4688:        oldcode = code;
    #####: 4689:        finchar = (int )oldcode;
    #####: 4690:        outbuf[tmp___2] = (char_type )finchar;
    #####: 4691:        goto while_continue___2;
        -: 4692:      }
    #####: 4693:      if (code == 256L) {
    #####: 4694:        if (block_mode) {
        -: 4695:          {
    #####: 4696:          memset((voidp )(prev), 0, (size_t )256);
    #####: 4697:          free_ent = (code_int )256;
    #####: 4698:          posbits = (posbits - 1L) + ((long )(n_bits << 3) - ((posbits - 1L) + (long )(n_bits << 3)) % (long )(n_bits << 3));
    #####: 4699:          n_bits = 9;
    #####: 4700:          maxcode = (1L << n_bits) - 1L;
    #####: 4701:          bitmask = (unsigned int )((1 << n_bits) - 1);
        -: 4702:          }
    #####: 4703:          goto resetbuf;
        -: 4704:        }
    #####: 4705:      }
    #####: 4706:      incode = code;
    #####: 4707:      stackp = (char_type *)(& d_buf[32767]);
    #####: 4708:      if (code >= free_ent) {
    #####: 4709:        if (code > free_ent) {
    #####: 4710:          if (! test) {
    #####: 4711:            if (outpos > 0) {
        -: 4712:              {
    #####: 4713:              write_buf(out, (voidp )((char *)(outbuf)), (unsigned int )outpos);
    #####: 4714:              bytes_out += (off_t )outpos;
        -: 4715:              }
    #####: 4716:            }
    #####: 4717:          }
    #####: 4718:          if (to_stdout) {
    #####: 4719:            tmp___3 = "corrupt input.";
    #####: 4720:          } else {
    #####: 4721:            tmp___3 = "corrupt input. Use zcat to recover some data.";
        -: 4722:          }
        -: 4723:          {
    #####: 4724:          error((char *)tmp___3);
        -: 4725:          }
    #####: 4726:        }
    #####: 4727:        stackp --;
    #####: 4728:        *stackp = (char_type )finchar;
    #####: 4729:        code = oldcode;
    #####: 4730:      }
        -: 4731:      {
    #####: 4732:      while (1) {
        -: 4733:        while_continue___3: /* CIL Label */ ;
    #####: 4734:        if (! ((cmp_code_int )code >= 256UL)) {
    #####: 4735:          goto while_break___3;
        -: 4736:        }
    #####: 4737:        stackp --;
    #####: 4738:        *stackp = window[code];
    #####: 4739:        code = (code_int )prev[code];
        -: 4740:      }
        -: 4741:      while_break___3: /* CIL Label */ ;
        -: 4742:      }
    #####: 4743:      stackp --;
    #####: 4744:      finchar = (int )window[code];
    #####: 4745:      *stackp = (char_type )finchar;
    #####: 4746:      i___1 = (int )((char_type *)(& d_buf[32767]) - stackp);
    #####: 4747:      if (outpos + i___1 >= 16384) {
        -: 4748:        {
    #####: 4749:        while (1) {
        -: 4750:          while_continue___4: /* CIL Label */ ;
    #####: 4751:          if (i___1 > 16384 - outpos) {
    #####: 4752:            i___1 = 16384 - outpos;
    #####: 4753:          }
    #####: 4754:          if (i___1 > 0) {
        -: 4755:            {
    #####: 4756:            memcpy((void * __restrict  )(outbuf + outpos), (void const   * __restrict  )stackp,
    #####: 4757:                   (size_t )i___1);
    #####: 4758:            outpos += i___1;
        -: 4759:            }
    #####: 4760:          }
    #####: 4761:          if (outpos >= 16384) {
    #####: 4762:            if (! test) {
        -: 4763:              {
    #####: 4764:              write_buf(out, (voidp )((char *)(outbuf)), (unsigned int )outpos);
    #####: 4765:              bytes_out += (off_t )outpos;
        -: 4766:              }
    #####: 4767:            }
    #####: 4768:            outpos = 0;
    #####: 4769:          }
    #####: 4770:          stackp += i___1;
    #####: 4771:          i___1 = (int )((char_type *)(& d_buf[32767]) - stackp);
    #####: 4772:          if (! (i___1 > 0)) {
    #####: 4773:            goto while_break___4;
        -: 4774:          }
        -: 4775:        }
        -: 4776:        while_break___4: /* CIL Label */ ;
        -: 4777:        }
    #####: 4778:      } else {
        -: 4779:        {
    #####: 4780:        memcpy((void * __restrict  )(outbuf + outpos), (void const   * __restrict  )stackp,
    #####: 4781:               (size_t )i___1);
    #####: 4782:        outpos += i___1;
        -: 4783:        }
        -: 4784:      }
    #####: 4785:      code = free_ent;
    #####: 4786:      if (code < maxmaxcode) {
    #####: 4787:        prev[code] = (unsigned short )oldcode;
    #####: 4788:        window[code] = (char_type )finchar;
    #####: 4789:        free_ent = code + 1L;
    #####: 4790:      }
    #####: 4791:      oldcode = incode;
        -: 4792:    }
        -: 4793:    while_break___2: /* CIL Label */ ;
        -: 4794:    }
    #####: 4795:    if (! (rsize != 0)) {
    #####: 4796:      goto while_break___0;
        -: 4797:    }
        -: 4798:  }
        -: 4799:  while_break___0: /* CIL Label */ ;
        -: 4800:  }
    #####: 4801:  if (! test) {
    #####: 4802:    if (outpos > 0) {
        -: 4803:      {
    #####: 4804:      write_buf(out, (voidp )((char *)(outbuf)), (unsigned int )outpos);
    #####: 4805:      bytes_out += (off_t )outpos;
        -: 4806:      }
    #####: 4807:    }
    #####: 4808:  }
    #####: 4809:  return (0);
        -: 4810:}
    #####: 4811:}
        -: 4812:static ulg orig_len  ;
        -: 4813:static int max_len  ;
        -: 4814:static uch literal[256]  ;
        -: 4815:static int lit_base[26]  ;
        -: 4816:static int leaves[26]  ;
        -: 4817:static int parents[26]  ;
        -: 4818:static int peek_bits  ;
        -: 4819:static ulg un_bitbuf  ;
        -: 4820:static int valid  ;
        -: 4821:static void read_tree(void) ;
        -: 4822:static void un_build_tree(void) ;
    #####: 4823:static void read_tree(void) 
        -: 4824:{ 
        -: 4825:  int len ;
        -: 4826:  int base ;
        -: 4827:  int n ;
        -: 4828:  unsigned int tmp ;
        -: 4829:  int tmp___0 ;
        -: 4830:  int tmp___1 ;
        -: 4831:  unsigned int tmp___2 ;
        -: 4832:  int tmp___3 ;
        -: 4833:  int tmp___4 ;
        -: 4834:  unsigned int tmp___5 ;
        -: 4835:  int tmp___6 ;
        -: 4836:  int tmp___7 ;
        -: 4837:  int tmp___8 ;
        -: 4838:  unsigned int tmp___9 ;
        -: 4839:  int tmp___10 ;
        -: 4840:  int tmp___11 ;
        -: 4841:
        -: 4842:  {
    #####: 4843:  orig_len = (ulg )0;
    #####: 4844:  n = 1;
        -: 4845:  {
    #####: 4846:  while (1) {
        -: 4847:    while_continue: /* CIL Label */ ;
    #####: 4848:    if (! (n <= 4)) {
    #####: 4849:      goto while_break;
        -: 4850:    }
    #####: 4851:    if (inptr < insize) {
    #####: 4852:      tmp = inptr;
    #####: 4853:      inptr ++;
    #####: 4854:      tmp___1 = (int )inbuf[tmp];
    #####: 4855:    } else {
        -: 4856:      {
    #####: 4857:      tmp___0 = fill_inbuf(0);
    #####: 4858:      tmp___1 = tmp___0;
        -: 4859:      }
        -: 4860:    }
    #####: 4861:    orig_len = (orig_len << 8) | (ulg )tmp___1;
    #####: 4862:    n ++;
        -: 4863:  }
        -: 4864:  while_break: /* CIL Label */ ;
        -: 4865:  }
    #####: 4866:  if (inptr < insize) {
    #####: 4867:    tmp___2 = inptr;
    #####: 4868:    inptr ++;
    #####: 4869:    tmp___4 = (int )inbuf[tmp___2];
    #####: 4870:  } else {
        -: 4871:    {
    #####: 4872:    tmp___3 = fill_inbuf(0);
    #####: 4873:    tmp___4 = tmp___3;
        -: 4874:    }
        -: 4875:  }
    #####: 4876:  max_len = tmp___4;
    #####: 4877:  if (max_len > 25) {
        -: 4878:    {
    #####: 4879:    error((char *)"invalid compressed data -- Huffman code > 32 bits");
        -: 4880:    }
    #####: 4881:  }
    #####: 4882:  n = 0;
    #####: 4883:  len = 1;
        -: 4884:  {
    #####: 4885:  while (1) {
        -: 4886:    while_continue___0: /* CIL Label */ ;
    #####: 4887:    if (! (len <= max_len)) {
    #####: 4888:      goto while_break___0;
        -: 4889:    }
    #####: 4890:    if (inptr < insize) {
    #####: 4891:      tmp___5 = inptr;
    #####: 4892:      inptr ++;
    #####: 4893:      tmp___7 = (int )inbuf[tmp___5];
    #####: 4894:    } else {
        -: 4895:      {
    #####: 4896:      tmp___6 = fill_inbuf(0);
    #####: 4897:      tmp___7 = tmp___6;
        -: 4898:      }
        -: 4899:    }
    #####: 4900:    leaves[len] = tmp___7;
    #####: 4901:    n += leaves[len];
    #####: 4902:    len ++;
        -: 4903:  }
        -: 4904:  while_break___0: /* CIL Label */ ;
        -: 4905:  }
    #####: 4906:  if (n > 256) {
        -: 4907:    {
    #####: 4908:    error((char *)"too many leaves in Huffman tree");
        -: 4909:    }
    #####: 4910:  }
    #####: 4911:  (leaves[max_len]) ++;
    #####: 4912:  base = 0;
    #####: 4913:  len = 1;
        -: 4914:  {
    #####: 4915:  while (1) {
        -: 4916:    while_continue___1: /* CIL Label */ ;
    #####: 4917:    if (! (len <= max_len)) {
    #####: 4918:      goto while_break___1;
        -: 4919:    }
    #####: 4920:    lit_base[len] = base;
    #####: 4921:    n = leaves[len];
        -: 4922:    {
    #####: 4923:    while (1) {
        -: 4924:      while_continue___2: /* CIL Label */ ;
    #####: 4925:      if (! (n > 0)) {
    #####: 4926:        goto while_break___2;
        -: 4927:      }
    #####: 4928:      tmp___8 = base;
    #####: 4929:      base ++;
    #####: 4930:      if (inptr < insize) {
    #####: 4931:        tmp___9 = inptr;
    #####: 4932:        inptr ++;
    #####: 4933:        tmp___11 = (int )inbuf[tmp___9];
    #####: 4934:      } else {
        -: 4935:        {
    #####: 4936:        tmp___10 = fill_inbuf(0);
    #####: 4937:        tmp___11 = tmp___10;
        -: 4938:        }
        -: 4939:      }
    #####: 4940:      literal[tmp___8] = (uch )tmp___11;
    #####: 4941:      n --;
        -: 4942:    }
        -: 4943:    while_break___2: /* CIL Label */ ;
        -: 4944:    }
    #####: 4945:    len ++;
        -: 4946:  }
        -: 4947:  while_break___1: /* CIL Label */ ;
        -: 4948:  }
    #####: 4949:  (leaves[max_len]) ++;
    #####: 4950:  return;
        -: 4951:}
        -: 4952:}
    #####: 4953:static void un_build_tree(void) 
        -: 4954:{ 
        -: 4955:  int nodes ;
        -: 4956:  int len ;
        -: 4957:  uch *prefixp ;
        -: 4958:  int prefixes ;
        -: 4959:  int tmp ;
        -: 4960:
        -: 4961:  {
    #####: 4962:  nodes = 0;
    #####: 4963:  len = max_len;
        -: 4964:  {
    #####: 4965:  while (1) {
        -: 4966:    while_continue: /* CIL Label */ ;
    #####: 4967:    if (! (len >= 1)) {
    #####: 4968:      goto while_break;
        -: 4969:    }
    #####: 4970:    nodes >>= 1;
    #####: 4971:    parents[len] = nodes;
    #####: 4972:    lit_base[len] -= nodes;
    #####: 4973:    nodes += leaves[len];
    #####: 4974:    len --;
        -: 4975:  }
        -: 4976:  while_break: /* CIL Label */ ;
        -: 4977:  }
    #####: 4978:  if (max_len <= 12) {
    #####: 4979:    peek_bits = max_len;
    #####: 4980:  } else {
    #####: 4981:    peek_bits = 12;
        -: 4982:  }
    #####: 4983:  prefixp = & outbuf[1 << peek_bits];
    #####: 4984:  len = 1;
        -: 4985:  {
    #####: 4986:  while (1) {
        -: 4987:    while_continue___0: /* CIL Label */ ;
    #####: 4988:    if (! (len <= peek_bits)) {
    #####: 4989:      goto while_break___0;
        -: 4990:    }
    #####: 4991:    prefixes = leaves[len] << (peek_bits - len);
        -: 4992:    {
    #####: 4993:    while (1) {
        -: 4994:      while_continue___1: /* CIL Label */ ;
    #####: 4995:      tmp = prefixes;
    #####: 4996:      prefixes --;
    #####: 4997:      if (! tmp) {
    #####: 4998:        goto while_break___1;
        -: 4999:      }
    #####: 5000:      prefixp --;
    #####: 5001:      *prefixp = (uch )len;
        -: 5002:    }
        -: 5003:    while_break___1: /* CIL Label */ ;
        -: 5004:    }
    #####: 5005:    len ++;
        -: 5006:  }
        -: 5007:  while_break___0: /* CIL Label */ ;
        -: 5008:  }
        -: 5009:  {
    #####: 5010:  while (1) {
        -: 5011:    while_continue___2: /* CIL Label */ ;
    #####: 5012:    if (! ((unsigned long )prefixp > (unsigned long )(outbuf))) {
    #####: 5013:      goto while_break___2;
        -: 5014:    }
    #####: 5015:    prefixp --;
    #####: 5016:    *prefixp = (uch )0;
        -: 5017:  }
        -: 5018:  while_break___2: /* CIL Label */ ;
        -: 5019:  }
    #####: 5020:  return;
        -: 5021:}
        -: 5022:}
    #####: 5023:int unpack(int in , int out ) 
        -: 5024:{ 
        -: 5025:  int len ;
        -: 5026:  unsigned int eob ;
        -: 5027:  register unsigned int peek ;
        -: 5028:  unsigned int peek_mask ;
        -: 5029:  unsigned int tmp ;
        -: 5030:  int tmp___0 ;
        -: 5031:  int tmp___1 ;
        -: 5032:  ulg mask ;
        -: 5033:  unsigned int tmp___2 ;
        -: 5034:  int tmp___3 ;
        -: 5035:  int tmp___4 ;
        -: 5036:  unsigned int tmp___5 ;
        -: 5037:
        -: 5038:  {
        -: 5039:  {
    #####: 5040:  ifd = in;
    #####: 5041:  ofd = out;
    #####: 5042:  read_tree();
    #####: 5043:  un_build_tree();
    #####: 5044:  valid = 0;
    #####: 5045:  un_bitbuf = (ulg )0;
    #####: 5046:  peek_mask = (unsigned int )((1 << peek_bits) - 1);
    #####: 5047:  eob = (unsigned int )(leaves[max_len] - 1);
        -: 5048:  }
        -: 5049:  {
    #####: 5050:  while (1) {
        -: 5051:    while_continue: /* CIL Label */ ;
        -: 5052:    {
    #####: 5053:    while (1) {
        -: 5054:      while_continue___0: /* CIL Label */ ;
    #####: 5055:      if (! (valid < peek_bits)) {
    #####: 5056:        goto while_break___0;
        -: 5057:      }
    #####: 5058:      if (inptr < insize) {
    #####: 5059:        tmp = inptr;
    #####: 5060:        inptr ++;
    #####: 5061:        tmp___1 = (int )inbuf[tmp];
    #####: 5062:      } else {
        -: 5063:        {
    #####: 5064:        tmp___0 = fill_inbuf(0);
    #####: 5065:        tmp___1 = tmp___0;
        -: 5066:        }
        -: 5067:      }
    #####: 5068:      un_bitbuf = (un_bitbuf << 8) | (ulg )tmp___1;
    #####: 5069:      valid += 8;
        -: 5070:    }
        -: 5071:    while_break___0: /* CIL Label */ ;
        -: 5072:    }
    #####: 5073:    peek = (unsigned int )((un_bitbuf >> (valid - peek_bits)) & (unsigned long )peek_mask);
    #####: 5074:    len = (int )outbuf[peek];
    #####: 5075:    if (len > 0) {
    #####: 5076:      peek >>= peek_bits - len;
    #####: 5077:    } else {
    #####: 5078:      mask = (ulg )peek_mask;
    #####: 5079:      len = peek_bits;
        -: 5080:      {
    #####: 5081:      while (1) {
        -: 5082:        while_continue___1: /* CIL Label */ ;
    #####: 5083:        len ++;
    #####: 5084:        mask = (mask << 1) + 1UL;
        -: 5085:        {
    #####: 5086:        while (1) {
        -: 5087:          while_continue___2: /* CIL Label */ ;
    #####: 5088:          if (! (valid < len)) {
    #####: 5089:            goto while_break___2;
        -: 5090:          }
    #####: 5091:          if (inptr < insize) {
    #####: 5092:            tmp___2 = inptr;
    #####: 5093:            inptr ++;
    #####: 5094:            tmp___4 = (int )inbuf[tmp___2];
    #####: 5095:          } else {
        -: 5096:            {
    #####: 5097:            tmp___3 = fill_inbuf(0);
    #####: 5098:            tmp___4 = tmp___3;
        -: 5099:            }
        -: 5100:          }
    #####: 5101:          un_bitbuf = (un_bitbuf << 8) | (ulg )tmp___4;
    #####: 5102:          valid += 8;
        -: 5103:        }
        -: 5104:        while_break___2: /* CIL Label */ ;
        -: 5105:        }
    #####: 5106:        peek = (unsigned int )((un_bitbuf >> (valid - len)) & mask);
    #####: 5107:        if (! (peek < (unsigned int )parents[len])) {
    #####: 5108:          goto while_break___1;
        -: 5109:        }
        -: 5110:      }
        -: 5111:      while_break___1: /* CIL Label */ ;
        -: 5112:      }
        -: 5113:    }
    #####: 5114:    if (peek == eob) {
    #####: 5115:      if (len == max_len) {
    #####: 5116:        goto while_break;
        -: 5117:      }
    #####: 5118:    }
    #####: 5119:    tmp___5 = outcnt;
    #####: 5120:    outcnt ++;
    #####: 5121:    window[tmp___5] = literal[peek + (unsigned int )lit_base[len]];
    #####: 5122:    if (outcnt == 32768U) {
        -: 5123:      {
    #####: 5124:      flush_window();
        -: 5125:      }
    #####: 5126:    }
    #####: 5127:    valid -= len;
        -: 5128:  }
        -: 5129:  while_break: /* CIL Label */ ;
        -: 5130:  }
        -: 5131:  {
    #####: 5132:  flush_window();
        -: 5133:  }
    #####: 5134:  if (orig_len != (ulg )(bytes_out & 4294967295L)) {
        -: 5135:    {
    #####: 5136:    error((char *)"invalid compressed data--length error");
        -: 5137:    }
    #####: 5138:  }
    #####: 5139:  return (0);
        -: 5140:}
        -: 5141:}
        -: 5142:char *key  ;
        -: 5143:int pkzip  =    0;
        -: 5144:int ext_header  =    0;
    #####: 5145:int check_zipfile(int in ) 
        -: 5146:{ 
        -: 5147:  uch *h ;
        -: 5148:
        -: 5149:  {
    #####: 5150:  h = inbuf + inptr;
    #####: 5151:  ifd = in;
    #####: 5152:  inptr += (unsigned int )((30 + ((int )((ush )*((h + 26) + 0)) | ((int )((ush )*((h + 26) + 1)) << 8))) + ((int )((ush )*((h + 28) + 0)) | ((int )((ush )*((h + 28) + 1)) << 8)));
    #####: 5153:  if (inptr > insize) {
        -: 5154:    {
    #####: 5155:    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\n%s: %s: not a valid zip file\n",
    #####: 5156:            progname, ifname);
    #####: 5157:    exit_code = 1;
        -: 5158:    }
    #####: 5159:    return (1);
        -: 5160:  } else { //Added block
    #####: 5161:  if (((ulg )((int )((ush )*(h + 0)) | ((int )((ush )*(h + 1)) << 8)) | ((ulg )((int )((ush )*((h + 2) + 0)) | ((int )((ush )*((h + 2) + 1)) << 8)) << 16)) != 67324752UL) {
        -: 5162:    {
    #####: 5163:    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\n%s: %s: not a valid zip file\n",
    #####: 5164:            progname, ifname);
    #####: 5165:    exit_code = 1;
        -: 5166:    }
    #####: 5167:    return (1);
        -: 5168:  }
        -: 5169:  }
    #####: 5170:  method = (int )*(h + 8);
    #####: 5171:  if (method != 0) {
    #####: 5172:    if (method != 8) {
        -: 5173:      {
    #####: 5174:      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\n%s: %s: first entry not deflated or stored -- use unzip\n",
    #####: 5175:              progname, ifname);
    #####: 5176:      exit_code = 1;
        -: 5177:      }
    #####: 5178:      return (1);
        -: 5179:    }
    #####: 5180:  }
    #####: 5181:  decrypt = (int )*(h + 6) & 1;
    #####: 5182:  if (decrypt != 0) {
        -: 5183:    {
    #####: 5184:    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\n%s: %s: encrypted file -- use unzip\n",
    #####: 5185:            progname, ifname);
    #####: 5186:    exit_code = 1;
        -: 5187:    }
    #####: 5188:    return (1);
        -: 5189:  }
    #####: 5190:  ext_header = ((int )*(h + 6) & 8) != 0;
    #####: 5191:  pkzip = 1;
    #####: 5192:  return (0);
        -: 5193:}
    #####: 5194:}
    #####: 5195:int unzip(int in , int out ) 
        -: 5196:{ 
        -: 5197:  ulg orig_crc ;
        -: 5198:  ulg orig_len___0 ;
        -: 5199:  int n ;
        -: 5200:  uch buf[16] ;
        -: 5201:  int err ;
        -: 5202:  int res ;
        -: 5203:  int tmp ;
        -: 5204:  register ulg n___0 ;
        -: 5205:  int tmp___0 ;
        -: 5206:  uch c ;
        -: 5207:  unsigned int tmp___1 ;
        -: 5208:  int tmp___2 ;
        -: 5209:  int tmp___3 ;
        -: 5210:  unsigned int tmp___4 ;
        -: 5211:  ulg tmp___5 ;
        -: 5212:  unsigned int tmp___6 ;
        -: 5213:  int tmp___7 ;
        -: 5214:  int tmp___8 ;
        -: 5215:  unsigned int tmp___9 ;
        -: 5216:  int tmp___10 ;
        -: 5217:  int tmp___11 ;
        -: 5218:  ulg tmp___12 ;
        -: 5219:
        -: 5220:  {
        -: 5221:  {
    #####: 5222:  orig_crc = (ulg )0;
    #####: 5223:  orig_len___0 = (ulg )0;
    #####: 5224:  err = 0;
    #####: 5225:  ifd = in;
    #####: 5226:  ofd = out;
    #####: 5227:  updcrc((uch *)((void *)0), 0U);
        -: 5228:  }
    #####: 5229:  if (pkzip) {
    #####: 5230:    if (! ext_header) {
    #####: 5231:      orig_crc = (ulg )((int )((ush )*((inbuf + 14) + 0)) | ((int )((ush )*((inbuf + 14) + 1)) << 8)) | ((ulg )((int )((ush )*(((inbuf + 14) + 2) + 0)) | ((int )((ush )*(((inbuf + 14) + 2) + 1)) << 8)) << 16);
    #####: 5232:      orig_len___0 = (ulg )((int )((ush )*((inbuf + 22) + 0)) | ((int )((ush )*((inbuf + 22) + 1)) << 8)) | ((ulg )((int )((ush )*(((inbuf + 22) + 2) + 0)) | ((int )((ush )*(((inbuf + 22) + 2) + 1)) << 8)) << 16);
    #####: 5233:    }
    #####: 5234:  }
    #####: 5235:  if (method == 8) {
        -: 5236:    {
    #####: 5237:    tmp = inflate();
    #####: 5238:    res = tmp;
        -: 5239:    }
    #####: 5240:    if (res == 3) {
        -: 5241:      {
    #####: 5242:      error((char *)"out of memory");
        -: 5243:      }
    #####: 5244:    } else { //Added block
    #####: 5245:    if (res != 0) {
        -: 5246:      {
    #####: 5247:      error((char *)"invalid compressed data--format violated");
        -: 5248:      }
    #####: 5249:    }
        -: 5250:    }
    #####: 5251:  } else { //Added block
    #####: 5252:  if (pkzip) {
    #####: 5253:    if (method == 0) {
    #####: 5254:      n___0 = (ulg )((int )((ush )*((inbuf + 22) + 0)) | ((int )((ush )*((inbuf + 22) + 1)) << 8)) | ((ulg )((int )((ush )*(((inbuf + 22) + 2) + 0)) | ((int )((ush )*(((inbuf + 22) + 2) + 1)) << 8)) << 16);
    #####: 5255:      if (decrypt) {
    #####: 5256:        tmp___0 = 12;
    #####: 5257:      } else {
    #####: 5258:        tmp___0 = 0;
        -: 5259:      }
    #####: 5260:      if (n___0 != ((ulg )((int )((ush )*((inbuf + 18) + 0)) | ((int )((ush )*((inbuf + 18) + 1)) << 8)) | ((ulg )((int )((ush )*(((inbuf + 18) + 2) + 0)) | ((int )((ush )*(((inbuf + 18) + 2) + 1)) << 8)) << 16)) - (unsigned long )tmp___0) {
        -: 5261:        {
    #####: 5262:        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"len %ld, siz %ld\n",
    #####: 5263:                n___0, (ulg )((int )((ush )*((inbuf + 18) + 0)) | ((int )((ush )*((inbuf + 18) + 1)) << 8)) | ((ulg )((int )((ush )*(((inbuf + 18) + 2) + 0)) | ((int )((ush )*(((inbuf + 18) + 2) + 1)) << 8)) << 16));
    #####: 5264:        error((char *)"invalid compressed data--length mismatch");
        -: 5265:        }
    #####: 5266:      }
        -: 5267:      {
    #####: 5268:      while (1) {
        -: 5269:        while_continue: /* CIL Label */ ;
    #####: 5270:        tmp___5 = n___0;
    #####: 5271:        n___0 --;
    #####: 5272:        if (! tmp___5) {
    #####: 5273:          goto while_break;
        -: 5274:        }
    #####: 5275:        if (inptr < insize) {
    #####: 5276:          tmp___1 = inptr;
    #####: 5277:          inptr ++;
    #####: 5278:          tmp___3 = (int )inbuf[tmp___1];
    #####: 5279:        } else {
        -: 5280:          {
    #####: 5281:          tmp___2 = fill_inbuf(0);
    #####: 5282:          tmp___3 = tmp___2;
        -: 5283:          }
        -: 5284:        }
    #####: 5285:        c = (uch )tmp___3;
    #####: 5286:        tmp___4 = outcnt;
    #####: 5287:        outcnt ++;
    #####: 5288:        window[tmp___4] = c;
    #####: 5289:        if (outcnt == 32768U) {
        -: 5290:          {
    #####: 5291:          flush_window();
        -: 5292:          }
    #####: 5293:        }
        -: 5294:      }
        -: 5295:      while_break: /* CIL Label */ ;
        -: 5296:      }
        -: 5297:      {
    #####: 5298:      flush_window();
        -: 5299:      }
    #####: 5300:    } else {
        -: 5301:      {
    #####: 5302:      error((char *)"internal error, invalid method");
        -: 5303:      }
        -: 5304:    }
    #####: 5305:  } else {
        -: 5306:    {
    #####: 5307:    error((char *)"internal error, invalid method");
        -: 5308:    }
        -: 5309:  }
        -: 5310:  }
    #####: 5311:  if (! pkzip) {
    #####: 5312:    n = 0;
        -: 5313:    {
    #####: 5314:    while (1) {
        -: 5315:      while_continue___0: /* CIL Label */ ;
    #####: 5316:      if (! (n < 8)) {
    #####: 5317:        goto while_break___0;
        -: 5318:      }
    #####: 5319:      if (inptr < insize) {
    #####: 5320:        tmp___6 = inptr;
    #####: 5321:        inptr ++;
    #####: 5322:        tmp___8 = (int )inbuf[tmp___6];
    #####: 5323:      } else {
        -: 5324:        {
    #####: 5325:        tmp___7 = fill_inbuf(0);
    #####: 5326:        tmp___8 = tmp___7;
        -: 5327:        }
        -: 5328:      }
    #####: 5329:      buf[n] = (uch )tmp___8;
    #####: 5330:      n ++;
        -: 5331:    }
        -: 5332:    while_break___0: /* CIL Label */ ;
        -: 5333:    }
    #####: 5334:    orig_crc = (ulg )((int )((ush )buf[0]) | ((int )((ush )buf[1]) << 8)) | ((ulg )((int )((ush )*((buf + 2) + 0)) | ((int )((ush )*((buf + 2) + 1)) << 8)) << 16);
    #####: 5335:    orig_len___0 = (ulg )((int )((ush )*((buf + 4) + 0)) | ((int )((ush )*((buf + 4) + 1)) << 8)) | ((ulg )((int )((ush )*(((buf + 4) + 2) + 0)) | ((int )((ush )*(((buf + 4) + 2) + 1)) << 8)) << 16);
    #####: 5336:  } else { //Added block
    #####: 5337:  if (ext_header) {
    #####: 5338:    n = 0;
        -: 5339:    {
    #####: 5340:    while (1) {
        -: 5341:      while_continue___1: /* CIL Label */ ;
    #####: 5342:      if (! (n < 16)) {
    #####: 5343:        goto while_break___1;
        -: 5344:      }
    #####: 5345:      if (inptr < insize) {
    #####: 5346:        tmp___9 = inptr;
    #####: 5347:        inptr ++;
    #####: 5348:        tmp___11 = (int )inbuf[tmp___9];
    #####: 5349:      } else {
        -: 5350:        {
    #####: 5351:        tmp___10 = fill_inbuf(0);
    #####: 5352:        tmp___11 = tmp___10;
        -: 5353:        }
        -: 5354:      }
    #####: 5355:      buf[n] = (uch )tmp___11;
    #####: 5356:      n ++;
        -: 5357:    }
        -: 5358:    while_break___1: /* CIL Label */ ;
        -: 5359:    }
    #####: 5360:    orig_crc = (ulg )((int )((ush )*((buf + 4) + 0)) | ((int )((ush )*((buf + 4) + 1)) << 8)) | ((ulg )((int )((ush )*(((buf + 4) + 2) + 0)) | ((int )((ush )*(((buf + 4) + 2) + 1)) << 8)) << 16);
    #####: 5361:    orig_len___0 = (ulg )((int )((ush )*((buf + 12) + 0)) | ((int )((ush )*((buf + 12) + 1)) << 8)) | ((ulg )((int )((ush )*(((buf + 12) + 2) + 0)) | ((int )((ush )*(((buf + 12) + 2) + 1)) << 8)) << 16);
    #####: 5362:  }
        -: 5363:  }
        -: 5364:  {
    #####: 5365:  tmp___12 = updcrc(outbuf, 0U);
        -: 5366:  }
    #####: 5367:  if (orig_crc != tmp___12) {
        -: 5368:    {
    #####: 5369:    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\n%s: %s: invalid compressed data--crc error\n",
    #####: 5370:            progname, ifname);
    #####: 5371:    err = 1;
        -: 5372:    }
    #####: 5373:  }
    #####: 5374:  if (orig_len___0 != (ulg )(bytes_out & 4294967295L)) {
        -: 5375:    {
    #####: 5376:    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\n%s: %s: invalid compressed data--length error\n",
    #####: 5377:            progname, ifname);
    #####: 5378:    err = 1;
        -: 5379:    }
    #####: 5380:  }
    #####: 5381:  if (pkzip) {
    #####: 5382:    if (inptr + 4U < insize) {
    #####: 5383:      if (((ulg )((int )((ush )*((inbuf + inptr) + 0)) | ((int )((ush )*((inbuf + inptr) + 1)) << 8)) | ((ulg )((int )((ush )*(((inbuf + inptr) + 2) + 0)) | ((int )((ush )*(((inbuf + inptr) + 2) + 1)) << 8)) << 16)) == 67324752UL) {
    #####: 5384:        if (to_stdout) {
    #####: 5385:          if (! quiet) {
        -: 5386:            {
    #####: 5387:            fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: %s has more than one entry--rest ignored\n",
    #####: 5388:                    progname, ifname);
        -: 5389:            }
    #####: 5390:          }
    #####: 5391:          if (exit_code == 0) {
    #####: 5392:            exit_code = 2;
    #####: 5393:          }
    #####: 5394:        } else {
        -: 5395:          {
    #####: 5396:          fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: %s has more than one entry -- unchanged\n",
    #####: 5397:                  progname, ifname);
    #####: 5398:          err = 1;
        -: 5399:          }
        -: 5400:        }
    #####: 5401:      }
    #####: 5402:    }
    #####: 5403:  }
    #####: 5404:  pkzip = 0;
    #####: 5405:  ext_header = pkzip;
    #####: 5406:  if (err == 0) {
    #####: 5407:    return (0);
        -: 5408:  }
    #####: 5409:  exit_code = 1;
    #####: 5410:  if (! test) {
        -: 5411:    {
    #####: 5412:    abort_gzip();
        -: 5413:    }
    #####: 5414:  }
    #####: 5415:  return (err);
        -: 5416:}
    #####: 5417:}
        -: 5418:ulg crc_32_tab[256] ;
    #####: 5419:int copy(int in , int out ) 
        -: 5420:{ 
        -: 5421:  int *tmp ;
        -: 5422:  ssize_t tmp___0 ;
        -: 5423:
        -: 5424:  {
        -: 5425:  {
    #####: 5426:  tmp = __errno_location();
    #####: 5427:  *tmp = 0;
        -: 5428:  }
        -: 5429:  {
    #####: 5430:  while (1) {
        -: 5431:    while_continue: /* CIL Label */ ;
    #####: 5432:    if (insize != 0U) {
    #####: 5433:      if (! ((int )insize != -1)) {
    #####: 5434:        goto while_break;
        -: 5435:      }
    #####: 5436:    } else {
    #####: 5437:      goto while_break;
        -: 5438:    }
        -: 5439:    {
    #####: 5440:    write_buf(out, (voidp )((char *)(inbuf)), insize);
    #####: 5441:    bytes_out += (off_t )insize;
    #####: 5442:    tmp___0 = read(in, (void *)((char *)(inbuf)), (size_t )32768);
    #####: 5443:    insize = (unsigned int )tmp___0;
        -: 5444:    }
        -: 5445:  }
        -: 5446:  while_break: /* CIL Label */ ;
        -: 5447:  }
    #####: 5448:  if ((int )insize == -1) {
        -: 5449:    {
    #####: 5450:    read_error();
        -: 5451:    }
    #####: 5452:  }
    #####: 5453:  bytes_in = bytes_out;
    #####: 5454:  return (0);
        -: 5455:}
        -: 5456:}
        -: 5457:static ulg crc___0  =    (ulg )4294967295L;
        2: 5458:ulg updcrc(uch *s , unsigned int n ) 
        -: 5459:{ 
        -: 5460:  register ulg c ;
        -: 5461:  uch *tmp ;
        -: 5462:
        -: 5463:  {
        2: 5464:  if ((unsigned long )s == (unsigned long )((void *)0)) {
        1: 5465:    c = (ulg )4294967295L;
        1: 5466:  } else {
        1: 5467:    c = crc___0;
        1: 5468:    if (n) {
        -: 5469:      {
    34231: 5470:      while (1) {
        -: 5471:        while_continue: /* CIL Label */ ;
    34231: 5472:        tmp = s;
    34231: 5473:        s ++;
    34231: 5474:        c = crc_32_tab[((int )c ^ (int )*tmp) & 255] ^ (c >> 8);
    34231: 5475:        n --;
    34231: 5476:        if (! n) {
        1: 5477:          goto while_break;
        -: 5478:        }
        -: 5479:      }
        -: 5480:      while_break: /* CIL Label */ ;
        -: 5481:      }
        1: 5482:    }
        -: 5483:  }
        2: 5484:  crc___0 = c;
        2: 5485:  return (c ^ 4294967295UL);
        -: 5486:}
        -: 5487:}
        1: 5488:void clear_bufs(void) 
        -: 5489:{ 
        -: 5490:
        -: 5491:
        -: 5492:  {
        1: 5493:  outcnt = 0U;
        1: 5494:  inptr = 0U;
        1: 5495:  insize = inptr;
        1: 5496:  bytes_out = 0L;
        1: 5497:  bytes_in = bytes_out;
        1: 5498:  return;
        -: 5499:}
        -: 5500:}
    #####: 5501:int fill_inbuf(int eof_ok ) 
        -: 5502:{ 
        -: 5503:  int len ;
        -: 5504:  ssize_t tmp ;
        -: 5505:  int *tmp___0 ;
        -: 5506:
        -: 5507:  {
    #####: 5508:  insize = 0U;
        -: 5509:  {
    #####: 5510:  while (1) {
        -: 5511:    while_continue: /* CIL Label */ ;
        -: 5512:    {
    #####: 5513:    tmp = read(ifd, (void *)((char *)(inbuf) + insize), (size_t )(32768U - insize));
    #####: 5514:    len = (int )tmp;
        -: 5515:    }
    #####: 5516:    if (len == 0) {
    #####: 5517:      goto while_break;
        -: 5518:    }
    #####: 5519:    if (len == -1) {
        -: 5520:      {
    #####: 5521:      read_error();
        -: 5522:      }
    #####: 5523:      goto while_break;
        -: 5524:    }
    #####: 5525:    insize += (unsigned int )len;
    #####: 5526:    if (! (insize < 32768U)) {
    #####: 5527:      goto while_break;
        -: 5528:    }
        -: 5529:  }
        -: 5530:  while_break: /* CIL Label */ ;
        -: 5531:  }
    #####: 5532:  if (insize == 0U) {
    #####: 5533:    if (eof_ok) {
    #####: 5534:      return (-1);
        -: 5535:    }
        -: 5536:    {
    #####: 5537:    flush_window();
    #####: 5538:    tmp___0 = __errno_location();
    #####: 5539:    *tmp___0 = 0;
    #####: 5540:    read_error();
        -: 5541:    }
    #####: 5542:  }
    #####: 5543:  bytes_in += (off_t )insize;
    #####: 5544:  inptr = 1U;
    #####: 5545:  return ((int )inbuf[0]);
        -: 5546:}
    #####: 5547:}
        1: 5548:void flush_outbuf(void) 
        -: 5549:{ 
        -: 5550:
        -: 5551:
        -: 5552:  {
        1: 5553:  if (outcnt == 0U) {
    #####: 5554:    return;
        -: 5555:  }
        -: 5556:  {
        1: 5557:  write_buf(ofd, (voidp )((char *)(outbuf)), outcnt);
        1: 5558:  bytes_out += (off_t )outcnt;
        1: 5559:  outcnt = 0U;
        -: 5560:  }
        1: 5561:  return;
        -: 5562:}
        1: 5563:}
    #####: 5564:void flush_window(void) 
        -: 5565:{ 
        -: 5566:
        -: 5567:
        -: 5568:  {
    #####: 5569:  if (outcnt == 0U) {
    #####: 5570:    return;
        -: 5571:  }
        -: 5572:  {
    #####: 5573:  updcrc(window, outcnt);
        -: 5574:  }
    #####: 5575:  if (! test) {
        -: 5576:    {
    #####: 5577:    write_buf(ofd, (voidp )((char *)(window)), outcnt);
        -: 5578:    }
    #####: 5579:  }
    #####: 5580:  bytes_out += (off_t )outcnt;
    #####: 5581:  outcnt = 0U;
    #####: 5582:  return;
        -: 5583:}
    #####: 5584:}
        1: 5585:void write_buf(int fd , voidp buf , unsigned int cnt ) 
        -: 5586:{ 
        -: 5587:  unsigned int n ;
        -: 5588:  ssize_t tmp ;
        -: 5589:
        -: 5590:  {
        -: 5591:  {
        1: 5592:  while (1) {
        -: 5593:    while_continue: /* CIL Label */ ;
        -: 5594:    {
        1: 5595:    tmp = write(fd, (void const   *)buf, (size_t )cnt);
        1: 5596:    n = (unsigned int )tmp;
        -: 5597:    }
        1: 5598:    if (! (n != cnt)) {
        1: 5599:      goto while_break;
        -: 5600:    }
    #####: 5601:    if (n == 4294967295U) {
        -: 5602:      {
    #####: 5603:      write_error();
        -: 5604:      }
    #####: 5605:    }
    #####: 5606:    cnt -= n;
    #####: 5607:    buf = (voidp )((char *)buf + n);
        -: 5608:  }
        -: 5609:  while_break: /* CIL Label */ ;
        -: 5610:  }
        1: 5611:  return;
        -: 5612:}
        -: 5613:}
    #####: 5614:char *strlwr(char *s ) 
        -: 5615:{ 
        -: 5616:  char *t ;
        -: 5617:  int tmp___0 ;
        -: 5618:  unsigned short const   **tmp___1 ;
        -: 5619:
        -: 5620:  {
    #####: 5621:  t = s;
        -: 5622:  {
    #####: 5623:  while (1) {
        -: 5624:    while_continue: /* CIL Label */ ;
    #####: 5625:    if (! *t) {
    #####: 5626:      goto while_break;
        -: 5627:    }
        -: 5628:    {
    #####: 5629:    tmp___1 = __ctype_b_loc();
        -: 5630:    }
    #####: 5631:    if ((int const   )*(*tmp___1 + (int )((unsigned char )*t)) & 256) {
        -: 5632:      {
    #####: 5633:      tmp___0 = tolower((int )((unsigned char )*t));
    #####: 5634:      *t = (char )tmp___0;
        -: 5635:      }
    #####: 5636:    } else {
    #####: 5637:      *t = (char )((unsigned char )*t);
        -: 5638:    }
    #####: 5639:    t ++;
        -: 5640:  }
        -: 5641:  while_break: /* CIL Label */ ;
        -: 5642:  }
    #####: 5643:  return (s);
        -: 5644:}
        -: 5645:}
        2: 5646:char *base_name(char *fname ) 
        -: 5647:{ 
        -: 5648:  char *p ;
        -: 5649:
        -: 5650:  {
        -: 5651:  {
        2: 5652:  p = strrchr((char const   *)fname, '/');
        -: 5653:  }
        2: 5654:  if ((unsigned long )p != (unsigned long )((void *)0)) {
        2: 5655:    fname = p + 1;
        2: 5656:  }
        2: 5657:  return (fname);
        -: 5658:}
        -: 5659:}
    #####: 5660:int xunlink(char *filename ) 
        -: 5661:{ 
        -: 5662:  int r ;
        -: 5663:  int tmp ;
        -: 5664:
        -: 5665:  {
        -: 5666:  {
    #####: 5667:  tmp = unlink((char const   *)filename);
    #####: 5668:  r = tmp;
        -: 5669:  }
    #####: 5670:  return (r);
        -: 5671:}
        -: 5672:}
    #####: 5673:void make_simple_name(char *name ) 
        -: 5674:{ 
        -: 5675:  char *p ;
        -: 5676:  char *tmp ;
        -: 5677:
        -: 5678:  {
        -: 5679:  {
    #####: 5680:  tmp = strrchr((char const   *)name, '.');
    #####: 5681:  p = tmp;
        -: 5682:  }
    #####: 5683:  if ((unsigned long )p == (unsigned long )((void *)0)) {
    #####: 5684:    return;
        -: 5685:  }
    #####: 5686:  if ((unsigned long )p == (unsigned long )name) {
    #####: 5687:    p ++;
    #####: 5688:  }
        -: 5689:  {
    #####: 5690:  while (1) {
        -: 5691:    while_continue: /* CIL Label */ ;
    #####: 5692:    p --;
    #####: 5693:    if ((int )*p == 46) {
    #####: 5694:      *p = (char )'_';
    #####: 5695:    }
    #####: 5696:    if (! ((unsigned long )p != (unsigned long )name)) {
    #####: 5697:      goto while_break;
        -: 5698:    }
        -: 5699:  }
        -: 5700:  while_break: /* CIL Label */ ;
        -: 5701:  }
    #####: 5702:  return;
        -: 5703:}
    #####: 5704:}
        1: 5705:char *add_envopt(int *argcp , char ***argvp , char *env___0 ) 
        -: 5706:{ 
        -: 5707:  char *p ;
        -: 5708:  char **oargv ;
        -: 5709:  char **nargv ;
        -: 5710:  int oargc ;
        -: 5711:  int nargc ;
        -: 5712:  char *tmp ;
        -: 5713:  size_t tmp___0 ;
        -: 5714:  voidp tmp___1 ;
        -: 5715:  size_t tmp___2 ;
        -: 5716:  size_t tmp___3 ;
        -: 5717:  char *tmp___4 ;
        -: 5718:  void *tmp___5 ;
        -: 5719:  int tmp___6 ;
        -: 5720:  char **tmp___7 ;
        -: 5721:  char **tmp___8 ;
        -: 5722:  size_t tmp___9 ;
        -: 5723:  char **tmp___10 ;
        -: 5724:  char *tmp___11 ;
        -: 5725:  char **tmp___12 ;
        -: 5726:  char **tmp___13 ;
        -: 5727:  int tmp___14 ;
        -: 5728:
        -: 5729:  {
        -: 5730:  {
        1: 5731:  oargc = *argcp;
        1: 5732:  nargc = 0;
        1: 5733:  tmp = getenv((char const   *)env___0);
        1: 5734:  env___0 = tmp;
        -: 5735:  }
        1: 5736:  if ((unsigned long )env___0 == (unsigned long )((void *)0)) {
        1: 5737:    return ((char *)((void *)0));
        -: 5738:  }
        -: 5739:  {
    #####: 5740:  tmp___0 = strlen((char const   *)env___0);
    #####: 5741:  tmp___1 = xmalloc((unsigned int )(tmp___0 + 1UL));
    #####: 5742:  p = (char *)tmp___1;
    #####: 5743:  env___0 = strcpy((char * __restrict  )p, (char const   * __restrict  )env___0);
    #####: 5744:  p = env___0;
        -: 5745:  }
        -: 5746:  {
    #####: 5747:  while (1) {
        -: 5748:    while_continue: /* CIL Label */ ;
    #####: 5749:    if (! *p) {
    #####: 5750:      goto while_break;
        -: 5751:    }
        -: 5752:    {
    #####: 5753:    tmp___2 = strspn((char const   *)p, " \t");
    #####: 5754:    p += tmp___2;
        -: 5755:    }
    #####: 5756:    if ((int )*p == 0) {
    #####: 5757:      goto while_break;
        -: 5758:    }
        -: 5759:    {
    #####: 5760:    tmp___3 = strcspn((char const   *)p, " \t");
    #####: 5761:    p += tmp___3;
        -: 5762:    }
    #####: 5763:    if (*p) {
    #####: 5764:      tmp___4 = p;
    #####: 5765:      p ++;
    #####: 5766:      *tmp___4 = (char )'\000';
    #####: 5767:    }
    #####: 5768:    nargc ++;
        -: 5769:  }
        -: 5770:  while_break: /* CIL Label */ ;
        -: 5771:  }
    #####: 5772:  if (nargc == 0) {
        -: 5773:    {
    #####: 5774:    free((void *)env___0);
        -: 5775:    }
    #####: 5776:    return ((char *)((void *)0));
        -: 5777:  }
        -: 5778:  {
    #####: 5779:  *argcp += nargc;
    #####: 5780:  tmp___5 = calloc((size_t )(*argcp + 1), sizeof(char *));
    #####: 5781:  nargv = (char **)tmp___5;
        -: 5782:  }
    #####: 5783:  if ((unsigned long )nargv == (unsigned long )((void *)0)) {
        -: 5784:    {
    #####: 5785:    error((char *)"out of memory");
        -: 5786:    }
    #####: 5787:  }
    #####: 5788:  oargv = *argvp;
    #####: 5789:  *argvp = nargv;
    #####: 5790:  tmp___6 = oargc;
    #####: 5791:  oargc --;
    #####: 5792:  if (tmp___6 < 0) {
        -: 5793:    {
    #####: 5794:    error((char *)"argc<=0");
        -: 5795:    }
    #####: 5796:  }
    #####: 5797:  tmp___7 = nargv;
    #####: 5798:  nargv ++;
    #####: 5799:  tmp___8 = oargv;
    #####: 5800:  oargv ++;
    #####: 5801:  *tmp___7 = *tmp___8;
    #####: 5802:  p = env___0;
        -: 5803:  {
    #####: 5804:  while (1) {
        -: 5805:    while_continue___0: /* CIL Label */ ;
    #####: 5806:    if (! (nargc > 0)) {
    #####: 5807:      goto while_break___0;
        -: 5808:    }
        -: 5809:    {
    #####: 5810:    tmp___9 = strspn((char const   *)p, " \t");
    #####: 5811:    p += tmp___9;
    #####: 5812:    tmp___10 = nargv;
    #####: 5813:    nargv ++;
    #####: 5814:    *tmp___10 = p;
        -: 5815:    }
        -: 5816:    {
    #####: 5817:    while (1) {
        -: 5818:      while_continue___1: /* CIL Label */ ;
    #####: 5819:      tmp___11 = p;
    #####: 5820:      p ++;
    #####: 5821:      if (! *tmp___11) {
    #####: 5822:        goto while_break___1;
        -: 5823:      }
        -: 5824:    }
        -: 5825:    while_break___1: /* CIL Label */ ;
        -: 5826:    }
    #####: 5827:    nargc --;
        -: 5828:  }
        -: 5829:  while_break___0: /* CIL Label */ ;
        -: 5830:  }
        -: 5831:  {
    #####: 5832:  while (1) {
        -: 5833:    while_continue___2: /* CIL Label */ ;
    #####: 5834:    tmp___14 = oargc;
    #####: 5835:    oargc --;
    #####: 5836:    if (! tmp___14) {
    #####: 5837:      goto while_break___2;
        -: 5838:    }
    #####: 5839:    tmp___12 = nargv;
    #####: 5840:    nargv ++;
    #####: 5841:    tmp___13 = oargv;
    #####: 5842:    oargv ++;
    #####: 5843:    *tmp___12 = *tmp___13;
        -: 5844:  }
        -: 5845:  while_break___2: /* CIL Label */ ;
        -: 5846:  }
    #####: 5847:  *nargv = (char *)((void *)0);
    #####: 5848:  return (env___0);
        -: 5849:}
        1: 5850:}
    #####: 5851:void error(char *m ) 
        -: 5852:{ 
        -: 5853:
        -: 5854:
        -: 5855:  {
        -: 5856:  {
    #####: 5857:  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\n%s: %s: %s\n",
    #####: 5858:          progname, ifname, m);
    #####: 5859:  abort_gzip();
        -: 5860:  }
    #####: 5861:  return;
        -: 5862:}
        -: 5863:}
    #####: 5864:void warning(char *m ) 
        -: 5865:{ 
        -: 5866:
        -: 5867:
        -: 5868:  {
    #####: 5869:  if (! quiet) {
        -: 5870:    {
    #####: 5871:    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: %s: warning: %s\n",
    #####: 5872:            progname, ifname, m);
        -: 5873:    }
    #####: 5874:  }
    #####: 5875:  if (exit_code == 0) {
    #####: 5876:    exit_code = 2;
    #####: 5877:  }
    #####: 5878:  return;
        -: 5879:}
        -: 5880:}
    #####: 5881:void read_error(void) 
        -: 5882:{ 
        -: 5883:  int e ;
        -: 5884:  int *tmp ;
        -: 5885:  int *tmp___0 ;
        -: 5886:
        -: 5887:  {
        -: 5888:  {
    #####: 5889:  tmp = __errno_location();
    #####: 5890:  e = *tmp;
    #####: 5891:  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\n%s: ", progname);
        -: 5892:  }
    #####: 5893:  if (e != 0) {
        -: 5894:    {
    #####: 5895:    tmp___0 = __errno_location();
    #####: 5896:    *tmp___0 = e;
    #####: 5897:    perror((char const   *)(ifname));
        -: 5898:    }
    #####: 5899:  } else {
        -: 5900:    {
    #####: 5901:    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: unexpected end of file\n",
        -: 5902:            ifname);
        -: 5903:    }
        -: 5904:  }
        -: 5905:  {
    #####: 5906:  abort_gzip();
        -: 5907:  }
    #####: 5908:  return;
        -: 5909:}
        -: 5910:}
    #####: 5911:void write_error(void) 
        -: 5912:{ 
        -: 5913:  int e ;
        -: 5914:  int *tmp ;
        -: 5915:  int *tmp___0 ;
        -: 5916:
        -: 5917:  {
        -: 5918:  {
    #####: 5919:  tmp = __errno_location();
    #####: 5920:  e = *tmp;
    #####: 5921:  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\n%s: ", progname);
    #####: 5922:  tmp___0 = __errno_location();
    #####: 5923:  *tmp___0 = e;
    #####: 5924:  perror((char const   *)(ofname));
    #####: 5925:  abort_gzip();
        -: 5926:  }
    #####: 5927:  return;
        -: 5928:}
        -: 5929:}
    #####: 5930:void display_ratio(off_t num , off_t den , FILE *file ) 
        -: 5931:{ 
        -: 5932:  long ratio ;
        -: 5933:
        -: 5934:  {
    #####: 5935:  if (den == 0L) {
    #####: 5936:    ratio = 0L;
    #####: 5937:  } else { //Added block
    #####: 5938:  if (den < 2147483L) {
    #####: 5939:    ratio = (1000L * num) / den;
    #####: 5940:  } else {
    #####: 5941:    ratio = num / (den / 1000L);
        -: 5942:  }
        -: 5943:  }
    #####: 5944:  if (ratio < 0L) {
        -: 5945:    {
    #####: 5946:    _IO_putc('-', file);
    #####: 5947:    ratio = - ratio;
        -: 5948:    }
    #####: 5949:  } else {
        -: 5950:    {
    #####: 5951:    _IO_putc(' ', file);
        -: 5952:    }
        -: 5953:  }
        -: 5954:  {
    #####: 5955:  fprint_off(file, ratio / 10L, 2);
    #####: 5956:  fprintf((FILE * __restrict  )file, (char const   * __restrict  )".%d%%", (int )(ratio % 10L));
        -: 5957:  }
    #####: 5958:  return;
        -: 5959:}
        -: 5960:}
    #####: 5961:void fprint_off(FILE *file , off_t offset , int width ) 
        -: 5962:{ 
        -: 5963:  char buf[8UL * sizeof(off_t )] ;
        -: 5964:  char *p ;
        -: 5965:  int negative ;
        -: 5966:  int remainder ;
        -: 5967:  int quotient ;
        -: 5968:  int tmp ;
        -: 5969:
        -: 5970:  {
    #####: 5971:  p = buf + sizeof(buf);
    #####: 5972:  negative = offset < 0L;
        -: 5973:  {
    #####: 5974:  while (1) {
        -: 5975:    while_continue: /* CIL Label */ ;
    #####: 5976:    remainder = (int )(offset % 10L);
    #####: 5977:    quotient = (int )(offset / 10L);
    #####: 5978:    if (offset < 0L) {
    #####: 5979:      if (0 < remainder) {
    #####: 5980:        remainder -= 10;
    #####: 5981:        quotient ++;
    #####: 5982:      }
    #####: 5983:    }
    #####: 5984:    p --;
    #####: 5985:    if (remainder < 0) {
    #####: 5986:      tmp = - remainder;
    #####: 5987:    } else {
    #####: 5988:      tmp = remainder;
        -: 5989:    }
    #####: 5990:    *p = (char )(tmp + 48);
    #####: 5991:    width --;
    #####: 5992:    offset = (off_t )quotient;
    #####: 5993:    if (! (offset != 0L)) {
    #####: 5994:      goto while_break;
        -: 5995:    }
        -: 5996:  }
        -: 5997:  while_break: /* CIL Label */ ;
        -: 5998:  }
    #####: 5999:  width -= negative;
        -: 6000:  {
    #####: 6001:  while (1) {
        -: 6002:    while_continue___0: /* CIL Label */ ;
    #####: 6003:    if (! (0 < width)) {
    #####: 6004:      goto while_break___0;
        -: 6005:    }
        -: 6006:    {
    #####: 6007:    _IO_putc(' ', file);
    #####: 6008:    width --;
        -: 6009:    }
        -: 6010:  }
        -: 6011:  while_break___0: /* CIL Label */ ;
        -: 6012:  }
    #####: 6013:  if (negative) {
        -: 6014:    {
    #####: 6015:    _IO_putc('-', file);
        -: 6016:    }
    #####: 6017:  }
        -: 6018:  {
    #####: 6019:  while (1) {
        -: 6020:    while_continue___1: /* CIL Label */ ;
    #####: 6021:    if (! ((unsigned long )p < (unsigned long )(buf + sizeof(buf)))) {
    #####: 6022:      goto while_break___1;
        -: 6023:    }
        -: 6024:    {
    #####: 6025:    _IO_putc((int )*p, file);
    #####: 6026:    p ++;
        -: 6027:    }
        -: 6028:  }
        -: 6029:  while_break___1: /* CIL Label */ ;
        -: 6030:  }
    #####: 6031:  return;
        -: 6032:}
        -: 6033:}
    #####: 6034:voidp xmalloc(unsigned int size ) 
        -: 6035:{ 
        -: 6036:  voidp cp ;
        -: 6037:  void *tmp ;
        -: 6038:
        -: 6039:  {
        -: 6040:  {
    #####: 6041:  tmp = malloc((size_t )size);
    #####: 6042:  cp = tmp;
        -: 6043:  }
    #####: 6044:  if ((unsigned long )cp == (unsigned long )((void *)0)) {
        -: 6045:    {
    #####: 6046:    error((char *)"out of memory");
        -: 6047:    }
    #####: 6048:  }
    #####: 6049:  return (cp);
        -: 6050:}
        -: 6051:}
        -: 6052:ulg crc_32_tab[256]  = 
        -: 6053:  {      (ulg )0L,      (ulg )1996959894L,      (ulg )3993919788L,      (ulg )2567524794L, 
        -: 6054:        (ulg )124634137L,      (ulg )1886057615L,      (ulg )3915621685L,      (ulg )2657392035L, 
        -: 6055:        (ulg )249268274L,      (ulg )2044508324L,      (ulg )3772115230L,      (ulg )2547177864L, 
        -: 6056:        (ulg )162941995L,      (ulg )2125561021L,      (ulg )3887607047L,      (ulg )2428444049L, 
        -: 6057:        (ulg )498536548L,      (ulg )1789927666L,      (ulg )4089016648L,      (ulg )2227061214L, 
        -: 6058:        (ulg )450548861L,      (ulg )1843258603L,      (ulg )4107580753L,      (ulg )2211677639L, 
        -: 6059:        (ulg )325883990L,      (ulg )1684777152L,      (ulg )4251122042L,      (ulg )2321926636L, 
        -: 6060:        (ulg )335633487L,      (ulg )1661365465L,      (ulg )4195302755L,      (ulg )2366115317L, 
        -: 6061:        (ulg )997073096L,      (ulg )1281953886L,      (ulg )3579855332L,      (ulg )2724688242L, 
        -: 6062:        (ulg )1006888145L,      (ulg )1258607687L,      (ulg )3524101629L,      (ulg )2768942443L, 
        -: 6063:        (ulg )901097722L,      (ulg )1119000684L,      (ulg )3686517206L,      (ulg )2898065728L, 
        -: 6064:        (ulg )853044451L,      (ulg )1172266101L,      (ulg )3705015759L,      (ulg )2882616665L, 
        -: 6065:        (ulg )651767980L,      (ulg )1373503546L,      (ulg )3369554304L,      (ulg )3218104598L, 
        -: 6066:        (ulg )565507253L,      (ulg )1454621731L,      (ulg )3485111705L,      (ulg )3099436303L, 
        -: 6067:        (ulg )671266974L,      (ulg )1594198024L,      (ulg )3322730930L,      (ulg )2970347812L, 
        -: 6068:        (ulg )795835527L,      (ulg )1483230225L,      (ulg )3244367275L,      (ulg )3060149565L, 
        -: 6069:        (ulg )1994146192L,      (ulg )31158534L,      (ulg )2563907772L,      (ulg )4023717930L, 
        -: 6070:        (ulg )1907459465L,      (ulg )112637215L,      (ulg )2680153253L,      (ulg )3904427059L, 
        -: 6071:        (ulg )2013776290L,      (ulg )251722036L,      (ulg )2517215374L,      (ulg )3775830040L, 
        -: 6072:        (ulg )2137656763L,      (ulg )141376813L,      (ulg )2439277719L,      (ulg )3865271297L, 
        -: 6073:        (ulg )1802195444L,      (ulg )476864866L,      (ulg )2238001368L,      (ulg )4066508878L, 
        -: 6074:        (ulg )1812370925L,      (ulg )453092731L,      (ulg )2181625025L,      (ulg )4111451223L, 
        -: 6075:        (ulg )1706088902L,      (ulg )314042704L,      (ulg )2344532202L,      (ulg )4240017532L, 
        -: 6076:        (ulg )1658658271L,      (ulg )366619977L,      (ulg )2362670323L,      (ulg )4224994405L, 
        -: 6077:        (ulg )1303535960L,      (ulg )984961486L,      (ulg )2747007092L,      (ulg )3569037538L, 
        -: 6078:        (ulg )1256170817L,      (ulg )1037604311L,      (ulg )2765210733L,      (ulg )3554079995L, 
        -: 6079:        (ulg )1131014506L,      (ulg )879679996L,      (ulg )2909243462L,      (ulg )3663771856L, 
        -: 6080:        (ulg )1141124467L,      (ulg )855842277L,      (ulg )2852801631L,      (ulg )3708648649L, 
        -: 6081:        (ulg )1342533948L,      (ulg )654459306L,      (ulg )3188396048L,      (ulg )3373015174L, 
        -: 6082:        (ulg )1466479909L,      (ulg )544179635L,      (ulg )3110523913L,      (ulg )3462522015L, 
        -: 6083:        (ulg )1591671054L,      (ulg )702138776L,      (ulg )2966460450L,      (ulg )3352799412L, 
        -: 6084:        (ulg )1504918807L,      (ulg )783551873L,      (ulg )3082640443L,      (ulg )3233442989L, 
        -: 6085:        (ulg )3988292384L,      (ulg )2596254646L,      (ulg )62317068L,      (ulg )1957810842L, 
        -: 6086:        (ulg )3939845945L,      (ulg )2647816111L,      (ulg )81470997L,      (ulg )1943803523L, 
        -: 6087:        (ulg )3814918930L,      (ulg )2489596804L,      (ulg )225274430L,      (ulg )2053790376L, 
        -: 6088:        (ulg )3826175755L,      (ulg )2466906013L,      (ulg )167816743L,      (ulg )2097651377L, 
        -: 6089:        (ulg )4027552580L,      (ulg )2265490386L,      (ulg )503444072L,      (ulg )1762050814L, 
        -: 6090:        (ulg )4150417245L,      (ulg )2154129355L,      (ulg )426522225L,      (ulg )1852507879L, 
        -: 6091:        (ulg )4275313526L,      (ulg )2312317920L,      (ulg )282753626L,      (ulg )1742555852L, 
        -: 6092:        (ulg )4189708143L,      (ulg )2394877945L,      (ulg )397917763L,      (ulg )1622183637L, 
        -: 6093:        (ulg )3604390888L,      (ulg )2714866558L,      (ulg )953729732L,      (ulg )1340076626L, 
        -: 6094:        (ulg )3518719985L,      (ulg )2797360999L,      (ulg )1068828381L,      (ulg )1219638859L, 
        -: 6095:        (ulg )3624741850L,      (ulg )2936675148L,      (ulg )906185462L,      (ulg )1090812512L, 
        -: 6096:        (ulg )3747672003L,      (ulg )2825379669L,      (ulg )829329135L,      (ulg )1181335161L, 
        -: 6097:        (ulg )3412177804L,      (ulg )3160834842L,      (ulg )628085408L,      (ulg )1382605366L, 
        -: 6098:        (ulg )3423369109L,      (ulg )3138078467L,      (ulg )570562233L,      (ulg )1426400815L, 
        -: 6099:        (ulg )3317316542L,      (ulg )2998733608L,      (ulg )733239954L,      (ulg )1555261956L, 
        -: 6100:        (ulg )3268935591L,      (ulg )3050360625L,      (ulg )752459403L,      (ulg )1541320221L, 
        -: 6101:        (ulg )2607071920L,      (ulg )3965973030L,      (ulg )1969922972L,      (ulg )40735498L, 
        -: 6102:        (ulg )2617837225L,      (ulg )3943577151L,      (ulg )1913087877L,      (ulg )83908371L, 
        -: 6103:        (ulg )2512341634L,      (ulg )3803740692L,      (ulg )2075208622L,      (ulg )213261112L, 
        -: 6104:        (ulg )2463272603L,      (ulg )3855990285L,      (ulg )2094854071L,      (ulg )198958881L, 
        -: 6105:        (ulg )2262029012L,      (ulg )4057260610L,      (ulg )1759359992L,      (ulg )534414190L, 
        -: 6106:        (ulg )2176718541L,      (ulg )4139329115L,      (ulg )1873836001L,      (ulg )414664567L, 
        -: 6107:        (ulg )2282248934L,      (ulg )4279200368L,      (ulg )1711684554L,      (ulg )285281116L, 
        -: 6108:        (ulg )2405801727L,      (ulg )4167216745L,      (ulg )1634467795L,      (ulg )376229701L, 
        -: 6109:        (ulg )2685067896L,      (ulg )3608007406L,      (ulg )1308918612L,      (ulg )956543938L, 
        -: 6110:        (ulg )2808555105L,      (ulg )3495958263L,      (ulg )1231636301L,      (ulg )1047427035L, 
        -: 6111:        (ulg )2932959818L,      (ulg )3654703836L,      (ulg )1088359270L,      (ulg )936918000L, 
        -: 6112:        (ulg )2847714899L,      (ulg )3736837829L,      (ulg )1202900863L,      (ulg )817233897L, 
        -: 6113:        (ulg )3183342108L,      (ulg )3401237130L,      (ulg )1404277552L,      (ulg )615818150L, 
        -: 6114:        (ulg )3134207493L,      (ulg )3453421203L,      (ulg )1423857449L,      (ulg )601450431L, 
        -: 6115:        (ulg )3009837614L,      (ulg )3294710456L,      (ulg )1567103746L,      (ulg )711928724L, 
        -: 6116:        (ulg )3020668471L,      (ulg )3272380065L,      (ulg )1510334235L,      (ulg )755167117L};
        -: 6117:static ulg crc  ;
        1: 6118:int zip(int in , int out ) 
        -: 6119:{ 
        -: 6120:  uch flags___0 ;
        -: 6121:  ush attr ;
        -: 6122:  ush deflate_flags ;
        -: 6123:  unsigned int tmp ;
        -: 6124:  unsigned int tmp___0 ;
        -: 6125:  unsigned int tmp___1 ;
        -: 6126:  unsigned int tmp___2 ;
        -: 6127:  unsigned int tmp___3 ;
        -: 6128:  ulg tmp___4 ;
        -: 6129:  unsigned int tmp___5 ;
        -: 6130:  ulg tmp___6 ;
        -: 6131:  unsigned int tmp___7 ;
        -: 6132:  ulg tmp___8 ;
        -: 6133:  unsigned int tmp___9 ;
        -: 6134:  ulg tmp___10 ;
        -: 6135:  unsigned int tmp___11 ;
        -: 6136:  ulg tmp___12 ;
        -: 6137:  unsigned int tmp___13 ;
        -: 6138:  ulg tmp___14 ;
        -: 6139:  unsigned int tmp___15 ;
        -: 6140:  ulg tmp___16 ;
        -: 6141:  unsigned int tmp___17 ;
        -: 6142:  ulg tmp___18 ;
        -: 6143:  unsigned int tmp___19 ;
        -: 6144:  unsigned int tmp___20 ;
        -: 6145:  char *p ;
        -: 6146:  char *tmp___21 ;
        -: 6147:  unsigned int tmp___22 ;
        -: 6148:  char *tmp___23 ;
        -: 6149:  unsigned int tmp___24 ;
        -: 6150:  unsigned int tmp___25 ;
        -: 6151:  unsigned int tmp___26 ;
        -: 6152:  unsigned int tmp___27 ;
        -: 6153:  unsigned int tmp___28 ;
        -: 6154:  unsigned int tmp___29 ;
        -: 6155:  unsigned int tmp___30 ;
        -: 6156:  unsigned int tmp___31 ;
        -: 6157:  unsigned int tmp___32 ;
        -: 6158:  unsigned int tmp___33 ;
        -: 6159:  unsigned int tmp___34 ;
        -: 6160:  unsigned int tmp___35 ;
        -: 6161:  unsigned int tmp___36 ;
        -: 6162:  unsigned int tmp___37 ;
        -: 6163:  unsigned int tmp___38 ;
        -: 6164:  unsigned int tmp___39 ;
        -: 6165:
        -: 6166:  {
        1: 6167:  flags___0 = (uch )0;
        1: 6168:  attr = (ush )0;
        1: 6169:  deflate_flags = (ush )0;
        1: 6170:  ifd = in;
        1: 6171:  ofd = out;
        1: 6172:  outcnt = 0U;
        1: 6173:  method = 8;
        1: 6174:  tmp = outcnt;
        1: 6175:  outcnt ++;
        1: 6176:  outbuf[tmp] = (uch )*("\037\213" + 0);
        1: 6177:  if (outcnt == 16384U) {
        -: 6178:    {
    #####: 6179:    flush_outbuf();
        -: 6180:    }
    #####: 6181:  }
        1: 6182:  tmp___0 = outcnt;
        1: 6183:  outcnt ++;
        1: 6184:  outbuf[tmp___0] = (uch )*("\037\213" + 1);
        1: 6185:  if (outcnt == 16384U) {
        -: 6186:    {
    #####: 6187:    flush_outbuf();
        -: 6188:    }
    #####: 6189:  }
        1: 6190:  tmp___1 = outcnt;
        1: 6191:  outcnt ++;
        1: 6192:  outbuf[tmp___1] = (uch )8;
        1: 6193:  if (outcnt == 16384U) {
        -: 6194:    {
    #####: 6195:    flush_outbuf();
        -: 6196:    }
    #####: 6197:  }
        1: 6198:  if (save_orig_name) {
        1: 6199:    flags___0 = (uch )((int )flags___0 | 8);
        1: 6200:  }
        1: 6201:  tmp___2 = outcnt;
        1: 6202:  outcnt ++;
        1: 6203:  outbuf[tmp___2] = flags___0;
        1: 6204:  if (outcnt == 16384U) {
        -: 6205:    {
    #####: 6206:    flush_outbuf();
        -: 6207:    }
    #####: 6208:  }
        1: 6209:  time_stamp = (time_t )0;
        1: 6210:  if (outcnt < 16382U) {
        1: 6211:    tmp___3 = outcnt;
        1: 6212:    outcnt ++;
        1: 6213:    if (time_stamp == (time_stamp & 4294967295L)) {
        1: 6214:      tmp___4 = (ulg )time_stamp;
        1: 6215:    } else {
    #####: 6216:      tmp___4 = (ulg )0;
        -: 6217:    }
        1: 6218:    outbuf[tmp___3] = (uch )((tmp___4 & 65535UL) & 255UL);
        1: 6219:    tmp___5 = outcnt;
        1: 6220:    outcnt ++;
        1: 6221:    if (time_stamp == (time_stamp & 4294967295L)) {
        1: 6222:      tmp___6 = (ulg )time_stamp;
        1: 6223:    } else {
    #####: 6224:      tmp___6 = (ulg )0;
        -: 6225:    }
        1: 6226:    outbuf[tmp___5] = (uch )((int )((ush )(tmp___6 & 65535UL)) >> 8);
        1: 6227:  } else {
    #####: 6228:    tmp___7 = outcnt;
    #####: 6229:    outcnt ++;
    #####: 6230:    if (time_stamp == (time_stamp & 4294967295L)) {
    #####: 6231:      tmp___8 = (ulg )time_stamp;
    #####: 6232:    } else {
    #####: 6233:      tmp___8 = (ulg )0;
        -: 6234:    }
    #####: 6235:    outbuf[tmp___7] = (uch )((tmp___8 & 65535UL) & 255UL);
    #####: 6236:    if (outcnt == 16384U) {
        -: 6237:      {
    #####: 6238:      flush_outbuf();
        -: 6239:      }
    #####: 6240:    }
    #####: 6241:    tmp___9 = outcnt;
    #####: 6242:    outcnt ++;
    #####: 6243:    if (time_stamp == (time_stamp & 4294967295L)) {
    #####: 6244:      tmp___10 = (ulg )time_stamp;
    #####: 6245:    } else {
    #####: 6246:      tmp___10 = (ulg )0;
        -: 6247:    }
    #####: 6248:    outbuf[tmp___9] = (uch )((int )((ush )(tmp___10 & 65535UL)) >> 8);
    #####: 6249:    if (outcnt == 16384U) {
        -: 6250:      {
    #####: 6251:      flush_outbuf();
        -: 6252:      }
    #####: 6253:    }
        -: 6254:  }
        1: 6255:  if (outcnt < 16382U) {
        1: 6256:    tmp___11 = outcnt;
        1: 6257:    outcnt ++;
        1: 6258:    if (time_stamp == (time_stamp & 4294967295L)) {
        1: 6259:      tmp___12 = (ulg )time_stamp;
        1: 6260:    } else {
    #####: 6261:      tmp___12 = (ulg )0;
        -: 6262:    }
        1: 6263:    outbuf[tmp___11] = (uch )((tmp___12 >> 16) & 255UL);
        1: 6264:    tmp___13 = outcnt;
        1: 6265:    outcnt ++;
        1: 6266:    if (time_stamp == (time_stamp & 4294967295L)) {
        1: 6267:      tmp___14 = (ulg )time_stamp;
        1: 6268:    } else {
    #####: 6269:      tmp___14 = (ulg )0;
        -: 6270:    }
        1: 6271:    outbuf[tmp___13] = (uch )((int )((ush )(tmp___14 >> 16)) >> 8);
        1: 6272:  } else {
    #####: 6273:    tmp___15 = outcnt;
    #####: 6274:    outcnt ++;
    #####: 6275:    if (time_stamp == (time_stamp & 4294967295L)) {
    #####: 6276:      tmp___16 = (ulg )time_stamp;
    #####: 6277:    } else {
    #####: 6278:      tmp___16 = (ulg )0;
        -: 6279:    }
    #####: 6280:    outbuf[tmp___15] = (uch )((tmp___16 >> 16) & 255UL);
    #####: 6281:    if (outcnt == 16384U) {
        -: 6282:      {
    #####: 6283:      flush_outbuf();
        -: 6284:      }
    #####: 6285:    }
    #####: 6286:    tmp___17 = outcnt;
    #####: 6287:    outcnt ++;
    #####: 6288:    if (time_stamp == (time_stamp & 4294967295L)) {
    #####: 6289:      tmp___18 = (ulg )time_stamp;
    #####: 6290:    } else {
    #####: 6291:      tmp___18 = (ulg )0;
        -: 6292:    }
    #####: 6293:    outbuf[tmp___17] = (uch )((int )((ush )(tmp___18 >> 16)) >> 8);
    #####: 6294:    if (outcnt == 16384U) {
        -: 6295:      {
    #####: 6296:      flush_outbuf();
        -: 6297:      }
    #####: 6298:    }
        -: 6299:  }
        -: 6300:  {
        1: 6301:  crc = updcrc((uch *)0, 0U);
        1: 6302:  bi_init(out);
        1: 6303:  ct_init(& attr, & method);
        1: 6304:  lm_init(level, & deflate_flags);
        1: 6305:  tmp___19 = outcnt;
        1: 6306:  outcnt ++;
        1: 6307:  outbuf[tmp___19] = (uch )deflate_flags;
        -: 6308:  }
        1: 6309:  if (outcnt == 16384U) {
        -: 6310:    {
    #####: 6311:    flush_outbuf();
        -: 6312:    }
    #####: 6313:  }
        1: 6314:  tmp___20 = outcnt;
        1: 6315:  outcnt ++;
        1: 6316:  outbuf[tmp___20] = (uch )3;
        1: 6317:  if (outcnt == 16384U) {
        -: 6318:    {
    #####: 6319:    flush_outbuf();
        -: 6320:    }
    #####: 6321:  }
        1: 6322:  if (save_orig_name) {
        -: 6323:    {
        1: 6324:    tmp___21 = base_name(ifname);
        1: 6325:    p = tmp___21;
        -: 6326:    }
        -: 6327:    {
        7: 6328:    while (1) {
        -: 6329:      while_continue: /* CIL Label */ ;
        7: 6330:      tmp___22 = outcnt;
        7: 6331:      outcnt ++;
        7: 6332:      outbuf[tmp___22] = (uch )*p;
        7: 6333:      if (outcnt == 16384U) {
        -: 6334:        {
    #####: 6335:        flush_outbuf();
        -: 6336:        }
    #####: 6337:      }
        7: 6338:      tmp___23 = p;
        7: 6339:      p ++;
        7: 6340:      if (! *tmp___23) {
        1: 6341:        goto while_break;
        -: 6342:      }
        -: 6343:    }
        -: 6344:    while_break: /* CIL Label */ ;
        -: 6345:    }
        1: 6346:  }
        -: 6347:  {
        1: 6348:  header_bytes = (off_t )outcnt;
        1: 6349:  deflate();
        -: 6350:  }
        1: 6351:  if (outcnt < 16382U) {
        1: 6352:    tmp___24 = outcnt;
        1: 6353:    outcnt ++;
        1: 6354:    outbuf[tmp___24] = (uch )((crc & 65535UL) & 255UL);
        1: 6355:    tmp___25 = outcnt;
        1: 6356:    outcnt ++;
        1: 6357:    outbuf[tmp___25] = (uch )((int )((ush )(crc & 65535UL)) >> 8);
        1: 6358:  } else {
    #####: 6359:    tmp___26 = outcnt;
    #####: 6360:    outcnt ++;
    #####: 6361:    outbuf[tmp___26] = (uch )((crc & 65535UL) & 255UL);
    #####: 6362:    if (outcnt == 16384U) {
        -: 6363:      {
    #####: 6364:      flush_outbuf();
        -: 6365:      }
    #####: 6366:    }
    #####: 6367:    tmp___27 = outcnt;
    #####: 6368:    outcnt ++;
    #####: 6369:    outbuf[tmp___27] = (uch )((int )((ush )(crc & 65535UL)) >> 8);
    #####: 6370:    if (outcnt == 16384U) {
        -: 6371:      {
    #####: 6372:      flush_outbuf();
        -: 6373:      }
    #####: 6374:    }
        -: 6375:  }
        1: 6376:  if (outcnt < 16382U) {
        1: 6377:    tmp___28 = outcnt;
        1: 6378:    outcnt ++;
        1: 6379:    outbuf[tmp___28] = (uch )((crc >> 16) & 255UL);
        1: 6380:    tmp___29 = outcnt;
        1: 6381:    outcnt ++;
        1: 6382:    outbuf[tmp___29] = (uch )((int )((ush )(crc >> 16)) >> 8);
        1: 6383:  } else {
    #####: 6384:    tmp___30 = outcnt;
    #####: 6385:    outcnt ++;
    #####: 6386:    outbuf[tmp___30] = (uch )((crc >> 16) & 255UL);
    #####: 6387:    if (outcnt == 16384U) {
        -: 6388:      {
    #####: 6389:      flush_outbuf();
        -: 6390:      }
    #####: 6391:    }
    #####: 6392:    tmp___31 = outcnt;
    #####: 6393:    outcnt ++;
    #####: 6394:    outbuf[tmp___31] = (uch )((int )((ush )(crc >> 16)) >> 8);
    #####: 6395:    if (outcnt == 16384U) {
        -: 6396:      {
    #####: 6397:      flush_outbuf();
        -: 6398:      }
    #####: 6399:    }
        -: 6400:  }
        1: 6401:  if (outcnt < 16382U) {
        1: 6402:    tmp___32 = outcnt;
        1: 6403:    outcnt ++;
        1: 6404:    outbuf[tmp___32] = (uch )(((ulg )bytes_in & 65535UL) & 255UL);
        1: 6405:    tmp___33 = outcnt;
        1: 6406:    outcnt ++;
        1: 6407:    outbuf[tmp___33] = (uch )((int )((ush )((ulg )bytes_in & 65535UL)) >> 8);
        1: 6408:  } else {
    #####: 6409:    tmp___34 = outcnt;
    #####: 6410:    outcnt ++;
    #####: 6411:    outbuf[tmp___34] = (uch )(((ulg )bytes_in & 65535UL) & 255UL);
    #####: 6412:    if (outcnt == 16384U) {
        -: 6413:      {
    #####: 6414:      flush_outbuf();
        -: 6415:      }
    #####: 6416:    }
    #####: 6417:    tmp___35 = outcnt;
    #####: 6418:    outcnt ++;
    #####: 6419:    outbuf[tmp___35] = (uch )((int )((ush )((ulg )bytes_in & 65535UL)) >> 8);
    #####: 6420:    if (outcnt == 16384U) {
        -: 6421:      {
    #####: 6422:      flush_outbuf();
        -: 6423:      }
    #####: 6424:    }
        -: 6425:  }
        1: 6426:  if (outcnt < 16382U) {
        1: 6427:    tmp___36 = outcnt;
        1: 6428:    outcnt ++;
        1: 6429:    outbuf[tmp___36] = (uch )(((ulg )bytes_in >> 16) & 255UL);
        1: 6430:    tmp___37 = outcnt;
        1: 6431:    outcnt ++;
        1: 6432:    outbuf[tmp___37] = (uch )((int )((ush )((ulg )bytes_in >> 16)) >> 8);
        1: 6433:  } else {
    #####: 6434:    tmp___38 = outcnt;
    #####: 6435:    outcnt ++;
    #####: 6436:    outbuf[tmp___38] = (uch )(((ulg )bytes_in >> 16) & 255UL);
    #####: 6437:    if (outcnt == 16384U) {
        -: 6438:      {
    #####: 6439:      flush_outbuf();
        -: 6440:      }
    #####: 6441:    }
    #####: 6442:    tmp___39 = outcnt;
    #####: 6443:    outcnt ++;
    #####: 6444:    outbuf[tmp___39] = (uch )((int )((ush )((ulg )bytes_in >> 16)) >> 8);
    #####: 6445:    if (outcnt == 16384U) {
        -: 6446:      {
    #####: 6447:      flush_outbuf();
        -: 6448:      }
    #####: 6449:    }
        -: 6450:  }
        -: 6451:  {
        1: 6452:  header_bytes = (off_t )((unsigned long )header_bytes + 2UL * sizeof(long ));
        1: 6453:  flush_outbuf();
        -: 6454:  }
        1: 6455:  return (0);
        -: 6456:}
        -: 6457:}
        2: 6458:int file_read(char *buf , unsigned int size ) 
        -: 6459:{ 
        -: 6460:  unsigned int len ;
        -: 6461:  ssize_t tmp ;
        -: 6462:
        -: 6463:  {
        -: 6464:  {
        2: 6465:  tmp = read(ifd, (void *)buf, (size_t )size);
        2: 6466:  len = (unsigned int )tmp;
        -: 6467:  }
        2: 6468:  if (len == 0U) {
        1: 6469:    return ((int )len);
        -: 6470:  }
        1: 6471:  if (len == 4294967295U) {
        -: 6472:    {
    #####: 6473:    read_error();
        -: 6474:    }
    #####: 6475:    return (-1);
        -: 6476:  }
        -: 6477:  {
        1: 6478:  crc = updcrc((uch *)buf, len);
        1: 6479:  bytes_in += (off_t )len;
        -: 6480:  }
        1: 6481:  return ((int )len);
        -: 6482:}
        2: 6483:}
        -: 6484:static char *license_msg[7]  = {      (char *)"Copyright 1999 Free Software Foundation",      (char *)"Copyright 1992-1993 Jean-loup Gailly",      (char *)"This program comes with ABSOLUTELY NO WARRANTY.",      (char *)"You may redistribute copies of this program", 
        -: 6485:        (char *)"under the terms of the GNU General Public License.",      (char *)"For more information about these matters, see the file named COPYING.",      (char *)0};
        -: 6486:extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) ctime)(time_t const   *__timer ) ;
        -: 6487:extern DIR *( __attribute__((__nonnull__(1))) opendir)(char const   *__name ) ;
        -: 6488:extern int ( __attribute__((__nonnull__(1))) closedir)(DIR *__dirp ) ;
        -: 6489:extern struct dirent *( __attribute__((__nonnull__(1))) readdir)(DIR *__dirp ) ;
        -: 6490:extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) utime)(char const   *__file ,
        -: 6491:                                                                                            struct utimbuf  const  *__file_times ) ;
        -: 6492:int ascii  =    0;
        -: 6493:int to_stdout  =    0;
        -: 6494:int decompress  =    0;
        -: 6495:int force  =    0;
        -: 6496:int no_name  =    -1;
        -: 6497:int no_time  =    -1;
        -: 6498:int recursive  =    0;
        -: 6499:int list  =    0;
        -: 6500:int verbose  =    0;
        -: 6501:int quiet  =    0;
        -: 6502:int do_lzw  =    0;
        -: 6503:int test  =    0;
        -: 6504:int foreground  ;
        -: 6505:int maxbits  =    16;
        -: 6506:int method  =    8;
        -: 6507:int level  =    6;
        -: 6508:int exit_code  =    0;
        -: 6509:int last_member  ;
        -: 6510:int part_nb  ;
        -: 6511:char *env  ;
        -: 6512:char **args  =    (char **)((void *)0);
        -: 6513:char *z_suffix  ;
        -: 6514:int z_len  ;
        -: 6515:off_t total_in  ;
        -: 6516:off_t total_out  ;
        -: 6517:int remove_ofname  =    0;
        -: 6518:struct stat istat  ;
        -: 6519:struct option longopts[24]  = 
        -: 6520:  {      {"ascii", 0, (int *)0, 'a'}, 
        -: 6521:        {"to-stdout", 0, (int *)0, 'c'}, 
        -: 6522:        {"stdout", 0, (int *)0, 'c'}, 
        -: 6523:        {"decompress", 0, (int *)0, 'd'}, 
        -: 6524:        {"uncompress", 0, (int *)0, 'd'}, 
        -: 6525:        {"force", 0, (int *)0, 'f'}, 
        -: 6526:        {"help", 0, (int *)0, 'h'}, 
        -: 6527:        {"list", 0, (int *)0, 'l'}, 
        -: 6528:        {"license", 0, (int *)0, 'L'}, 
        -: 6529:        {"no-name", 0, (int *)0, 'n'}, 
        -: 6530:        {"name", 0, (int *)0, 'N'}, 
        -: 6531:        {"quiet", 0, (int *)0, 'q'}, 
        -: 6532:        {"silent", 0, (int *)0, 'q'}, 
        -: 6533:        {"recursive", 0, (int *)0, 'r'}, 
        -: 6534:        {"suffix", 1, (int *)0, 'S'}, 
        -: 6535:        {"test", 0, (int *)0, 't'}, 
        -: 6536:        {"no-time", 0, (int *)0, 'T'}, 
        -: 6537:        {"verbose", 0, (int *)0, 'v'}, 
        -: 6538:        {"version", 0, (int *)0, 'V'}, 
        -: 6539:        {"fast", 0, (int *)0, '1'}, 
        -: 6540:        {"best", 0, (int *)0, '9'}, 
        -: 6541:        {"lzw", 0, (int *)0, 'Z'}, 
        -: 6542:        {"bits", 1, (int *)0, 'b'}, 
        -: 6543:        {(char const   *)0, 0, (int *)0, 0}};
        -: 6544:static void usage(void) ;
        -: 6545:static void help(void) ;
        -: 6546:static void license(void) ;
        -: 6547:static void version(void) ;
        -: 6548:static int input_eof(void) ;
        -: 6549:static void treat_stdin(void) ;
        -: 6550:static void treat_file(char *iname ) ;
        -: 6551:static int create_outfile(void) ;
        -: 6552:static int do_stat(char *name , struct stat *sbuf ) ;
        -: 6553:static char *get_suffix(char *name ) ;
        -: 6554:static int get_istat(char *iname , struct stat *sbuf ) ;
        -: 6555:static int make_ofname(void) ;
        -: 6556:static int same_file(struct stat *stat1 , struct stat *stat2 ) ;
        -: 6557:static int name_too_long(char *name , struct stat *statb ) ;
        -: 6558:static void shorten_name(char *name ) ;
        -: 6559:static int get_method(int in ) ;
        -: 6560:static void do_list(int ifd___0 , int method___0 ) ;
        -: 6561:static int check_ofname(void) ;
        -: 6562:static void copy_stat(struct stat *ifstat ) ;
        -: 6563:static void do_exit(int exitcode ) ;
        -: 6564:int main(int argc , char **argv ) ;
        -: 6565:int (*work)(int infile , int outfile )  =    & zip;
        -: 6566:static void treat_dir(char *dir ) ;
        -: 6567:static void reset_times(char *name , struct stat *statb ) ;
    #####: 6568:static void usage(void) 
        -: 6569:{ 
        -: 6570:
        -: 6571:
        -: 6572:  {
        -: 6573:  {
    #####: 6574:  printf((char const   * __restrict  )"usage: %s [-%scdfhlLnN%stvV19] [-S suffix] [file ...]\n",
    #####: 6575:         progname, "", "r");
        -: 6576:  }
    #####: 6577:  return;
        -: 6578:}
        -: 6579:}
        -: 6580:static char *help_msg[19]  = 
        -: 6581:  {      (char *)" -c --stdout      write on standard output, keep original files unchanged",      (char *)" -d --decompress  decompress",      (char *)" -f --force       force overwrite of output file and compress links",      (char *)" -h --help        give this help", 
        -: 6582:        (char *)" -l --list        list compressed file contents",      (char *)" -L --license     display software license",      (char *)" -n --no-name     do not save or restore the original name and time stamp",      (char *)" -N --name        save or restore the original name and time stamp", 
        -: 6583:        (char *)" -q --quiet       suppress all warnings",      (char *)" -r --recursive   operate recursively on directories",      (char *)" -S .suf  --suffix .suf     use suffix .suf on compressed files",      (char *)" -t --test        test compressed file integrity", 
        -: 6584:        (char *)" -v --verbose     verbose mode",      (char *)" -V --version     display version number",      (char *)" -1 --fast        compress faster",      (char *)" -9 --best        compress better", 
        -: 6585:        (char *)" file...          files to (de)compress. If none given, use standard input.",      (char *)"Report bugs to <bug-gzip@gnu.org>.",      (char *)0};
    #####: 6586:static void help(void) 
        -: 6587:{ 
        -: 6588:  char **p ;
        -: 6589:  char **tmp ;
        -: 6590:
        -: 6591:  {
        -: 6592:  {
    #####: 6593:  p = help_msg;
    #####: 6594:  printf((char const   * __restrict  )"%s %s\n(%s)\n", progname, "1.3", "1999-12-21");
    #####: 6595:  usage();
        -: 6596:  }
        -: 6597:  {
    #####: 6598:  while (1) {
        -: 6599:    while_continue: /* CIL Label */ ;
    #####: 6600:    if (! *p) {
    #####: 6601:      goto while_break;
        -: 6602:    }
        -: 6603:    {
    #####: 6604:    tmp = p;
    #####: 6605:    p ++;
    #####: 6606:    printf((char const   * __restrict  )"%s\n", *tmp);
        -: 6607:    }
        -: 6608:  }
        -: 6609:  while_break: /* CIL Label */ ;
        -: 6610:  }
    #####: 6611:  return;
        -: 6612:}
        -: 6613:}
    #####: 6614:static void license(void) 
        -: 6615:{ 
        -: 6616:  char **p ;
        -: 6617:  char **tmp ;
        -: 6618:
        -: 6619:  {
        -: 6620:  {
    #####: 6621:  p = license_msg;
    #####: 6622:  printf((char const   * __restrict  )"%s %s\n(%s)\n", progname, "1.3", "1999-12-21");
        -: 6623:  }
        -: 6624:  {
    #####: 6625:  while (1) {
        -: 6626:    while_continue: /* CIL Label */ ;
    #####: 6627:    if (! *p) {
    #####: 6628:      goto while_break;
        -: 6629:    }
        -: 6630:    {
    #####: 6631:    tmp = p;
    #####: 6632:    p ++;
    #####: 6633:    printf((char const   * __restrict  )"%s\n", *tmp);
        -: 6634:    }
        -: 6635:  }
        -: 6636:  while_break: /* CIL Label */ ;
        -: 6637:  }
    #####: 6638:  return;
        -: 6639:}
        -: 6640:}
    #####: 6641:static void version(void) 
        -: 6642:{ 
        -: 6643:
        -: 6644:
        -: 6645:  {
        -: 6646:  {
    #####: 6647:  license();
    #####: 6648:  printf((char const   * __restrict  )"Compilation options:\n%s %s ", "DIRENT", "UTIME");
    #####: 6649:  printf((char const   * __restrict  )"STDC_HEADERS ");
    #####: 6650:  printf((char const   * __restrict  )"HAVE_UNISTD_H ");
    #####: 6651:  printf((char const   * __restrict  )"HAVE_MEMORY_H ");
    #####: 6652:  printf((char const   * __restrict  )"HAVE_STRING_H ");
    #####: 6653:  printf((char const   * __restrict  )"\n");
    #####: 6654:  printf((char const   * __restrict  )"Written by Jean-loup Gailly.\n");
        -: 6655:  }
    #####: 6656:  return;
        -: 6657:}
        -: 6658:}
    #####: 6659:static void progerror(char *string ) 
        -: 6660:{ 
        -: 6661:  int e ;
        -: 6662:  int *tmp ;
        -: 6663:  int *tmp___0 ;
        -: 6664:
        -: 6665:  {
        -: 6666:  {
    #####: 6667:  tmp = __errno_location();
    #####: 6668:  e = *tmp;
    #####: 6669:  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: ", progname);
    #####: 6670:  tmp___0 = __errno_location();
    #####: 6671:  *tmp___0 = e;
    #####: 6672:  perror((char const   *)string);
    #####: 6673:  exit_code = 1;
        -: 6674:  }
    #####: 6675:  return;
        -: 6676:}
        -: 6677:}
        1: 6678:int main(int argc , char **argv ) 
        -: 6679:{ 
        -: 6680:  int file_count ;
        -: 6681:  int proglen ;
        -: 6682:  int optc ;
        -: 6683:  size_t tmp ;
        -: 6684:  int tmp___0 ;
        -: 6685:  void (*tmp___1)(int  ) ;
        -: 6686:  void (*tmp___2)(int  ) ;
        -: 6687:  void (*tmp___3)(int  ) ;
        -: 6688:  int tmp___4 ;
        -: 6689:  int tmp___5 ;
        -: 6690:  int tmp___6 ;
        -: 6691:  int tmp___7 ;
        -: 6692:  size_t tmp___8 ;
        -: 6693:  size_t tmp___9 ;
        -: 6694:  void (*tmp___10)(int  ) ;
        -: 6695:  int tmp___11 ;
        -: 6696:  int tmp___12 ;
        -: 6697:
        -: 6698:  {
        -: 6699:  {
        1: 6700:  progname = base_name(*(argv + 0));
        1: 6701:  tmp = strlen((char const   *)progname);
        1: 6702:  proglen = (int )tmp;
        -: 6703:  }
        1: 6704:  if (proglen > 4) {
        -: 6705:    {
        1: 6706:    tmp___0 = strcmp((char const   *)((progname + proglen) - 4), ".exe");
        -: 6707:    }
        1: 6708:    if (tmp___0 == 0) {
    #####: 6709:      *(progname + (proglen - 4)) = (char )'\000';
    #####: 6710:    }
        1: 6711:  }
        -: 6712:  {
        1: 6713:  env = add_envopt(& argc, & argv, (char *)"GZIP");
        -: 6714:  }
        1: 6715:  if ((unsigned long )env != (unsigned long )((void *)0)) {
    #####: 6716:    args = argv;
    #####: 6717:  }
        -: 6718:  {
        1: 6719:  tmp___1 = signal(2, (void (*)(int  ))1);
        1: 6720:  foreground = (unsigned long )tmp___1 != (unsigned long )((void (*)(int  ))1);
        -: 6721:  }
        1: 6722:  if (foreground) {
        -: 6723:    {
        1: 6724:    signal(2, (void (*)(int  ))(& abort_gzip));
        -: 6725:    }
        1: 6726:  }
        -: 6727:  {
        1: 6728:  tmp___2 = signal(15, (void (*)(int  ))1);
        -: 6729:  }
        1: 6730:  if ((unsigned long )tmp___2 != (unsigned long )((void (*)(int  ))1)) {
        -: 6731:    {
        1: 6732:    signal(15, (void (*)(int  ))(& abort_gzip));
        -: 6733:    }
        1: 6734:  }
        -: 6735:  {
        1: 6736:  tmp___3 = signal(1, (void (*)(int  ))1);
        -: 6737:  }
        1: 6738:  if ((unsigned long )tmp___3 != (unsigned long )((void (*)(int  ))1)) {
        -: 6739:    {
        1: 6740:    signal(1, (void (*)(int  ))(& abort_gzip));
        -: 6741:    }
        1: 6742:  }
        -: 6743:  {
        1: 6744:  tmp___6 = strncmp((char const   *)progname, "un", (size_t )2);
        -: 6745:  }
        1: 6746:  if (tmp___6 == 0) {
    #####: 6747:    decompress = 1;
    #####: 6748:  } else {
        -: 6749:    {
        1: 6750:    tmp___7 = strncmp((char const   *)progname, "gun", (size_t )3);
        -: 6751:    }
        1: 6752:    if (tmp___7 == 0) {
    #####: 6753:      decompress = 1;
    #####: 6754:    } else {
        -: 6755:      {
        1: 6756:      tmp___4 = strcmp((char const   *)(progname + 1), "cat");
        -: 6757:      }
        1: 6758:      if (tmp___4 == 0) {
    #####: 6759:        to_stdout = 1;
    #####: 6760:        decompress = to_stdout;
    #####: 6761:      } else {
        -: 6762:        {
        1: 6763:        tmp___5 = strcmp((char const   *)progname, "gzcat");
        -: 6764:        }
        1: 6765:        if (tmp___5 == 0) {
    #####: 6766:          to_stdout = 1;
    #####: 6767:          decompress = to_stdout;
    #####: 6768:        }
        -: 6769:      }
        -: 6770:    }
        -: 6771:  }
        -: 6772:  {
        1: 6773:  z_suffix = (char *)".gz";
        1: 6774:  tmp___8 = strlen((char const   *)z_suffix);
        1: 6775:  z_len = (int )tmp___8;
        -: 6776:  }
        -: 6777:  {
        2: 6778:  while (1) {
        -: 6779:    while_continue: /* CIL Label */ ;
        -: 6780:    {
        2: 6781:    optc = getopt_long(argc, (char * const  *)argv, "ab:cdfhH?lLmMnNqrS:tvVZ123456789",
        -: 6782:                       (struct option  const  *)(longopts), (int *)0);
        -: 6783:    }
        2: 6784:    if (! (optc != -1)) {
        1: 6785:      goto while_break;
        -: 6786:    }
        -: 6787:    {
        1: 6788:    if (optc == 97) {
    #####: 6789:      goto case_97;
        -: 6790:    }
        1: 6791:    if (optc == 98) {
    #####: 6792:      goto case_98;
        -: 6793:    }
        1: 6794:    if (optc == 99) {
        1: 6795:      goto case_99;
        -: 6796:    }
    #####: 6797:    if (optc == 100) {
    #####: 6798:      goto case_100;
        -: 6799:    }
    #####: 6800:    if (optc == 102) {
    #####: 6801:      goto case_102;
        -: 6802:    }
    #####: 6803:    if (optc == 104) {
    #####: 6804:      goto case_104;
        -: 6805:    }
    #####: 6806:    if (optc == 72) {
    #####: 6807:      goto case_104;
        -: 6808:    }
    #####: 6809:    if (optc == 63) {
    #####: 6810:      goto case_104;
        -: 6811:    }
    #####: 6812:    if (optc == 108) {
    #####: 6813:      goto case_108;
        -: 6814:    }
    #####: 6815:    if (optc == 76) {
    #####: 6816:      goto case_76;
        -: 6817:    }
    #####: 6818:    if (optc == 109) {
    #####: 6819:      goto case_109;
        -: 6820:    }
    #####: 6821:    if (optc == 77) {
    #####: 6822:      goto case_77;
        -: 6823:    }
    #####: 6824:    if (optc == 110) {
    #####: 6825:      goto case_110;
        -: 6826:    }
    #####: 6827:    if (optc == 78) {
    #####: 6828:      goto case_78;
        -: 6829:    }
    #####: 6830:    if (optc == 113) {
    #####: 6831:      goto case_113;
        -: 6832:    }
    #####: 6833:    if (optc == 114) {
    #####: 6834:      goto case_114;
        -: 6835:    }
    #####: 6836:    if (optc == 83) {
    #####: 6837:      goto case_83;
        -: 6838:    }
    #####: 6839:    if (optc == 116) {
    #####: 6840:      goto case_116;
        -: 6841:    }
    #####: 6842:    if (optc == 118) {
    #####: 6843:      goto case_118;
        -: 6844:    }
    #####: 6845:    if (optc == 86) {
    #####: 6846:      goto case_86;
        -: 6847:    }
    #####: 6848:    if (optc == 90) {
    #####: 6849:      goto case_90;
        -: 6850:    }
    #####: 6851:    if (optc == 49) {
    #####: 6852:      goto case_49;
        -: 6853:    }
    #####: 6854:    if (optc == 50) {
    #####: 6855:      goto case_49;
        -: 6856:    }
    #####: 6857:    if (optc == 51) {
    #####: 6858:      goto case_49;
        -: 6859:    }
    #####: 6860:    if (optc == 52) {
    #####: 6861:      goto case_49;
        -: 6862:    }
    #####: 6863:    if (optc == 53) {
    #####: 6864:      goto case_49;
        -: 6865:    }
    #####: 6866:    if (optc == 54) {
    #####: 6867:      goto case_49;
        -: 6868:    }
    #####: 6869:    if (optc == 55) {
    #####: 6870:      goto case_49;
        -: 6871:    }
    #####: 6872:    if (optc == 56) {
    #####: 6873:      goto case_49;
        -: 6874:    }
    #####: 6875:    if (optc == 57) {
    #####: 6876:      goto case_49;
        -: 6877:    }
    #####: 6878:    goto switch_default;
        -: 6879:    case_97: /* CIL Label */ 
    #####: 6880:    ascii = 1;
    #####: 6881:    goto switch_break;
        -: 6882:    case_98: /* CIL Label */ 
        -: 6883:    {
    #####: 6884:    maxbits = atoi((char const   *)optarg);
        -: 6885:    }
    #####: 6886:    goto switch_break;
        -: 6887:    case_99: /* CIL Label */ 
        1: 6888:    to_stdout = 1;
        1: 6889:    goto switch_break;
        -: 6890:    case_100: /* CIL Label */ 
    #####: 6891:    decompress = 1;
    #####: 6892:    goto switch_break;
        -: 6893:    case_102: /* CIL Label */ 
    #####: 6894:    force ++;
    #####: 6895:    goto switch_break;
        -: 6896:    case_104: /* CIL Label */ 
        -: 6897:    case_72: /* CIL Label */ 
        -: 6898:    case_63: /* CIL Label */ 
        -: 6899:    {
    #####: 6900:    help();
    #####: 6901:    do_exit(0);
        -: 6902:    }
    #####: 6903:    goto switch_break;
        -: 6904:    case_108: /* CIL Label */ 
    #####: 6905:    to_stdout = 1;
    #####: 6906:    decompress = to_stdout;
    #####: 6907:    list = decompress;
    #####: 6908:    goto switch_break;
        -: 6909:    case_76: /* CIL Label */ 
        -: 6910:    {
    #####: 6911:    license();
    #####: 6912:    do_exit(0);
        -: 6913:    }
    #####: 6914:    goto switch_break;
        -: 6915:    case_109: /* CIL Label */ 
    #####: 6916:    no_time = 1;
    #####: 6917:    goto switch_break;
        -: 6918:    case_77: /* CIL Label */ 
    #####: 6919:    no_time = 0;
    #####: 6920:    goto switch_break;
        -: 6921:    case_110: /* CIL Label */ 
    #####: 6922:    no_time = 1;
    #####: 6923:    no_name = no_time;
    #####: 6924:    goto switch_break;
        -: 6925:    case_78: /* CIL Label */ 
    #####: 6926:    no_time = 0;
    #####: 6927:    no_name = no_time;
    #####: 6928:    goto switch_break;
        -: 6929:    case_113: /* CIL Label */ 
    #####: 6930:    quiet = 1;
    #####: 6931:    verbose = 0;
    #####: 6932:    goto switch_break;
        -: 6933:    case_114: /* CIL Label */ 
    #####: 6934:    recursive = 1;
    #####: 6935:    goto switch_break;
        -: 6936:    case_83: /* CIL Label */ 
        -: 6937:    {
    #####: 6938:    tmp___9 = strlen((char const   *)optarg);
    #####: 6939:    z_len = (int )tmp___9;
    #####: 6940:    z_suffix = optarg;
        -: 6941:    }
    #####: 6942:    goto switch_break;
        -: 6943:    case_116: /* CIL Label */ 
    #####: 6944:    to_stdout = 1;
    #####: 6945:    decompress = to_stdout;
    #####: 6946:    test = decompress;
    #####: 6947:    goto switch_break;
        -: 6948:    case_118: /* CIL Label */ 
    #####: 6949:    verbose ++;
    #####: 6950:    quiet = 0;
    #####: 6951:    goto switch_break;
        -: 6952:    case_86: /* CIL Label */ 
        -: 6953:    {
    #####: 6954:    version();
    #####: 6955:    do_exit(0);
        -: 6956:    }
    #####: 6957:    goto switch_break;
        -: 6958:    case_90: /* CIL Label */ 
        -: 6959:    {
    #####: 6960:    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: -Z not supported in this version\n",
    #####: 6961:            progname);
    #####: 6962:    usage();
    #####: 6963:    do_exit(1);
        -: 6964:    }
    #####: 6965:    goto switch_break;
        -: 6966:    case_49: /* CIL Label */ 
        -: 6967:    case_50: /* CIL Label */ 
        -: 6968:    case_51: /* CIL Label */ 
        -: 6969:    case_52: /* CIL Label */ 
        -: 6970:    case_53: /* CIL Label */ 
        -: 6971:    case_54: /* CIL Label */ 
        -: 6972:    case_55: /* CIL Label */ 
        -: 6973:    case_56: /* CIL Label */ 
        -: 6974:    case_57: /* CIL Label */ 
    #####: 6975:    level = optc - 48;
    #####: 6976:    goto switch_break;
        -: 6977:    switch_default: /* CIL Label */ 
        -: 6978:    {
    #####: 6979:    usage();
    #####: 6980:    do_exit(1);
    #####: 6981:    }
        -: 6982:    switch_break: /* CIL Label */ ;
        -: 6983:    }
        -: 6984:  }
        -: 6985:  while_break: /* CIL Label */ ;
        -: 6986:  }
        1: 6987:  if (quiet) {
        -: 6988:    {
    #####: 6989:    tmp___10 = signal(13, (void (*)(int  ))1);
        -: 6990:    }
    #####: 6991:    if ((unsigned long )tmp___10 != (unsigned long )((void (*)(int  ))1)) {
        -: 6992:      {
    #####: 6993:      signal(13, (void (*)(int  ))(& abort_gzip));
        -: 6994:      }
    #####: 6995:    }
    #####: 6996:  }
        1: 6997:  if (no_time < 0) {
        1: 6998:    no_time = decompress;
        1: 6999:  }
        1: 7000:  if (no_name < 0) {
        1: 7001:    no_name = decompress;
        1: 7002:  }
        1: 7003:  file_count = argc - optind;
        1: 7004:  if (ascii) {
    #####: 7005:    if (! quiet) {
        -: 7006:      {
    #####: 7007:      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: option --ascii ignored on this system\n",
    #####: 7008:              progname);
        -: 7009:      }
    #####: 7010:    }
    #####: 7011:  }
        1: 7012:  if (z_len == 0) {
    #####: 7013:    if (! decompress) {
        -: 7014:      {
    #####: 7015:      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: incorrect suffix \'%s\'\n",
    #####: 7016:              progname, optarg);
    #####: 7017:      do_exit(1);
        -: 7018:      }
    #####: 7019:    } else {
    #####: 7020:      goto _L;
        -: 7021:    }
        1: 7022:  } else { //Added block
        -: 7023:  _L: 
        1: 7024:  if (z_len > 30) {
        -: 7025:    {
    #####: 7026:    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: incorrect suffix \'%s\'\n",
    #####: 7027:            progname, optarg);
    #####: 7028:    do_exit(1);
        -: 7029:    }
    #####: 7030:  }
        -: 7031:  }
        1: 7032:  if (do_lzw) {
    #####: 7033:    if (! decompress) {
    #####: 7034:      work = & lzw;
    #####: 7035:    }
    #####: 7036:  }
        1: 7037:  if (file_count != 0) {
        1: 7038:    if (to_stdout) {
        1: 7039:      if (! test) {
        1: 7040:        if (! list) {
        1: 7041:          if (! decompress) {
        1: 7042:            tmp___11 = 1;
        1: 7043:          } else { //Added block
    #####: 7044:          if (! ascii) {
    #####: 7045:            tmp___11 = 1;
    #####: 7046:          } else {
    #####: 7047:            tmp___11 = 0;
        -: 7048:          }
        -: 7049:          }
        1: 7050:        } else {
    #####: 7051:          tmp___11 = 0;
        -: 7052:        }
        1: 7053:      } else {
    #####: 7054:        tmp___11 = 0;
        -: 7055:      }
        1: 7056:    } else {
    #####: 7057:      tmp___11 = 0;
        -: 7058:    }
        -: 7059:    {
        2: 7060:    while (1) {
        -: 7061:      while_continue___0: /* CIL Label */ ;
        2: 7062:      if (! (optind < argc)) {
        1: 7063:        goto while_break___0;
        -: 7064:      }
        -: 7065:      {
        1: 7066:      tmp___12 = optind;
        1: 7067:      optind ++;
        1: 7068:      treat_file(*(argv + tmp___12));
        -: 7069:      }
        -: 7070:    }
        -: 7071:    while_break___0: /* CIL Label */ ;
        -: 7072:    }
        1: 7073:  } else {
        -: 7074:    {
    #####: 7075:    treat_stdin();
        -: 7076:    }
        -: 7077:  }
        1: 7078:  if (list) {
    #####: 7079:    if (! quiet) {
    #####: 7080:      if (file_count > 1) {
        -: 7081:        {
    #####: 7082:        do_list(-1, -1);
        -: 7083:        }
    #####: 7084:      }
    #####: 7085:    }
    #####: 7086:  }
        -: 7087:  {
        1: 7088:  do_exit(exit_code);
        -: 7089:  }
        1: 7090:  return (exit_code);
        -: 7091:}
        -: 7092:}
        1: 7093:static int input_eof(void) 
        -: 7094:{ 
        -: 7095:  int tmp ;
        -: 7096:
        -: 7097:  {
        1: 7098:  if (! decompress) {
        1: 7099:    return (1);
        -: 7100:  } else { //Added block
    #####: 7101:  if (last_member) {
    #####: 7102:    return (1);
        -: 7103:  }
        -: 7104:  }
    #####: 7105:  if (inptr == insize) {
    #####: 7106:    if (insize != 32768U) {
    #####: 7107:      return (1);
        -: 7108:    } else {
        -: 7109:      {
    #####: 7110:      tmp = fill_inbuf(1);
        -: 7111:      }
    #####: 7112:      if (tmp == -1) {
    #####: 7113:        return (1);
        -: 7114:      }
        -: 7115:    }
    #####: 7116:    inptr = 0U;
    #####: 7117:  }
    #####: 7118:  return (0);
        -: 7119:}
        1: 7120:}
    #####: 7121:static void treat_stdin(void) 
        -: 7122:{ 
        -: 7123:  char const   *tmp ;
        -: 7124:  char const   *tmp___0 ;
        -: 7125:  struct _IO_FILE *tmp___1 ;
        -: 7126:  int tmp___2 ;
        -: 7127:  int tmp___3 ;
        -: 7128:  int tmp___4 ;
        -: 7129:  int tmp___5 ;
        -: 7130:  int tmp___6 ;
        -: 7131:  int tmp___7 ;
        -: 7132:  int tmp___8 ;
        -: 7133:  int tmp___9 ;
        -: 7134:  int tmp___10 ;
        -: 7135:  int tmp___11 ;
        -: 7136:
        -: 7137:  {
    #####: 7138:  if (! force) {
    #####: 7139:    if (! list) {
    #####: 7140:      if (decompress) {
    #####: 7141:        tmp___1 = stdin;
    #####: 7142:      } else {
    #####: 7143:        tmp___1 = stdout;
        -: 7144:      }
        -: 7145:      {
    #####: 7146:      tmp___2 = fileno(tmp___1);
    #####: 7147:      tmp___3 = isatty(tmp___2);
        -: 7148:      }
    #####: 7149:      if (tmp___3) {
    #####: 7150:        if (decompress) {
    #####: 7151:          tmp = "de";
    #####: 7152:        } else {
    #####: 7153:          tmp = "";
        -: 7154:        }
    #####: 7155:        if (decompress) {
    #####: 7156:          tmp___0 = "read from";
    #####: 7157:        } else {
    #####: 7158:          tmp___0 = "written to";
        -: 7159:        }
        -: 7160:        {
    #####: 7161:        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: compressed data not %s a terminal. Use -f to force %scompression.\n",
    #####: 7162:                progname, tmp___0, tmp);
    #####: 7163:        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"For help, type: %s -h\n",
    #####: 7164:                progname);
    #####: 7165:        do_exit(1);
        -: 7166:        }
    #####: 7167:      }
    #####: 7168:    }
    #####: 7169:  }
    #####: 7170:  if (decompress) {
    #####: 7171:    tmp___4 = 1;
    #####: 7172:  } else { //Added block
    #####: 7173:  if (! ascii) {
    #####: 7174:    tmp___4 = 1;
    #####: 7175:  } else {
    #####: 7176:    tmp___4 = 0;
        -: 7177:  }
        -: 7178:  }
    #####: 7179:  if (! test) {
    #####: 7180:    if (! list) {
    #####: 7181:      if (! decompress) {
    #####: 7182:        tmp___5 = 1;
    #####: 7183:      } else { //Added block
    #####: 7184:      if (! ascii) {
    #####: 7185:        tmp___5 = 1;
    #####: 7186:      } else {
    #####: 7187:        tmp___5 = 0;
        -: 7188:      }
        -: 7189:      }
    #####: 7190:    } else {
    #####: 7191:      tmp___5 = 0;
        -: 7192:    }
    #####: 7193:  } else {
    #####: 7194:    tmp___5 = 0;
        -: 7195:  }
        -: 7196:  {
    #####: 7197:  strcpy((char * __restrict  )(ifname), (char const   * __restrict  )"stdin");
    #####: 7198:  strcpy((char * __restrict  )(ofname), (char const   * __restrict  )"stdout");
    #####: 7199:  time_stamp = (time_t )0;
        -: 7200:  }
    #####: 7201:  if (list) {
    #####: 7202:    goto _L;
        -: 7203:  } else { //Added block
    #####: 7204:  if (! no_time) {
        -: 7205:    _L: 
        -: 7206:    {
    #####: 7207:    tmp___6 = fileno(stdin);
    #####: 7208:    tmp___7 = fstat(tmp___6, & istat);
        -: 7209:    }
    #####: 7210:    if (tmp___7 != 0) {
        -: 7211:      {
    #####: 7212:      progerror((char *)"standard input");
    #####: 7213:      do_exit(1);
        -: 7214:      }
    #####: 7215:    }
    #####: 7216:    time_stamp = (time_t )0;
    #####: 7217:  }
        -: 7218:  }
        -: 7219:  {
    #####: 7220:  ifile_size = -1L;
    #####: 7221:  clear_bufs();
    #####: 7222:  to_stdout = 1;
    #####: 7223:  part_nb = 0;
        -: 7224:  }
    #####: 7225:  if (decompress) {
        -: 7226:    {
    #####: 7227:    method = get_method(ifd);
        -: 7228:    }
    #####: 7229:    if (method < 0) {
        -: 7230:      {
    #####: 7231:      do_exit(exit_code);
        -: 7232:      }
    #####: 7233:    }
    #####: 7234:  }
    #####: 7235:  if (list) {
        -: 7236:    {
    #####: 7237:    do_list(ifd, method);
        -: 7238:    }
    #####: 7239:    return;
        -: 7240:  }
        -: 7241:  {
    #####: 7242:  while (1) {
        -: 7243:    while_continue: /* CIL Label */ ;
        -: 7244:    {
    #####: 7245:    tmp___8 = fileno(stdout);
    #####: 7246:    tmp___9 = fileno(stdin);
    #####: 7247:    tmp___10 = (*work)(tmp___9, tmp___8);
        -: 7248:    }
    #####: 7249:    if (tmp___10 != 0) {
    #####: 7250:      return;
        -: 7251:    }
        -: 7252:    {
    #####: 7253:    tmp___11 = input_eof();
        -: 7254:    }
    #####: 7255:    if (tmp___11) {
    #####: 7256:      goto while_break;
        -: 7257:    }
        -: 7258:    {
    #####: 7259:    method = get_method(ifd);
        -: 7260:    }
    #####: 7261:    if (method < 0) {
    #####: 7262:      return;
        -: 7263:    }
    #####: 7264:    bytes_out = (off_t )0;
        -: 7265:  }
        -: 7266:  while_break: /* CIL Label */ ;
        -: 7267:  }
    #####: 7268:  if (verbose) {
    #####: 7269:    if (test) {
        -: 7270:      {
    #####: 7271:      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )" OK\n");
        -: 7272:      }
    #####: 7273:    } else { //Added block
    #####: 7274:    if (! decompress) {
        -: 7275:      {
    #####: 7276:      display_ratio(bytes_in - (bytes_out - header_bytes), bytes_in, stderr);
    #####: 7277:      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\n");
        -: 7278:      }
    #####: 7279:    }
        -: 7280:    }
    #####: 7281:  }
    #####: 7282:  return;
        -: 7283:}
    #####: 7284:}
        1: 7285:static void treat_file(char *iname ) 
        -: 7286:{ 
        -: 7287:  int cflag ;
        -: 7288:  int tmp ;
        -: 7289:  int tmp___0 ;
        -: 7290:  struct stat st ;
        -: 7291:  int tmp___1 ;
        -: 7292:  int tmp___2 ;
        -: 7293:  int tmp___3 ;
        -: 7294:  int tmp___4 ;
        -: 7295:  char const   *tmp___7 ;
        -: 7296:  size_t tmp___8 ;
        -: 7297:  char const   *tmp___9 ;
        -: 7298:  size_t tmp___10 ;
        -: 7299:  int tmp___11 ;
        -: 7300:  int tmp___12 ;
        -: 7301:  int tmp___13 ;
        -: 7302:
        -: 7303:  {
        -: 7304:  {
        1: 7305:  tmp = strcmp((char const   *)iname, "-");
        -: 7306:  }
        1: 7307:  if (tmp == 0) {
        -: 7308:    {
    #####: 7309:    cflag = to_stdout;
    #####: 7310:    treat_stdin();
    #####: 7311:    to_stdout = cflag;
        -: 7312:    }
    #####: 7313:    return;
        -: 7314:  }
        -: 7315:  {
        1: 7316:  tmp___0 = get_istat(iname, & istat);
        -: 7317:  }
        1: 7318:  if (tmp___0 != 0) {
    #####: 7319:    return;
        -: 7320:  }
        1: 7321:  if ((istat.st_mode & 61440U) == 16384U) {
    #####: 7322:    if (recursive) {
        -: 7323:      {
    #####: 7324:      st = istat;
    #####: 7325:      treat_dir(iname);
    #####: 7326:      reset_times(iname, & st);
        -: 7327:      }
    #####: 7328:    } else {
    #####: 7329:      if (! quiet) {
        -: 7330:        {
    #####: 7331:        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: %s is a directory -- ignored\n",
    #####: 7332:                progname, ifname);
        -: 7333:        }
    #####: 7334:      }
    #####: 7335:      if (exit_code == 0) {
    #####: 7336:        exit_code = 2;
    #####: 7337:      }
        -: 7338:    }
    #####: 7339:    return;
        -: 7340:  }
        1: 7341:  if (! ((istat.st_mode & 61440U) == 32768U)) {
    #####: 7342:    if (! quiet) {
        -: 7343:      {
    #####: 7344:      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: %s is not a directory or a regular file - ignored\n",
    #####: 7345:              progname, ifname);
        -: 7346:      }
    #####: 7347:    }
    #####: 7348:    if (exit_code == 0) {
    #####: 7349:      exit_code = 2;
    #####: 7350:    }
    #####: 7351:    return;
        -: 7352:  }
        1: 7353:  if (istat.st_nlink > 1UL) {
    #####: 7354:    if (! to_stdout) {
    #####: 7355:      if (! force) {
    #####: 7356:        if (! quiet) {
    #####: 7357:          if (istat.st_nlink > 2UL) {
    #####: 7358:            tmp___1 = 's';
    #####: 7359:          } else {
    #####: 7360:            tmp___1 = ' ';
        -: 7361:          }
        -: 7362:          {
    #####: 7363:          fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: %s has %d other link%c -- unchanged\n",
    #####: 7364:                  progname, ifname, (int )istat.st_nlink - 1, tmp___1);
        -: 7365:          }
    #####: 7366:        }
    #####: 7367:        if (exit_code == 0) {
    #####: 7368:          exit_code = 2;
    #####: 7369:        }
    #####: 7370:        return;
        -: 7371:      }
    #####: 7372:    }
    #####: 7373:  }
        1: 7374:  ifile_size = istat.st_size;
        1: 7375:  time_stamp = (time_t )0;
        1: 7376:  if (to_stdout) {
        1: 7377:    if (! list) {
        1: 7378:      if (! test) {
        -: 7379:        {
        1: 7380:        strcpy((char * __restrict  )(ofname), (char const   * __restrict  )"stdout");
        -: 7381:        }
        1: 7382:      } else {
    #####: 7383:        goto _L___0;
        -: 7384:      }
        1: 7385:    } else {
    #####: 7386:      goto _L___0;
        -: 7387:    }
        1: 7388:  } else {
        -: 7389:    _L___0: 
        -: 7390:    {
    #####: 7391:    tmp___2 = make_ofname();
        -: 7392:    }
    #####: 7393:    if (tmp___2 != 0) {
    #####: 7394:      return;
        -: 7395:    }
        -: 7396:  }
        1: 7397:  if (ascii) {
    #####: 7398:    if (! decompress) {
    #####: 7399:      tmp___3 = 0;
    #####: 7400:    } else {
    #####: 7401:      tmp___3 = 0;
        -: 7402:    }
    #####: 7403:  } else {
        1: 7404:    tmp___3 = 0;
        -: 7405:  }
        -: 7406:  {
        1: 7407:  ifd = open((char const   *)(ifname), tmp___3, 384);
        -: 7408:  }
        1: 7409:  if (ifd == -1) {
        -: 7410:    {
    #####: 7411:    progerror(ifname);
        -: 7412:    }
    #####: 7413:    return;
        -: 7414:  }
        -: 7415:  {
        1: 7416:  clear_bufs();
        1: 7417:  part_nb = 0;
        -: 7418:  }
        1: 7419:  if (decompress) {
        -: 7420:    {
    #####: 7421:    method = get_method(ifd);
        -: 7422:    }
    #####: 7423:    if (method < 0) {
        -: 7424:      {
    #####: 7425:      close(ifd);
        -: 7426:      }
    #####: 7427:      return;
        -: 7428:    }
    #####: 7429:  }
        1: 7430:  if (list) {
        -: 7431:    {
    #####: 7432:    do_list(ifd, method);
    #####: 7433:    close(ifd);
        -: 7434:    }
    #####: 7435:    return;
        -: 7436:  }
        1: 7437:  if (to_stdout) {
        -: 7438:    {
        1: 7439:    ofd = fileno(stdout);
        -: 7440:    }
        1: 7441:  } else {
        -: 7442:    {
    #####: 7443:    tmp___4 = create_outfile();
        -: 7444:    }
    #####: 7445:    if (tmp___4 != 0) {
    #####: 7446:      return;
        -: 7447:    }
    #####: 7448:    if (! decompress) {
    #####: 7449:      if (save_orig_name) {
    #####: 7450:        if (! verbose) {
    #####: 7451:          if (! quiet) {
        -: 7452:            {
    #####: 7453:            fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: %s compressed to %s\n",
    #####: 7454:                    progname, ifname, ofname);
        -: 7455:            }
    #####: 7456:          }
    #####: 7457:        }
    #####: 7458:      }
    #####: 7459:    }
        -: 7460:  }
        1: 7461:  if (! save_orig_name) {
        1: 7462:    save_orig_name = ! no_name;
        1: 7463:  }
        1: 7464:  if (verbose) {
        -: 7465:    {
    #####: 7466:    tmp___10 = strlen((char const   *)(ifname));
        -: 7467:    }
    #####: 7468:    if ((int )tmp___10 >= 15) {
    #####: 7469:      tmp___9 = "";
    #####: 7470:    } else {
        -: 7471:      {
    #####: 7472:      tmp___8 = strlen((char const   *)(ifname));
        -: 7473:      }
    #####: 7474:      if ((int )tmp___8 >= 7) {
    #####: 7475:        tmp___7 = "\t";
    #####: 7476:      } else {
    #####: 7477:        tmp___7 = "\t\t";
        -: 7478:      }
    #####: 7479:      tmp___9 = tmp___7;
        -: 7480:    }
        -: 7481:    {
    #####: 7482:    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s:\t%s", ifname,
    #####: 7483:            tmp___9);
        -: 7484:    }
    #####: 7485:  }
        -: 7486:  {
        1: 7487:  while (1) {
        -: 7488:    while_continue: /* CIL Label */ ;
        -: 7489:    {
        1: 7490:    tmp___11 = (*work)(ifd, ofd);
        -: 7491:    }
        1: 7492:    if (tmp___11 != 0) {
    #####: 7493:      method = -1;
    #####: 7494:      goto while_break;
        -: 7495:    }
        -: 7496:    {
        1: 7497:    tmp___12 = input_eof();
        -: 7498:    }
        1: 7499:    if (tmp___12) {
        1: 7500:      goto while_break;
        -: 7501:    }
        -: 7502:    {
    #####: 7503:    method = get_method(ifd);
        -: 7504:    }
    #####: 7505:    if (method < 0) {
    #####: 7506:      goto while_break;
        -: 7507:    }
    #####: 7508:    bytes_out = (off_t )0;
        -: 7509:  }
        -: 7510:  while_break: /* CIL Label */ ;
        -: 7511:  }
        -: 7512:  {
        1: 7513:  close(ifd);
        -: 7514:  }
        1: 7515:  if (! to_stdout) {
        -: 7516:    {
    #####: 7517:    tmp___13 = close(ofd);
        -: 7518:    }
    #####: 7519:    if (tmp___13) {
        -: 7520:      {
    #####: 7521:      write_error();
        -: 7522:      }
    #####: 7523:    }
    #####: 7524:  }
        1: 7525:  if (method == -1) {
    #####: 7526:    if (! to_stdout) {
        -: 7527:      {
    #####: 7528:      xunlink(ofname);
        -: 7529:      }
    #####: 7530:    }
    #####: 7531:    return;
        -: 7532:  }
        1: 7533:  if (verbose) {
    #####: 7534:    if (test) {
        -: 7535:      {
    #####: 7536:      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )" OK");
        -: 7537:      }
    #####: 7538:    } else { //Added block
    #####: 7539:    if (decompress) {
        -: 7540:      {
    #####: 7541:      display_ratio(bytes_out - (bytes_in - header_bytes), bytes_out, stderr);
        -: 7542:      }
    #####: 7543:    } else {
        -: 7544:      {
    #####: 7545:      display_ratio(bytes_in - (bytes_out - header_bytes), bytes_in, stderr);
        -: 7546:      }
        -: 7547:    }
        -: 7548:    }
    #####: 7549:    if (! test) {
    #####: 7550:      if (! to_stdout) {
        -: 7551:        {
    #####: 7552:        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )" -- replaced with %s",
        -: 7553:                ofname);
        -: 7554:        }
    #####: 7555:      }
    #####: 7556:    }
        -: 7557:    {
    #####: 7558:    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\n");
        -: 7559:    }
    #####: 7560:  }
        1: 7561:  if (! to_stdout) {
        -: 7562:    {
    #####: 7563:    copy_stat(& istat);
        -: 7564:    }
    #####: 7565:  }
        1: 7566:  return;
        -: 7567:}
        1: 7568:}
    #####: 7569:static int create_outfile(void) 
        -: 7570:{ 
        -: 7571:  struct stat ostat ;
        -: 7572:  int flags___0 ;
        -: 7573:  int tmp ;
        -: 7574:  int tmp___0 ;
        -: 7575:  int tmp___1 ;
        -: 7576:
        -: 7577:  {
    #####: 7578:  flags___0 = 193;
    #####: 7579:  if (ascii) {
    #####: 7580:    if (decompress) {
    #####: 7581:      flags___0 &= -1;
    #####: 7582:    }
    #####: 7583:  }
        -: 7584:  {
    #####: 7585:  while (1) {
        -: 7586:    while_continue: /* CIL Label */ ;
        -: 7587:    {
    #####: 7588:    tmp = check_ofname();
        -: 7589:    }
    #####: 7590:    if (tmp != 0) {
        -: 7591:      {
    #####: 7592:      close(ifd);
        -: 7593:      }
    #####: 7594:      return (1);
        -: 7595:    }
        -: 7596:    {
    #####: 7597:    remove_ofname = 1;
    #####: 7598:    ofd = open((char const   *)(ofname), flags___0, 384);
        -: 7599:    }
    #####: 7600:    if (ofd == -1) {
        -: 7601:      {
    #####: 7602:      progerror(ofname);
    #####: 7603:      close(ifd);
        -: 7604:      }
    #####: 7605:      return (1);
        -: 7606:    }
        -: 7607:    {
    #####: 7608:    tmp___0 = fstat(ofd, & ostat);
        -: 7609:    }
    #####: 7610:    if (tmp___0 != 0) {
        -: 7611:      {
    #####: 7612:      progerror(ofname);
    #####: 7613:      close(ifd);
    #####: 7614:      close(ofd);
    #####: 7615:      xunlink(ofname);
        -: 7616:      }
    #####: 7617:      return (1);
        -: 7618:    }
        -: 7619:    {
    #####: 7620:    tmp___1 = name_too_long(ofname, & ostat);
        -: 7621:    }
    #####: 7622:    if (! tmp___1) {
    #####: 7623:      return (0);
        -: 7624:    }
    #####: 7625:    if (decompress) {
    #####: 7626:      if (! quiet) {
        -: 7627:        {
    #####: 7628:        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: %s: warning, name truncated\n",
    #####: 7629:                progname, ofname);
        -: 7630:        }
    #####: 7631:      }
    #####: 7632:      if (exit_code == 0) {
    #####: 7633:        exit_code = 2;
    #####: 7634:      }
    #####: 7635:      return (0);
        -: 7636:    }
        -: 7637:    {
    #####: 7638:    close(ofd);
    #####: 7639:    xunlink(ofname);
    #####: 7640:    shorten_name(ofname);
        -: 7641:    }
        -: 7642:  }
        -: 7643:  while_break: /* CIL Label */ ;
        -: 7644:  }
        -: 7645:}
    #####: 7646:}
        1: 7647:static int do_stat(char *name , struct stat *sbuf ) 
        -: 7648:{ 
        -: 7649:  int *tmp ;
        -: 7650:  int tmp___0 ;
        -: 7651:
        -: 7652:  {
        -: 7653:  {
        1: 7654:  tmp = __errno_location();
        1: 7655:  *tmp = 0;
        1: 7656:  tmp___0 = stat((char const   * __restrict  )name, (struct stat * __restrict  )sbuf);
        -: 7657:  }
        1: 7658:  return (tmp___0);
        -: 7659:}
        -: 7660:}
        -: 7661:static char *known_suffixes[9]  = 
        -: 7662:  {      (char *)((void *)0),      (char *)".gz",      (char *)".z",      (char *)".taz", 
        -: 7663:        (char *)".tgz",      (char *)"-gz",      (char *)"-z",      (char *)"_z", 
        -: 7664:        (char *)((void *)0)};
    #####: 7665:static char *get_suffix(char *name ) 
        -: 7666:{ 
        -: 7667:  int nlen ;
        -: 7668:  int slen ;
        -: 7669:  char suffix[33] ;
        -: 7670:  char **suf ;
        -: 7671:  int tmp ;
        -: 7672:  size_t tmp___0 ;
        -: 7673:  size_t tmp___1 ;
        -: 7674:  int s ;
        -: 7675:  size_t tmp___2 ;
        -: 7676:  int tmp___3 ;
        -: 7677:
        -: 7678:  {
        -: 7679:  {
    #####: 7680:  suf = known_suffixes;
    #####: 7681:  *suf = z_suffix;
    #####: 7682:  tmp = strcmp((char const   *)z_suffix, "z");
        -: 7683:  }
    #####: 7684:  if (tmp == 0) {
    #####: 7685:    suf ++;
    #####: 7686:  }
        -: 7687:  {
    #####: 7688:  tmp___0 = strlen((char const   *)name);
    #####: 7689:  nlen = (int )tmp___0;
        -: 7690:  }
    #####: 7691:  if (nlen <= 32) {
        -: 7692:    {
    #####: 7693:    strcpy((char * __restrict  )(suffix), (char const   * __restrict  )name);
        -: 7694:    }
    #####: 7695:  } else {
        -: 7696:    {
    #####: 7697:    strcpy((char * __restrict  )(suffix), (char const   * __restrict  )(((name + nlen) - 30) - 2));
        -: 7698:    }
        -: 7699:  }
        -: 7700:  {
    #####: 7701:  strlwr(suffix);
    #####: 7702:  tmp___1 = strlen((char const   *)(suffix));
    #####: 7703:  slen = (int )tmp___1;
        -: 7704:  }
        -: 7705:  {
    #####: 7706:  while (1) {
        -: 7707:    while_continue: /* CIL Label */ ;
        -: 7708:    {
    #####: 7709:    tmp___2 = strlen((char const   *)*suf);
    #####: 7710:    s = (int )tmp___2;
        -: 7711:    }
    #####: 7712:    if (slen > s) {
    #####: 7713:      if ((int )suffix[(slen - s) - 1] != 47) {
        -: 7714:        {
    #####: 7715:        tmp___3 = strcmp((char const   *)((suffix + slen) - s), (char const   *)*suf);
        -: 7716:        }
    #####: 7717:        if (tmp___3 == 0) {
    #####: 7718:          return ((name + nlen) - s);
        -: 7719:        }
    #####: 7720:      }
    #####: 7721:    }
    #####: 7722:    suf ++;
    #####: 7723:    if (! ((unsigned long )*suf != (unsigned long )((void *)0))) {
    #####: 7724:      goto while_break;
        -: 7725:    }
        -: 7726:  }
        -: 7727:  while_break: /* CIL Label */ ;
        -: 7728:  }
    #####: 7729:  return ((char *)((void *)0));
        -: 7730:}
    #####: 7731:}
        -: 7732:static char *suffixes[6]  = {      (char *)((void *)0),      (char *)".gz",      (char *)".z",      (char *)"-z", 
        -: 7733:        (char *)".Z",      (char *)((void *)0)};
        1: 7734:static int get_istat(char *iname , struct stat *sbuf ) 
        -: 7735:{ 
        -: 7736:  int ilen ;
        -: 7737:  int z_suffix_errno ;
        -: 7738:  char **suf ;
        -: 7739:  char *s ;
        -: 7740:  size_t tmp ;
        -: 7741:  int tmp___0 ;
        -: 7742:  int *tmp___1 ;
        -: 7743:  size_t tmp___2 ;
        -: 7744:  int tmp___3 ;
        -: 7745:  char *s0 ;
        -: 7746:  size_t tmp___4 ;
        -: 7747:  int tmp___5 ;
        -: 7748:  int *tmp___6 ;
        -: 7749:  int tmp___7 ;
        -: 7750:  int *tmp___8 ;
        -: 7751:
        -: 7752:  {
        -: 7753:  {
        1: 7754:  z_suffix_errno = 0;
        1: 7755:  suf = suffixes;
        1: 7756:  *suf = z_suffix;
        1: 7757:  tmp = strlen((char const   *)iname);
        -: 7758:  }
        1: 7759:  if (sizeof(ifname) - 1UL <= tmp) {
    #####: 7760:    goto name_too_long;
        -: 7761:  }
        -: 7762:  {
        1: 7763:  strcpy((char * __restrict  )(ifname), (char const   * __restrict  )iname);
        1: 7764:  tmp___0 = do_stat(ifname, sbuf);
        -: 7765:  }
        1: 7766:  if (tmp___0 == 0) {
        1: 7767:    return (0);
        -: 7768:  }
    #####: 7769:  if (! decompress) {
        -: 7770:    {
    #####: 7771:    progerror(ifname);
        -: 7772:    }
    #####: 7773:    return (1);
        -: 7774:  } else {
        -: 7775:    {
    #####: 7776:    tmp___1 = __errno_location();
        -: 7777:    }
    #####: 7778:    if (*tmp___1 != 2) {
        -: 7779:      {
    #####: 7780:      progerror(ifname);
        -: 7781:      }
    #####: 7782:      return (1);
        -: 7783:    }
        -: 7784:  }
        -: 7785:  {
    #####: 7786:  s = get_suffix(ifname);
        -: 7787:  }
    #####: 7788:  if ((unsigned long )s != (unsigned long )((void *)0)) {
        -: 7789:    {
    #####: 7790:    progerror(ifname);
        -: 7791:    }
    #####: 7792:    return (1);
        -: 7793:  }
        -: 7794:  {
    #####: 7795:  tmp___2 = strlen((char const   *)(ifname));
    #####: 7796:  ilen = (int )tmp___2;
    #####: 7797:  tmp___3 = strcmp((char const   *)z_suffix, ".gz");
        -: 7798:  }
    #####: 7799:  if (tmp___3 == 0) {
    #####: 7800:    suf ++;
    #####: 7801:  }
        -: 7802:  {
    #####: 7803:  while (1) {
        -: 7804:    while_continue: /* CIL Label */ ;
        -: 7805:    {
    #####: 7806:    s = *suf;
    #####: 7807:    s0 = s;
    #####: 7808:    strcpy((char * __restrict  )(ifname), (char const   * __restrict  )iname);
    #####: 7809:    tmp___4 = strlen((char const   *)s);
        -: 7810:    }
    #####: 7811:    if (sizeof(ifname) <= (size_t )ilen + tmp___4) {
    #####: 7812:      goto name_too_long;
        -: 7813:    }
        -: 7814:    {
    #####: 7815:    strcat((char * __restrict  )(ifname), (char const   * __restrict  )s);
    #####: 7816:    tmp___5 = do_stat(ifname, sbuf);
        -: 7817:    }
    #####: 7818:    if (tmp___5 == 0) {
    #####: 7819:      return (0);
        -: 7820:    }
        -: 7821:    {
    #####: 7822:    tmp___7 = strcmp((char const   *)s0, (char const   *)z_suffix);
        -: 7823:    }
    #####: 7824:    if (tmp___7 == 0) {
        -: 7825:      {
    #####: 7826:      tmp___6 = __errno_location();
    #####: 7827:      z_suffix_errno = *tmp___6;
        -: 7828:      }
    #####: 7829:    }
    #####: 7830:    suf ++;
    #####: 7831:    if (! ((unsigned long )*suf != (unsigned long )((void *)0))) {
    #####: 7832:      goto while_break;
        -: 7833:    }
        -: 7834:  }
        -: 7835:  while_break: /* CIL Label */ ;
        -: 7836:  }
        -: 7837:  {
    #####: 7838:  strcpy((char * __restrict  )(ifname), (char const   * __restrict  )iname);
    #####: 7839:  strcat((char * __restrict  )(ifname), (char const   * __restrict  )z_suffix);
    #####: 7840:  tmp___8 = __errno_location();
    #####: 7841:  *tmp___8 = z_suffix_errno;
    #####: 7842:  progerror(ifname);
        -: 7843:  }
    #####: 7844:  return (1);
        -: 7845:  name_too_long: 
        -: 7846:  {
    #####: 7847:  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: %s: file name too long\n",
    #####: 7848:          progname, iname);
    #####: 7849:  exit_code = 1;
        -: 7850:  }
    #####: 7851:  return (1);
        -: 7852:}
        1: 7853:}
    #####: 7854:static int make_ofname(void) 
        -: 7855:{ 
        -: 7856:  char *suff ;
        -: 7857:  int tmp ;
        -: 7858:  int tmp___0 ;
        -: 7859:  size_t tmp___1 ;
        -: 7860:
        -: 7861:  {
        -: 7862:  {
    #####: 7863:  strcpy((char * __restrict  )(ofname), (char const   * __restrict  )(ifname));
    #####: 7864:  suff = get_suffix(ofname);
        -: 7865:  }
    #####: 7866:  if (decompress) {
    #####: 7867:    if ((unsigned long )suff == (unsigned long )((void *)0)) {
    #####: 7868:      if (! recursive) {
    #####: 7869:        if (list) {
    #####: 7870:          return (0);
        -: 7871:        } else { //Added block
    #####: 7872:        if (test) {
    #####: 7873:          return (0);
        -: 7874:        }
        -: 7875:        }
    #####: 7876:      }
    #####: 7877:      if (verbose) {
    #####: 7878:        goto _L;
        -: 7879:      } else { //Added block
    #####: 7880:      if (! recursive) {
    #####: 7881:        if (! quiet) {
        -: 7882:          _L: 
    #####: 7883:          if (! quiet) {
        -: 7884:            {
    #####: 7885:            fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: %s: unknown suffix -- ignored\n",
    #####: 7886:                    progname, ifname);
        -: 7887:            }
    #####: 7888:          }
    #####: 7889:          if (exit_code == 0) {
    #####: 7890:            exit_code = 2;
    #####: 7891:          }
    #####: 7892:        }
    #####: 7893:      }
        -: 7894:      }
    #####: 7895:      return (2);
        -: 7896:    }
        -: 7897:    {
    #####: 7898:    strlwr(suff);
    #####: 7899:    tmp = strcmp((char const   *)suff, ".tgz");
        -: 7900:    }
    #####: 7901:    if (tmp == 0) {
        -: 7902:      {
    #####: 7903:      strcpy((char * __restrict  )suff, (char const   * __restrict  )".tar");
        -: 7904:      }
    #####: 7905:    } else {
        -: 7906:      {
    #####: 7907:      tmp___0 = strcmp((char const   *)suff, ".taz");
        -: 7908:      }
    #####: 7909:      if (tmp___0 == 0) {
        -: 7910:        {
    #####: 7911:        strcpy((char * __restrict  )suff, (char const   * __restrict  )".tar");
        -: 7912:        }
    #####: 7913:      } else {
    #####: 7914:        *suff = (char )'\000';
        -: 7915:      }
        -: 7916:    }
    #####: 7917:  } else { //Added block
    #####: 7918:  if ((unsigned long )suff != (unsigned long )((void *)0)) {
    #####: 7919:    if (verbose) {
        -: 7920:      {
    #####: 7921:      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: %s already has %s suffix -- unchanged\n",
    #####: 7922:              progname, ifname, suff);
        -: 7923:      }
    #####: 7924:    } else { //Added block
    #####: 7925:    if (! recursive) {
    #####: 7926:      if (! quiet) {
        -: 7927:        {
    #####: 7928:        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: %s already has %s suffix -- unchanged\n",
    #####: 7929:                progname, ifname, suff);
        -: 7930:        }
    #####: 7931:      }
    #####: 7932:    }
        -: 7933:    }
    #####: 7934:    if (exit_code == 0) {
    #####: 7935:      exit_code = 2;
    #####: 7936:    }
    #####: 7937:    return (2);
        -: 7938:  } else {
        -: 7939:    {
    #####: 7940:    save_orig_name = 0;
    #####: 7941:    tmp___1 = strlen((char const   *)(ofname));
        -: 7942:    }
    #####: 7943:    if (sizeof(ofname) <= tmp___1 + (size_t )z_len) {
    #####: 7944:      goto name_too_long;
        -: 7945:    }
        -: 7946:    {
    #####: 7947:    strcat((char * __restrict  )(ofname), (char const   * __restrict  )z_suffix);
        -: 7948:    }
        -: 7949:  }
        -: 7950:  }
    #####: 7951:  return (0);
        -: 7952:  name_too_long: 
    #####: 7953:  if (! quiet) {
        -: 7954:    {
    #####: 7955:    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: %s: file name too long\n",
    #####: 7956:            progname, ifname);
        -: 7957:    }
    #####: 7958:  }
    #####: 7959:  if (exit_code == 0) {
    #####: 7960:    exit_code = 2;
    #####: 7961:  }
    #####: 7962:  return (2);
        -: 7963:}
    #####: 7964:}
    #####: 7965:static int get_method(int in ) 
        -: 7966:{ 
        -: 7967:  uch flags___0 ;
        -: 7968:  char magic[2] ;
        -: 7969:  int imagic1 ;
        -: 7970:  ulg stamp ;
        -: 7971:  unsigned int tmp ;
        -: 7972:  int tmp___0 ;
        -: 7973:  int tmp___1 ;
        -: 7974:  unsigned int tmp___2 ;
        -: 7975:  int tmp___3 ;
        -: 7976:  unsigned int tmp___4 ;
        -: 7977:  int tmp___5 ;
        -: 7978:  int tmp___6 ;
        -: 7979:  unsigned int tmp___7 ;
        -: 7980:  int tmp___8 ;
        -: 7981:  int tmp___9 ;
        -: 7982:  unsigned int tmp___10 ;
        -: 7983:  int tmp___11 ;
        -: 7984:  int tmp___12 ;
        -: 7985:  unsigned int tmp___13 ;
        -: 7986:  int tmp___14 ;
        -: 7987:  int tmp___15 ;
        -: 7988:  unsigned int tmp___16 ;
        -: 7989:  int tmp___17 ;
        -: 7990:  int tmp___18 ;
        -: 7991:  unsigned int tmp___19 ;
        -: 7992:  int tmp___20 ;
        -: 7993:  int tmp___21 ;
        -: 7994:  unsigned int tmp___22 ;
        -: 7995:  int tmp___23 ;
        -: 7996:  int tmp___24 ;
        -: 7997:  unsigned int tmp___25 ;
        -: 7998:  int tmp___26 ;
        -: 7999:  int tmp___27 ;
        -: 8000:  unsigned int tmp___28 ;
        -: 8001:  unsigned int tmp___29 ;
        -: 8002:  unsigned int part ;
        -: 8003:  unsigned int tmp___30 ;
        -: 8004:  int tmp___31 ;
        -: 8005:  int tmp___32 ;
        -: 8006:  unsigned int tmp___33 ;
        -: 8007:  int tmp___34 ;
        -: 8008:  int tmp___35 ;
        -: 8009:  unsigned int len ;
        -: 8010:  unsigned int tmp___36 ;
        -: 8011:  int tmp___37 ;
        -: 8012:  int tmp___38 ;
        -: 8013:  unsigned int tmp___39 ;
        -: 8014:  int tmp___40 ;
        -: 8015:  int tmp___41 ;
        -: 8016:  unsigned int tmp___42 ;
        -: 8017:  unsigned int tmp___43 ;
        -: 8018:  char c ;
        -: 8019:  unsigned int tmp___44 ;
        -: 8020:  int tmp___45 ;
        -: 8021:  char *p ;
        -: 8022:  char *tmp___46 ;
        -: 8023:  char *base ;
        -: 8024:  unsigned int tmp___47 ;
        -: 8025:  int tmp___48 ;
        -: 8026:  int tmp___49 ;
        -: 8027:  char *tmp___50 ;
        -: 8028:  unsigned int tmp___51 ;
        -: 8029:  int tmp___52 ;
        -: 8030:  int tmp___53 ;
        -: 8031:  int tmp___54 ;
        -: 8032:  int tmp___55 ;
        -: 8033:  int tmp___56 ;
        -: 8034:  int tmp___57 ;
        -: 8035:  int tmp___58 ;
        -: 8036:  int tmp___59 ;
        -: 8037:  int tmp___60 ;
        -: 8038:  int tmp___61 ;
        -: 8039:  int inbyte ;
        -: 8040:  unsigned int tmp___62 ;
        -: 8041:  int tmp___63 ;
        -: 8042:
        -: 8043:  {
    #####: 8044:  if (force) {
    #####: 8045:    if (to_stdout) {
    #####: 8046:      if (inptr < insize) {
    #####: 8047:        tmp = inptr;
    #####: 8048:        inptr ++;
    #####: 8049:        tmp___1 = (int )inbuf[tmp];
    #####: 8050:      } else {
        -: 8051:        {
    #####: 8052:        tmp___0 = fill_inbuf(1);
    #####: 8053:        tmp___1 = tmp___0;
        -: 8054:        }
        -: 8055:      }
    #####: 8056:      magic[0] = (char )tmp___1;
    #####: 8057:      if (inptr < insize) {
    #####: 8058:        tmp___2 = inptr;
    #####: 8059:        inptr ++;
    #####: 8060:        imagic1 = (int )inbuf[tmp___2];
    #####: 8061:      } else {
        -: 8062:        {
    #####: 8063:        tmp___3 = fill_inbuf(1);
    #####: 8064:        imagic1 = tmp___3;
        -: 8065:        }
        -: 8066:      }
    #####: 8067:      magic[1] = (char )imagic1;
    #####: 8068:    } else {
    #####: 8069:      goto _L;
        -: 8070:    }
    #####: 8071:  } else {
        -: 8072:    _L: 
    #####: 8073:    if (inptr < insize) {
    #####: 8074:      tmp___4 = inptr;
    #####: 8075:      inptr ++;
    #####: 8076:      tmp___6 = (int )inbuf[tmp___4];
    #####: 8077:    } else {
        -: 8078:      {
    #####: 8079:      tmp___5 = fill_inbuf(0);
    #####: 8080:      tmp___6 = tmp___5;
        -: 8081:      }
        -: 8082:    }
    #####: 8083:    magic[0] = (char )tmp___6;
    #####: 8084:    if (inptr < insize) {
    #####: 8085:      tmp___7 = inptr;
    #####: 8086:      inptr ++;
    #####: 8087:      tmp___9 = (int )inbuf[tmp___7];
    #####: 8088:    } else {
        -: 8089:      {
    #####: 8090:      tmp___8 = fill_inbuf(0);
    #####: 8091:      tmp___9 = tmp___8;
        -: 8092:      }
        -: 8093:    }
    #####: 8094:    magic[1] = (char )tmp___9;
    #####: 8095:    imagic1 = 0;
        -: 8096:  }
        -: 8097:  {
    #####: 8098:  method = -1;
    #####: 8099:  part_nb ++;
    #####: 8100:  header_bytes = (off_t )0;
    #####: 8101:  last_member = 0;
    #####: 8102:  tmp___60 = memcmp((void const   *)(magic), (void const   *)"\037\213", (size_t )2);
        -: 8103:  }
    #####: 8104:  if (tmp___60 == 0) {
    #####: 8105:    goto _L___4;
        -: 8106:  } else {
        -: 8107:    {
    #####: 8108:    tmp___61 = memcmp((void const   *)(magic), (void const   *)"\037\236", (size_t )2);
        -: 8109:    }
    #####: 8110:    if (tmp___61 == 0) {
        -: 8111:      _L___4: 
    #####: 8112:      if (inptr < insize) {
    #####: 8113:        tmp___10 = inptr;
    #####: 8114:        inptr ++;
    #####: 8115:        tmp___12 = (int )inbuf[tmp___10];
    #####: 8116:      } else {
        -: 8117:        {
    #####: 8118:        tmp___11 = fill_inbuf(0);
    #####: 8119:        tmp___12 = tmp___11;
        -: 8120:        }
        -: 8121:      }
    #####: 8122:      method = tmp___12;
    #####: 8123:      if (method != 8) {
        -: 8124:        {
    #####: 8125:        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: %s: unknown method %d -- get newer version of gzip\n",
    #####: 8126:                progname, ifname, method);
    #####: 8127:        exit_code = 1;
        -: 8128:        }
    #####: 8129:        return (-1);
        -: 8130:      }
    #####: 8131:      work = & unzip;
    #####: 8132:      if (inptr < insize) {
    #####: 8133:        tmp___13 = inptr;
    #####: 8134:        inptr ++;
    #####: 8135:        tmp___15 = (int )inbuf[tmp___13];
    #####: 8136:      } else {
        -: 8137:        {
    #####: 8138:        tmp___14 = fill_inbuf(0);
    #####: 8139:        tmp___15 = tmp___14;
        -: 8140:        }
        -: 8141:      }
    #####: 8142:      flags___0 = (uch )tmp___15;
    #####: 8143:      if (((int )flags___0 & 32) != 0) {
        -: 8144:        {
    #####: 8145:        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: %s is encrypted -- get newer version of gzip\n",
    #####: 8146:                progname, ifname);
    #####: 8147:        exit_code = 1;
        -: 8148:        }
    #####: 8149:        return (-1);
        -: 8150:      }
    #####: 8151:      if (((int )flags___0 & 2) != 0) {
        -: 8152:        {
    #####: 8153:        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: %s is a a multi-part gzip file -- get newer version of gzip\n",
    #####: 8154:                progname, ifname);
    #####: 8155:        exit_code = 1;
        -: 8156:        }
    #####: 8157:        if (force <= 1) {
    #####: 8158:          return (-1);
        -: 8159:        }
    #####: 8160:      }
    #####: 8161:      if (((int )flags___0 & 192) != 0) {
        -: 8162:        {
    #####: 8163:        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: %s has flags 0x%x -- get newer version of gzip\n",
    #####: 8164:                progname, ifname, (int )flags___0);
    #####: 8165:        exit_code = 1;
        -: 8166:        }
    #####: 8167:        if (force <= 1) {
    #####: 8168:          return (-1);
        -: 8169:        }
    #####: 8170:      }
    #####: 8171:      if (inptr < insize) {
    #####: 8172:        tmp___16 = inptr;
    #####: 8173:        inptr ++;
    #####: 8174:        tmp___18 = (int )inbuf[tmp___16];
    #####: 8175:      } else {
        -: 8176:        {
    #####: 8177:        tmp___17 = fill_inbuf(0);
    #####: 8178:        tmp___18 = tmp___17;
        -: 8179:        }
        -: 8180:      }
    #####: 8181:      stamp = (ulg )tmp___18;
    #####: 8182:      if (inptr < insize) {
    #####: 8183:        tmp___19 = inptr;
    #####: 8184:        inptr ++;
    #####: 8185:        tmp___21 = (int )inbuf[tmp___19];
    #####: 8186:      } else {
        -: 8187:        {
    #####: 8188:        tmp___20 = fill_inbuf(0);
    #####: 8189:        tmp___21 = tmp___20;
        -: 8190:        }
        -: 8191:      }
    #####: 8192:      stamp |= (ulg )tmp___21 << 8;
    #####: 8193:      if (inptr < insize) {
    #####: 8194:        tmp___22 = inptr;
    #####: 8195:        inptr ++;
    #####: 8196:        tmp___24 = (int )inbuf[tmp___22];
    #####: 8197:      } else {
        -: 8198:        {
    #####: 8199:        tmp___23 = fill_inbuf(0);
    #####: 8200:        tmp___24 = tmp___23;
        -: 8201:        }
        -: 8202:      }
    #####: 8203:      stamp |= (ulg )tmp___24 << 16;
    #####: 8204:      if (inptr < insize) {
    #####: 8205:        tmp___25 = inptr;
    #####: 8206:        inptr ++;
    #####: 8207:        tmp___27 = (int )inbuf[tmp___25];
    #####: 8208:      } else {
        -: 8209:        {
    #####: 8210:        tmp___26 = fill_inbuf(0);
    #####: 8211:        tmp___27 = tmp___26;
        -: 8212:        }
        -: 8213:      }
    #####: 8214:      stamp |= (ulg )tmp___27 << 24;
    #####: 8215:      if (stamp != 0UL) {
    #####: 8216:        if (! no_time) {
    #####: 8217:          time_stamp = (time_t )stamp;
    #####: 8218:        }
    #####: 8219:      }
    #####: 8220:      time_stamp = (time_t )0;
    #####: 8221:      if (inptr < insize) {
    #####: 8222:        tmp___28 = inptr;
    #####: 8223:        inptr ++;
    #####: 8224:      } else {
        -: 8225:        {
    #####: 8226:        fill_inbuf(0);
        -: 8227:        }
        -: 8228:      }
    #####: 8229:      if (inptr < insize) {
    #####: 8230:        tmp___29 = inptr;
    #####: 8231:        inptr ++;
    #####: 8232:      } else {
        -: 8233:        {
    #####: 8234:        fill_inbuf(0);
        -: 8235:        }
        -: 8236:      }
    #####: 8237:      if (((int )flags___0 & 2) != 0) {
    #####: 8238:        if (inptr < insize) {
    #####: 8239:          tmp___30 = inptr;
    #####: 8240:          inptr ++;
    #####: 8241:          tmp___32 = (int )inbuf[tmp___30];
    #####: 8242:        } else {
        -: 8243:          {
    #####: 8244:          tmp___31 = fill_inbuf(0);
    #####: 8245:          tmp___32 = tmp___31;
        -: 8246:          }
        -: 8247:        }
    #####: 8248:        part = (unsigned int )tmp___32;
    #####: 8249:        if (inptr < insize) {
    #####: 8250:          tmp___33 = inptr;
    #####: 8251:          inptr ++;
    #####: 8252:          tmp___35 = (int )inbuf[tmp___33];
    #####: 8253:        } else {
        -: 8254:          {
    #####: 8255:          tmp___34 = fill_inbuf(0);
    #####: 8256:          tmp___35 = tmp___34;
        -: 8257:          }
        -: 8258:        }
    #####: 8259:        part |= (unsigned int )tmp___35 << 8;
    #####: 8260:        if (verbose) {
        -: 8261:          {
    #####: 8262:          fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: %s: part number %u\n",
    #####: 8263:                  progname, ifname, part);
        -: 8264:          }
    #####: 8265:        }
    #####: 8266:      }
    #####: 8267:      if (((int )flags___0 & 4) != 0) {
    #####: 8268:        if (inptr < insize) {
    #####: 8269:          tmp___36 = inptr;
    #####: 8270:          inptr ++;
    #####: 8271:          tmp___38 = (int )inbuf[tmp___36];
    #####: 8272:        } else {
        -: 8273:          {
    #####: 8274:          tmp___37 = fill_inbuf(0);
    #####: 8275:          tmp___38 = tmp___37;
        -: 8276:          }
        -: 8277:        }
    #####: 8278:        len = (unsigned int )tmp___38;
    #####: 8279:        if (inptr < insize) {
    #####: 8280:          tmp___39 = inptr;
    #####: 8281:          inptr ++;
    #####: 8282:          tmp___41 = (int )inbuf[tmp___39];
    #####: 8283:        } else {
        -: 8284:          {
    #####: 8285:          tmp___40 = fill_inbuf(0);
    #####: 8286:          tmp___41 = tmp___40;
        -: 8287:          }
        -: 8288:        }
    #####: 8289:        len |= (unsigned int )tmp___41 << 8;
    #####: 8290:        if (verbose) {
        -: 8291:          {
    #####: 8292:          fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: %s: extra field of %u bytes ignored\n",
    #####: 8293:                  progname, ifname, len);
        -: 8294:          }
    #####: 8295:        }
        -: 8296:        {
    #####: 8297:        while (1) {
        -: 8298:          while_continue: /* CIL Label */ ;
    #####: 8299:          tmp___43 = len;
    #####: 8300:          len --;
    #####: 8301:          if (! tmp___43) {
    #####: 8302:            goto while_break;
        -: 8303:          }
    #####: 8304:          if (inptr < insize) {
    #####: 8305:            tmp___42 = inptr;
    #####: 8306:            inptr ++;
    #####: 8307:          } else {
        -: 8308:            {
    #####: 8309:            fill_inbuf(0);
        -: 8310:            }
        -: 8311:          }
        -: 8312:        }
        -: 8313:        while_break: /* CIL Label */ ;
        -: 8314:        }
    #####: 8315:      }
    #####: 8316:      if (((int )flags___0 & 8) != 0) {
    #####: 8317:        if (no_name) {
    #####: 8318:          goto _L___0;
        -: 8319:        } else { //Added block
    #####: 8320:        if (to_stdout) {
    #####: 8321:          if (! list) {
    #####: 8322:            goto _L___0;
        -: 8323:          } else {
    #####: 8324:            goto _L___1;
        -: 8325:          }
    #####: 8326:        } else { //Added block
        -: 8327:        _L___1: 
    #####: 8328:        if (part_nb > 1) {
        -: 8329:          _L___0: 
        -: 8330:          {
    #####: 8331:          while (1) {
        -: 8332:            while_continue___0: /* CIL Label */ ;
    #####: 8333:            if (inptr < insize) {
    #####: 8334:              tmp___44 = inptr;
    #####: 8335:              inptr ++;
    #####: 8336:              c = (char )inbuf[tmp___44];
    #####: 8337:            } else {
        -: 8338:              {
    #####: 8339:              tmp___45 = fill_inbuf(0);
    #####: 8340:              c = (char )tmp___45;
        -: 8341:              }
        -: 8342:            }
    #####: 8343:            if (! ((int )c != 0)) {
    #####: 8344:              goto while_break___0;
        -: 8345:            }
        -: 8346:          }
        -: 8347:          while_break___0: /* CIL Label */ ;
        -: 8348:          }
    #####: 8349:        } else {
        -: 8350:          {
    #####: 8351:          tmp___46 = base_name(ofname);
    #####: 8352:          p = tmp___46;
    #####: 8353:          base = p;
        -: 8354:          }
        -: 8355:          {
    #####: 8356:          while (1) {
        -: 8357:            while_continue___1: /* CIL Label */ ;
    #####: 8358:            if (inptr < insize) {
    #####: 8359:              tmp___47 = inptr;
    #####: 8360:              inptr ++;
    #####: 8361:              tmp___49 = (int )inbuf[tmp___47];
    #####: 8362:            } else {
        -: 8363:              {
    #####: 8364:              tmp___48 = fill_inbuf(0);
    #####: 8365:              tmp___49 = tmp___48;
        -: 8366:              }
        -: 8367:            }
    #####: 8368:            *p = (char )tmp___49;
    #####: 8369:            tmp___50 = p;
    #####: 8370:            p ++;
    #####: 8371:            if ((int )*tmp___50 == 0) {
    #####: 8372:              goto while_break___1;
        -: 8373:            }
    #####: 8374:            if ((unsigned long )p >= (unsigned long )(ofname + sizeof(ofname))) {
        -: 8375:              {
    #####: 8376:              error((char *)"corrupted input -- file name too large");
        -: 8377:              }
    #####: 8378:            }
        -: 8379:          }
        -: 8380:          while_break___1: /* CIL Label */ ;
        -: 8381:          }
    #####: 8382:          if (! list) {
    #####: 8383:            if (base) {
    #####: 8384:              list = 0;
    #####: 8385:            }
    #####: 8386:          }
        -: 8387:        }
        -: 8388:        }
        -: 8389:        }
    #####: 8390:      }
    #####: 8391:      if (((int )flags___0 & 16) != 0) {
        -: 8392:        {
    #####: 8393:        while (1) {
        -: 8394:          while_continue___2: /* CIL Label */ ;
    #####: 8395:          if (inptr < insize) {
    #####: 8396:            tmp___51 = inptr;
    #####: 8397:            inptr ++;
    #####: 8398:            tmp___53 = (int )inbuf[tmp___51];
    #####: 8399:          } else {
        -: 8400:            {
    #####: 8401:            tmp___52 = fill_inbuf(0);
    #####: 8402:            tmp___53 = tmp___52;
        -: 8403:            }
        -: 8404:          }
    #####: 8405:          if (! (tmp___53 != 0)) {
    #####: 8406:            goto while_break___2;
        -: 8407:          }
        -: 8408:        }
        -: 8409:        while_break___2: /* CIL Label */ ;
        -: 8410:        }
    #####: 8411:      }
    #####: 8412:      if (part_nb == 1) {
    #####: 8413:        header_bytes = (off_t )((unsigned long )inptr + 2UL * sizeof(long ));
    #####: 8414:      }
    #####: 8415:    } else {
        -: 8416:      {
    #####: 8417:      tmp___58 = memcmp((void const   *)(magic), (void const   *)"PK\003\004", (size_t )2);
        -: 8418:      }
    #####: 8419:      if (tmp___58 == 0) {
    #####: 8420:        if (inptr == 2U) {
        -: 8421:          {
    #####: 8422:          tmp___59 = memcmp((void const   *)((char *)(inbuf)), (void const   *)"PK\003\004",
        -: 8423:                            (size_t )4);
        -: 8424:          }
    #####: 8425:          if (tmp___59 == 0) {
        -: 8426:            {
    #####: 8427:            inptr = 0U;
    #####: 8428:            work = & unzip;
    #####: 8429:            tmp___54 = check_zipfile(in);
        -: 8430:            }
    #####: 8431:            if (tmp___54 != 0) {
    #####: 8432:              return (-1);
        -: 8433:            }
    #####: 8434:            last_member = 1;
    #####: 8435:          } else {
    #####: 8436:            goto _L___3;
        -: 8437:          }
    #####: 8438:        } else {
    #####: 8439:          goto _L___3;
        -: 8440:        }
    #####: 8441:      } else {
        -: 8442:        _L___3: 
        -: 8443:        {
    #####: 8444:        tmp___57 = memcmp((void const   *)(magic), (void const   *)"\037\036", (size_t )2);
        -: 8445:        }
    #####: 8446:        if (tmp___57 == 0) {
    #####: 8447:          work = & unpack;
    #####: 8448:          method = 2;
    #####: 8449:        } else {
        -: 8450:          {
    #####: 8451:          tmp___56 = memcmp((void const   *)(magic), (void const   *)"\037\235", (size_t )2);
        -: 8452:          }
    #####: 8453:          if (tmp___56 == 0) {
    #####: 8454:            work = & unlzw;
    #####: 8455:            method = 1;
    #####: 8456:            last_member = 1;
    #####: 8457:          } else {
        -: 8458:            {
    #####: 8459:            tmp___55 = memcmp((void const   *)(magic), (void const   *)"\037\240",
        -: 8460:                              (size_t )2);
        -: 8461:            }
    #####: 8462:            if (tmp___55 == 0) {
    #####: 8463:              work = & unlzh;
    #####: 8464:              method = 3;
    #####: 8465:              last_member = 1;
    #####: 8466:            } else { //Added block
    #####: 8467:            if (force) {
    #####: 8468:              if (to_stdout) {
    #####: 8469:                if (! list) {
    #####: 8470:                  method = 0;
    #####: 8471:                  work = & copy;
    #####: 8472:                  inptr = 0U;
    #####: 8473:                  last_member = 1;
    #####: 8474:                }
    #####: 8475:              }
    #####: 8476:            }
        -: 8477:            }
        -: 8478:          }
        -: 8479:        }
        -: 8480:      }
        -: 8481:    }
        -: 8482:  }
    #####: 8483:  if (method >= 0) {
    #####: 8484:    return (method);
        -: 8485:  }
    #####: 8486:  if (part_nb == 1) {
        -: 8487:    {
    #####: 8488:    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\n%s: %s: not in gzip format\n",
    #####: 8489:            progname, ifname);
    #####: 8490:    exit_code = 1;
        -: 8491:    }
    #####: 8492:    return (-1);
        -: 8493:  } else {
    #####: 8494:    if ((int )magic[0] == 0) {
    #####: 8495:      inbyte = imagic1;
        -: 8496:      {
    #####: 8497:      while (1) {
        -: 8498:        while_continue___3: /* CIL Label */ ;
    #####: 8499:        if (! (inbyte == 0)) {
    #####: 8500:          goto while_break___3;
        -: 8501:        }
    #####: 8502:        goto __Cont;
        -: 8503:        __Cont: 
    #####: 8504:        if (inptr < insize) {
    #####: 8505:          tmp___62 = inptr;
    #####: 8506:          inptr ++;
    #####: 8507:          inbyte = (int )inbuf[tmp___62];
    #####: 8508:        } else {
        -: 8509:          {
    #####: 8510:          tmp___63 = fill_inbuf(1);
    #####: 8511:          inbyte = tmp___63;
        -: 8512:          }
        -: 8513:        }
        -: 8514:      }
        -: 8515:      while_break___3: /* CIL Label */ ;
        -: 8516:      }
    #####: 8517:      if (inbyte == -1) {
    #####: 8518:        if (verbose) {
    #####: 8519:          if (! quiet) {
        -: 8520:            {
    #####: 8521:            fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\n%s: %s: decompression OK, trailing zero bytes ignored\n",
    #####: 8522:                    progname, ifname);
        -: 8523:            }
    #####: 8524:          }
    #####: 8525:          if (exit_code == 0) {
    #####: 8526:            exit_code = 2;
    #####: 8527:          }
    #####: 8528:        }
    #####: 8529:        return (-3);
        -: 8530:      }
    #####: 8531:    }
    #####: 8532:    if (! quiet) {
        -: 8533:      {
    #####: 8534:      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\n%s: %s: decompression OK, trailing garbage ignored\n",
    #####: 8535:              progname, ifname);
        -: 8536:      }
    #####: 8537:    }
    #####: 8538:    if (exit_code == 0) {
    #####: 8539:      exit_code = 2;
    #####: 8540:    }
    #####: 8541:    return (-2);
        -: 8542:  }
        -: 8543:}
    #####: 8544:}
        -: 8545:static int first_time  =    1;
        -: 8546:static char *methods[9]  = 
        -: 8547:  {      (char *)"store",      (char *)"compr",      (char *)"pack ",      (char *)"lzh  ", 
        -: 8548:        (char *)"",      (char *)"",      (char *)"",      (char *)"", 
        -: 8549:        (char *)"defla"};
    #####: 8550:static void do_list(int ifd___0 , int method___0 ) 
        -: 8551:{ 
        -: 8552:  ulg crc___1 ;
        -: 8553:  char *date ;
        -: 8554:  int positive_off_t_width ;
        -: 8555:  off_t o ;
        -: 8556:  uch buf[8] ;
        -: 8557:  ssize_t tmp ;
        -: 8558:  char *tmp___0 ;
        -: 8559:
        -: 8560:  {
    #####: 8561:  positive_off_t_width = 1;
    #####: 8562:  o = -1L - (-1L << (sizeof(off_t ) * 8UL - 1UL));
        -: 8563:  {
    #####: 8564:  while (1) {
        -: 8565:    while_continue: /* CIL Label */ ;
    #####: 8566:    if (! (9L < o)) {
    #####: 8567:      goto while_break;
        -: 8568:    }
    #####: 8569:    positive_off_t_width ++;
    #####: 8570:    o /= 10L;
        -: 8571:  }
        -: 8572:  while_break: /* CIL Label */ ;
        -: 8573:  }
    #####: 8574:  if (first_time) {
    #####: 8575:    if (method___0 >= 0) {
    #####: 8576:      first_time = 0;
    #####: 8577:      if (verbose) {
        -: 8578:        {
    #####: 8579:        printf((char const   * __restrict  )"method  crc     date  time  ");
        -: 8580:        }
    #####: 8581:      }
    #####: 8582:      if (! quiet) {
        -: 8583:        {
    #####: 8584:        printf((char const   * __restrict  )"%*.*s %*.*s  ratio uncompressed_name\n",
    #####: 8585:               positive_off_t_width, positive_off_t_width, "compressed", positive_off_t_width,
    #####: 8586:               positive_off_t_width, "uncompressed");
        -: 8587:        }
    #####: 8588:      }
    #####: 8589:    } else {
    #####: 8590:      goto _L;
        -: 8591:    }
    #####: 8592:  } else { //Added block
        -: 8593:  _L: 
    #####: 8594:  if (method___0 < 0) {
    #####: 8595:    if (total_in <= 0L) {
    #####: 8596:      return;
        -: 8597:    } else { //Added block
    #####: 8598:    if (total_out <= 0L) {
    #####: 8599:      return;
        -: 8600:    }
        -: 8601:    }
    #####: 8602:    if (verbose) {
        -: 8603:      {
    #####: 8604:      printf((char const   * __restrict  )"                            ");
        -: 8605:      }
    #####: 8606:    }
    #####: 8607:    if (verbose) {
        -: 8608:      {
    #####: 8609:      fprint_off(stdout, total_in, positive_off_t_width);
    #####: 8610:      printf((char const   * __restrict  )" ");
    #####: 8611:      fprint_off(stdout, total_out, positive_off_t_width);
    #####: 8612:      printf((char const   * __restrict  )" ");
        -: 8613:      }
    #####: 8614:    } else { //Added block
    #####: 8615:    if (! quiet) {
        -: 8616:      {
    #####: 8617:      fprint_off(stdout, total_in, positive_off_t_width);
    #####: 8618:      printf((char const   * __restrict  )" ");
    #####: 8619:      fprint_off(stdout, total_out, positive_off_t_width);
    #####: 8620:      printf((char const   * __restrict  )" ");
        -: 8621:      }
    #####: 8622:    }
        -: 8623:    }
        -: 8624:    {
    #####: 8625:    display_ratio(total_out - (total_in - header_bytes), total_out, stdout);
    #####: 8626:    printf((char const   * __restrict  )" (totals)\n");
        -: 8627:    }
    #####: 8628:    return;
        -: 8629:  }
        -: 8630:  }
    #####: 8631:  crc___1 = (ulg )(~ 0);
    #####: 8632:  bytes_out = -1L;
    #####: 8633:  bytes_in = ifile_size;
    #####: 8634:  if (method___0 == 8) {
    #####: 8635:    if (! last_member) {
        -: 8636:      {
    #####: 8637:      bytes_in = lseek(ifd___0, (off_t )-8, 2);
        -: 8638:      }
    #####: 8639:      if (bytes_in != -1L) {
        -: 8640:        {
    #####: 8641:        bytes_in += 8L;
    #####: 8642:        tmp = read(ifd___0, (void *)((char *)(buf)), sizeof(buf));
        -: 8643:        }
    #####: 8644:        if ((unsigned long )tmp != sizeof(buf)) {
        -: 8645:          {
    #####: 8646:          read_error();
        -: 8647:          }
    #####: 8648:        }
    #####: 8649:        crc___1 = (ulg )((int )((ush )buf[0]) | ((int )((ush )buf[1]) << 8)) | ((ulg )((int )((ush )*((buf + 2) + 0)) | ((int )((ush )*((buf + 2) + 1)) << 8)) << 16);
    #####: 8650:        bytes_out = (off_t )((ulg )((int )((ush )*((buf + 4) + 0)) | ((int )((ush )*((buf + 4) + 1)) << 8)) | ((ulg )((int )((ush )*(((buf + 4) + 2) + 0)) | ((int )((ush )*(((buf + 4) + 2) + 1)) << 8)) << 16));
    #####: 8651:      }
    #####: 8652:    }
    #####: 8653:  }
        -: 8654:  {
    #####: 8655:  tmp___0 = ctime((time_t const   *)(& time_stamp));
    #####: 8656:  date = tmp___0 + 4;
    #####: 8657:  *(date + 12) = (char )'\000';
        -: 8658:  }
    #####: 8659:  if (verbose) {
        -: 8660:    {
    #####: 8661:    printf((char const   * __restrict  )"%5s %08lx %11s ", methods[method___0], crc___1,
    #####: 8662:           date);
        -: 8663:    }
    #####: 8664:  }
        -: 8665:  {
    #####: 8666:  fprint_off(stdout, bytes_in, positive_off_t_width);
    #####: 8667:  printf((char const   * __restrict  )" ");
    #####: 8668:  fprint_off(stdout, bytes_out, positive_off_t_width);
    #####: 8669:  printf((char const   * __restrict  )" ");
        -: 8670:  }
    #####: 8671:  if (bytes_in == -1L) {
    #####: 8672:    total_in = -1L;
    #####: 8673:    header_bytes = (off_t )0;
    #####: 8674:    bytes_out = header_bytes;
    #####: 8675:    bytes_in = bytes_out;
    #####: 8676:  } else { //Added block
    #####: 8677:  if (total_in >= 0L) {
    #####: 8678:    total_in += bytes_in;
    #####: 8679:  }
        -: 8680:  }
    #####: 8681:  if (bytes_out == -1L) {
    #####: 8682:    total_out = -1L;
    #####: 8683:    header_bytes = (off_t )0;
    #####: 8684:    bytes_out = header_bytes;
    #####: 8685:    bytes_in = bytes_out;
    #####: 8686:  } else { //Added block
    #####: 8687:  if (total_out >= 0L) {
    #####: 8688:    total_out += bytes_out;
    #####: 8689:  }
        -: 8690:  }
        -: 8691:  {
    #####: 8692:  display_ratio(bytes_out - (bytes_in - header_bytes), bytes_out, stdout);
    #####: 8693:  printf((char const   * __restrict  )" %s\n", ofname);
        -: 8694:  }
    #####: 8695:  return;
        -: 8696:}
    #####: 8697:}
    #####: 8698:static int same_file(struct stat *stat1 , struct stat *stat2 ) 
        -: 8699:{ 
        -: 8700:  int tmp ;
        -: 8701:
        -: 8702:  {
    #####: 8703:  if (stat1->st_ino == stat2->st_ino) {
    #####: 8704:    if (stat1->st_dev == stat2->st_dev) {
    #####: 8705:      tmp = 1;
    #####: 8706:    } else {
    #####: 8707:      tmp = 0;
        -: 8708:    }
    #####: 8709:  } else {
    #####: 8710:    tmp = 0;
        -: 8711:  }
    #####: 8712:  return (tmp);
        -: 8713:}
        -: 8714:}
    #####: 8715:static int name_too_long(char *name , struct stat *statb ) 
        -: 8716:{ 
        -: 8717:  int s ;
        -: 8718:  size_t tmp ;
        -: 8719:  char c ;
        -: 8720:  struct stat tstat ;
        -: 8721:  int res ;
        -: 8722:  int tmp___0 ;
        -: 8723:  int tmp___1 ;
        -: 8724:  int tmp___2 ;
        -: 8725:
        -: 8726:  {
        -: 8727:  {
    #####: 8728:  tmp = strlen((char const   *)name);
    #####: 8729:  s = (int )tmp;
    #####: 8730:  c = *(name + (s - 1));
    #####: 8731:  tstat = *statb;
    #####: 8732:  *(name + (s - 1)) = (char )'\000';
    #####: 8733:  tmp___0 = stat((char const   * __restrict  )name, (struct stat * __restrict  )(& tstat));
        -: 8734:  }
    #####: 8735:  if (tmp___0 == 0) {
        -: 8736:    {
    #####: 8737:    tmp___1 = same_file(statb, & tstat);
        -: 8738:    }
    #####: 8739:    if (tmp___1) {
    #####: 8740:      tmp___2 = 1;
    #####: 8741:    } else {
    #####: 8742:      tmp___2 = 0;
        -: 8743:    }
    #####: 8744:  } else {
    #####: 8745:    tmp___2 = 0;
        -: 8746:  }
    #####: 8747:  res = tmp___2;
    #####: 8748:  *(name + (s - 1)) = c;
    #####: 8749:  return (res);
        -: 8750:}
        -: 8751:}
    #####: 8752:static void shorten_name(char *name ) 
        -: 8753:{ 
        -: 8754:  int len ;
        -: 8755:  char *trunc ;
        -: 8756:  int plen ;
        -: 8757:  int min_part ;
        -: 8758:  char *p ;
        -: 8759:  size_t tmp ;
        -: 8760:  int tmp___0 ;
        -: 8761:  size_t tmp___1 ;
        -: 8762:  char *tmp___2 ;
        -: 8763:
        -: 8764:  {
        -: 8765:  {
    #####: 8766:  trunc = (char *)((void *)0);
    #####: 8767:  min_part = 3;
    #####: 8768:  tmp = strlen((char const   *)name);
    #####: 8769:  len = (int )tmp;
        -: 8770:  }
    #####: 8771:  if (decompress) {
    #####: 8772:    if (len <= 1) {
        -: 8773:      {
    #####: 8774:      error((char *)"name too short");
        -: 8775:      }
    #####: 8776:    }
    #####: 8777:    *(name + (len - 1)) = (char )'\000';
    #####: 8778:    return;
        -: 8779:  }
        -: 8780:  {
    #####: 8781:  p = get_suffix(name);
        -: 8782:  }
    #####: 8783:  if ((unsigned long )p == (unsigned long )((void *)0)) {
        -: 8784:    {
    #####: 8785:    error((char *)"can\'t recover suffix\n");
        -: 8786:    }
    #####: 8787:  }
    #####: 8788:  *p = (char )'\000';
    #####: 8789:  save_orig_name = 1;
    #####: 8790:  if (len > 4) {
        -: 8791:    {
    #####: 8792:    tmp___0 = strcmp((char const   *)(p - 4), ".tar");
        -: 8793:    }
    #####: 8794:    if (tmp___0 == 0) {
        -: 8795:      {
    #####: 8796:      strcpy((char * __restrict  )(p - 4), (char const   * __restrict  )".tgz");
        -: 8797:      }
    #####: 8798:      return;
        -: 8799:    }
    #####: 8800:  }
        -: 8801:  {
    #####: 8802:  while (1) {
        -: 8803:    while_continue: /* CIL Label */ ;
        -: 8804:    {
    #####: 8805:    p = strrchr((char const   *)name, '/');
        -: 8806:    }
    #####: 8807:    if (p) {
    #####: 8808:      p ++;
    #####: 8809:    } else {
    #####: 8810:      p = name;
        -: 8811:    }
        -: 8812:    {
    #####: 8813:    while (1) {
        -: 8814:      while_continue___0: /* CIL Label */ ;
    #####: 8815:      if (! *p) {
    #####: 8816:        goto while_break___0;
        -: 8817:      }
        -: 8818:      {
    #####: 8819:      tmp___1 = strcspn((char const   *)p, ".");
    #####: 8820:      plen = (int )tmp___1;
    #####: 8821:      p += plen;
        -: 8822:      }
    #####: 8823:      if (plen > min_part) {
    #####: 8824:        trunc = p - 1;
    #####: 8825:      }
    #####: 8826:      if (*p) {
    #####: 8827:        p ++;
    #####: 8828:      }
        -: 8829:    }
        -: 8830:    while_break___0: /* CIL Label */ ;
        -: 8831:    }
    #####: 8832:    if ((unsigned long )trunc == (unsigned long )((void *)0)) {
    #####: 8833:      min_part --;
    #####: 8834:      if (! (min_part != 0)) {
    #####: 8835:        goto while_break;
        -: 8836:      }
    #####: 8837:    } else {
    #####: 8838:      goto while_break;
        -: 8839:    }
        -: 8840:  }
        -: 8841:  while_break: /* CIL Label */ ;
        -: 8842:  }
    #####: 8843:  if ((unsigned long )trunc != (unsigned long )((void *)0)) {
        -: 8844:    {
    #####: 8845:    while (1) {
        -: 8846:      while_continue___1: /* CIL Label */ ;
    #####: 8847:      *(trunc + 0) = *(trunc + 1);
    #####: 8848:      tmp___2 = trunc;
    #####: 8849:      trunc ++;
    #####: 8850:      if (! *tmp___2) {
    #####: 8851:        goto while_break___1;
        -: 8852:      }
        -: 8853:    }
        -: 8854:    while_break___1: /* CIL Label */ ;
        -: 8855:    }
    #####: 8856:    trunc --;
    #####: 8857:  } else {
        -: 8858:    {
    #####: 8859:    trunc = strrchr((char const   *)name, (int )*("." + 0));
        -: 8860:    }
    #####: 8861:    if ((unsigned long )trunc == (unsigned long )((void *)0)) {
        -: 8862:      {
    #####: 8863:      error((char *)"internal error in shorten_name");
        -: 8864:      }
    #####: 8865:    }
    #####: 8866:    if ((int )*(trunc + 1) == 0) {
    #####: 8867:      trunc --;
    #####: 8868:    }
        -: 8869:  }
        -: 8870:  {
    #####: 8871:  strcpy((char * __restrict  )trunc, (char const   * __restrict  )z_suffix);
        -: 8872:  }
    #####: 8873:  return;
        -: 8874:}
    #####: 8875:}
    #####: 8876:static int check_ofname(void) 
        -: 8877:{ 
        -: 8878:  struct stat ostat ;
        -: 8879:  int *tmp ;
        -: 8880:  int *tmp___0 ;
        -: 8881:  int tmp___1 ;
        -: 8882:  int tmp___2 ;
        -: 8883:  int tmp___3 ;
        -: 8884:  char const   *tmp___4 ;
        -: 8885:  int tmp___5 ;
        -: 8886:  int tmp___6 ;
        -: 8887:  char response[80] ;
        -: 8888:  int tmp___7 ;
        -: 8889:  int tmp___8 ;
        -: 8890:  int tmp___10 ;
        -: 8891:  int tmp___11 ;
        -: 8892:  unsigned short const   **tmp___12 ;
        -: 8893:  int tmp___13 ;
        -: 8894:
        -: 8895:  {
        -: 8896:  {
    #####: 8897:  tmp = __errno_location();
    #####: 8898:  *tmp = 0;
        -: 8899:  }
        -: 8900:  {
    #####: 8901:  while (1) {
        -: 8902:    while_continue: /* CIL Label */ ;
        -: 8903:    {
    #####: 8904:    tmp___1 = stat((char const   * __restrict  )(ofname), (struct stat * __restrict  )(& ostat));
        -: 8905:    }
    #####: 8906:    if (! (tmp___1 != 0)) {
    #####: 8907:      goto while_break;
        -: 8908:    }
        -: 8909:    {
    #####: 8910:    tmp___0 = __errno_location();
        -: 8911:    }
    #####: 8912:    if (*tmp___0 != 36) {
    #####: 8913:      return (0);
        -: 8914:    }
        -: 8915:    {
    #####: 8916:    shorten_name(ofname);
        -: 8917:    }
        -: 8918:  }
        -: 8919:  while_break: /* CIL Label */ ;
        -: 8920:  }
    #####: 8921:  if (! decompress) {
        -: 8922:    {
    #####: 8923:    tmp___3 = name_too_long(ofname, & ostat);
        -: 8924:    }
    #####: 8925:    if (tmp___3) {
        -: 8926:      {
    #####: 8927:      shorten_name(ofname);
    #####: 8928:      tmp___2 = stat((char const   * __restrict  )(ofname), (struct stat * __restrict  )(& ostat));
        -: 8929:      }
    #####: 8930:      if (tmp___2 != 0) {
    #####: 8931:        return (0);
        -: 8932:      }
    #####: 8933:    }
    #####: 8934:  }
        -: 8935:  {
    #####: 8936:  tmp___6 = same_file(& istat, & ostat);
        -: 8937:  }
    #####: 8938:  if (tmp___6) {
        -: 8939:    {
    #####: 8940:    tmp___5 = strcmp((char const   *)(ifname), (char const   *)(ofname));
        -: 8941:    }
    #####: 8942:    if (tmp___5 == 0) {
    #####: 8943:      if (decompress) {
    #####: 8944:        tmp___4 = "de";
    #####: 8945:      } else {
    #####: 8946:        tmp___4 = "";
        -: 8947:      }
        -: 8948:      {
    #####: 8949:      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: %s: cannot %scompress onto itself\n",
    #####: 8950:              progname, ifname, tmp___4);
        -: 8951:      }
    #####: 8952:    } else {
        -: 8953:      {
    #####: 8954:      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: %s and %s are the same file\n",
    #####: 8955:              progname, ifname, ofname);
        -: 8956:      }
        -: 8957:    }
    #####: 8958:    exit_code = 1;
    #####: 8959:    return (1);
        -: 8960:  }
    #####: 8961:  if (! force) {
        -: 8962:    {
    #####: 8963:    strcpy((char * __restrict  )(response), (char const   * __restrict  )"n");
    #####: 8964:    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: %s already exists;",
    #####: 8965:            progname, ofname);
        -: 8966:    }
    #####: 8967:    if (foreground) {
        -: 8968:      {
    #####: 8969:      tmp___7 = fileno(stdin);
    #####: 8970:      tmp___8 = isatty(tmp___7);
        -: 8971:      }
    #####: 8972:      if (tmp___8) {
        -: 8973:        {
    #####: 8974:        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )" do you wish to overwrite (y or n)? ");
    #####: 8975:        fflush(stderr);
    #####: 8976:        fgets((char * __restrict  )(response), (int )(sizeof(response) - 1UL), (FILE * __restrict  )stdin);
        -: 8977:        }
    #####: 8978:      }
    #####: 8979:    }
        -: 8980:    {
    #####: 8981:    tmp___12 = __ctype_b_loc();
        -: 8982:    }
    #####: 8983:    if ((int const   )*(*tmp___12 + (int )((unsigned char )response[0])) & 256) {
        -: 8984:      {
    #####: 8985:      tmp___10 = tolower((int )((unsigned char )response[0]));
    #####: 8986:      tmp___11 = tmp___10;
        -: 8987:      }
    #####: 8988:    } else {
    #####: 8989:      tmp___11 = (int )((unsigned char )response[0]);
        -: 8990:    }
    #####: 8991:    if (tmp___11 != 121) {
        -: 8992:      {
    #####: 8993:      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\tnot overwritten\n");
        -: 8994:      }
    #####: 8995:      if (exit_code == 0) {
    #####: 8996:        exit_code = 2;
    #####: 8997:      }
    #####: 8998:      return (1);
        -: 8999:    }
    #####: 9000:  }
        -: 9001:  {
    #####: 9002:  tmp___13 = xunlink(ofname);
        -: 9003:  }
    #####: 9004:  if (tmp___13) {
        -: 9005:    {
    #####: 9006:    progerror(ofname);
        -: 9007:    }
    #####: 9008:    return (1);
        -: 9009:  }
    #####: 9010:  return (0);
        -: 9011:}
    #####: 9012:}
    #####: 9013:static void reset_times(char *name , struct stat *statb ) 
        -: 9014:{ 
        -: 9015:  struct utimbuf timep ;
        -: 9016:  int e ;
        -: 9017:  int *tmp ;
        -: 9018:  int *tmp___0 ;
        -: 9019:  int tmp___1 ;
        -: 9020:
        -: 9021:  {
        -: 9022:  {
    #####: 9023:  timep.actime = statb->st_atim.tv_sec;
    #####: 9024:  timep.modtime = statb->st_mtim.tv_sec;
    #####: 9025:  tmp___1 = utime((char const   *)name, (struct utimbuf  const  *)(& timep));
        -: 9026:  }
    #####: 9027:  if (tmp___1) {
    #####: 9028:    if (! ((statb->st_mode & 61440U) == 16384U)) {
        -: 9029:      {
    #####: 9030:      tmp = __errno_location();
    #####: 9031:      e = *tmp;
        -: 9032:      }
    #####: 9033:      if (! quiet) {
        -: 9034:        {
    #####: 9035:        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: ",
    #####: 9036:                progname);
        -: 9037:        }
    #####: 9038:      }
    #####: 9039:      if (exit_code == 0) {
    #####: 9040:        exit_code = 2;
    #####: 9041:      }
    #####: 9042:      if (! quiet) {
        -: 9043:        {
    #####: 9044:        tmp___0 = __errno_location();
    #####: 9045:        *tmp___0 = e;
    #####: 9046:        perror((char const   *)(ofname));
        -: 9047:        }
    #####: 9048:      }
    #####: 9049:    }
    #####: 9050:  }
    #####: 9051:  return;
        -: 9052:}
        -: 9053:}
    #####: 9054:static void copy_stat(struct stat *ifstat ) 
        -: 9055:{ 
        -: 9056:  int e ;
        -: 9057:  int *tmp ;
        -: 9058:  int *tmp___0 ;
        -: 9059:  int tmp___1 ;
        -: 9060:  int e___0 ;
        -: 9061:  int *tmp___2 ;
        -: 9062:  int *tmp___3 ;
        -: 9063:  int tmp___4 ;
        -: 9064:
        -: 9065:  {
    #####: 9066:  if (decompress) {
    #####: 9067:    if (time_stamp != 0L) {
    #####: 9068:      if (ifstat->st_mtim.tv_sec != time_stamp) {
    #####: 9069:        ifstat->st_mtim.tv_sec = time_stamp;
    #####: 9070:        if (verbose > 1) {
        -: 9071:          {
    #####: 9072:          fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: time stamp restored\n",
        -: 9073:                  ofname);
        -: 9074:          }
    #####: 9075:        }
    #####: 9076:      }
    #####: 9077:    }
    #####: 9078:  }
        -: 9079:  {
    #####: 9080:  reset_times(ofname, ifstat);
    #####: 9081:  tmp___1 = chmod((char const   *)(ofname), ifstat->st_mode & 4095U);
        -: 9082:  }
    #####: 9083:  if (tmp___1) {
        -: 9084:    {
    #####: 9085:    tmp = __errno_location();
    #####: 9086:    e = *tmp;
        -: 9087:    }
    #####: 9088:    if (! quiet) {
        -: 9089:      {
    #####: 9090:      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: ", progname);
        -: 9091:      }
    #####: 9092:    }
    #####: 9093:    if (exit_code == 0) {
    #####: 9094:      exit_code = 2;
    #####: 9095:    }
    #####: 9096:    if (! quiet) {
        -: 9097:      {
    #####: 9098:      tmp___0 = __errno_location();
    #####: 9099:      *tmp___0 = e;
    #####: 9100:      perror((char const   *)(ofname));
        -: 9101:      }
    #####: 9102:    }
    #####: 9103:  }
        -: 9104:  {
    #####: 9105:  chown((char const   *)(ofname), ifstat->st_uid, ifstat->st_gid);
    #####: 9106:  remove_ofname = 0;
    #####: 9107:  tmp___4 = xunlink(ifname);
        -: 9108:  }
    #####: 9109:  if (tmp___4) {
        -: 9110:    {
    #####: 9111:    tmp___2 = __errno_location();
    #####: 9112:    e___0 = *tmp___2;
        -: 9113:    }
    #####: 9114:    if (! quiet) {
        -: 9115:      {
    #####: 9116:      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: ", progname);
        -: 9117:      }
    #####: 9118:    }
    #####: 9119:    if (exit_code == 0) {
    #####: 9120:      exit_code = 2;
    #####: 9121:    }
    #####: 9122:    if (! quiet) {
        -: 9123:      {
    #####: 9124:      tmp___3 = __errno_location();
    #####: 9125:      *tmp___3 = e___0;
    #####: 9126:      perror((char const   *)(ifname));
        -: 9127:      }
    #####: 9128:    }
    #####: 9129:  }
    #####: 9130:  return;
        -: 9131:}
        -: 9132:}
    #####: 9133:static void treat_dir(char *dir ) 
        -: 9134:{ 
        -: 9135:  struct dirent *dp ;
        -: 9136:  DIR *dirp ;
        -: 9137:  char nbuf[1024] ;
        -: 9138:  int len ;
        -: 9139:  int tmp ;
        -: 9140:  int tmp___0 ;
        -: 9141:  size_t tmp___1 ;
        -: 9142:  int tmp___2 ;
        -: 9143:  size_t tmp___3 ;
        -: 9144:  int *tmp___4 ;
        -: 9145:  int *tmp___5 ;
        -: 9146:  int tmp___6 ;
        -: 9147:
        -: 9148:  {
        -: 9149:  {
    #####: 9150:  dirp = opendir((char const   *)dir);
        -: 9151:  }
    #####: 9152:  if ((unsigned long )dirp == (unsigned long )((void *)0)) {
        -: 9153:    {
    #####: 9154:    progerror(dir);
        -: 9155:    }
    #####: 9156:    return;
        -: 9157:  }
        -: 9158:  {
    #####: 9159:  while (1) {
        -: 9160:    while_continue: /* CIL Label */ ;
        -: 9161:    {
    #####: 9162:    tmp___4 = __errno_location();
    #####: 9163:    *tmp___4 = 0;
    #####: 9164:    dp = readdir(dirp);
        -: 9165:    }
    #####: 9166:    if (! ((unsigned long )dp != (unsigned long )((void *)0))) {
    #####: 9167:      goto while_break;
        -: 9168:    }
        -: 9169:    {
    #####: 9170:    tmp = strcmp((char const   *)(dp->d_name), ".");
        -: 9171:    }
    #####: 9172:    if (tmp == 0) {
    #####: 9173:      goto while_continue;
        -: 9174:    } else {
        -: 9175:      {
    #####: 9176:      tmp___0 = strcmp((char const   *)(dp->d_name), "..");
        -: 9177:      }
    #####: 9178:      if (tmp___0 == 0) {
    #####: 9179:        goto while_continue;
        -: 9180:      }
        -: 9181:    }
        -: 9182:    {
    #####: 9183:    tmp___1 = strlen((char const   *)dir);
    #####: 9184:    len = (int )tmp___1;
    #####: 9185:    tmp___3 = strlen((char const   *)(dp->d_name));
        -: 9186:    }
    #####: 9187:    if (((size_t )len + tmp___3) + 1UL < 1023UL) {
        -: 9188:      {
    #####: 9189:      strcpy((char * __restrict  )(nbuf), (char const   * __restrict  )dir);
        -: 9190:      }
    #####: 9191:      if (len != 0) {
    #####: 9192:        tmp___2 = len;
    #####: 9193:        len ++;
    #####: 9194:        nbuf[tmp___2] = (char )'/';
    #####: 9195:      }
        -: 9196:      {
    #####: 9197:      strcpy((char * __restrict  )(nbuf + len), (char const   * __restrict  )(dp->d_name));
    #####: 9198:      treat_file(nbuf);
        -: 9199:      }
    #####: 9200:    } else {
        -: 9201:      {
    #####: 9202:      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: %s/%s: pathname too long\n",
    #####: 9203:              progname, dir, dp->d_name);
    #####: 9204:      exit_code = 1;
        -: 9205:      }
        -: 9206:    }
        -: 9207:  }
        -: 9208:  while_break: /* CIL Label */ ;
        -: 9209:  }
        -: 9210:  {
    #####: 9211:  tmp___5 = __errno_location();
        -: 9212:  }
    #####: 9213:  if (*tmp___5 != 0) {
        -: 9214:    {
    #####: 9215:    progerror(dir);
        -: 9216:    }
    #####: 9217:  }
        -: 9218:  {
    #####: 9219:  tmp___6 = closedir(dirp);
        -: 9220:  }
    #####: 9221:  if (tmp___6 != 0) {
        -: 9222:    {
    #####: 9223:    progerror(dir);
        -: 9224:    }
    #####: 9225:  }
    #####: 9226:  return;
        -: 9227:}
    #####: 9228:}
        -: 9229:static int in_exit  =    0;
        1: 9230:static void do_exit(int exitcode ) 
        -: 9231:{ 
        -: 9232:
        -: 9233:
        -: 9234:  {
        1: 9235:  if (in_exit) {
        -: 9236:    {
    #####: 9237:    exit(exitcode);
        -: 9238:    }
        -: 9239:  }
        1: 9240:  in_exit = 1;
        1: 9241:  if ((unsigned long )env != (unsigned long )((void *)0)) {
        -: 9242:    {
    #####: 9243:    free((void *)env);
    #####: 9244:    env = (char *)((void *)0);
        -: 9245:    }
    #####: 9246:  }
        1: 9247:  if ((unsigned long )args != (unsigned long )((void *)0)) {
        -: 9248:    {
    #####: 9249:    free((void *)((char *)args));
    #####: 9250:    args = (char **)((void *)0);
        -: 9251:    }
    #####: 9252:  }
        -: 9253:  {
        1: 9254:  exit(exitcode);
        -: 9255:  }
        -: 9256:}
        -: 9257:}
    #####: 9258:void abort_gzip(void) 
        -: 9259:{ 
        -: 9260:
        -: 9261:
        -: 9262:  {
    #####: 9263:  if (remove_ofname) {
        -: 9264:    {
    #####: 9265:    close(ofd);
    #####: 9266:    xunlink(ofname);
        -: 9267:    }
    #####: 9268:  }
        -: 9269:  {
    #####: 9270:  do_exit(1);
        -: 9271:  }
    #####: 9272:  return;
        -: 9273:}
        -: 9274:}
        -: 9275:#pragma merger("0","/tmp/cil-Ls8epKGB.i","")
